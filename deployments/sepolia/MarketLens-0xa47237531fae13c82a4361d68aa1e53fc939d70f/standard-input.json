{"language":"Solidity","sources":{"src/lens/MarketLens.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.20;\n\nimport './MarketData.sol';\nimport './TokenData.sol';\nimport './HooksInstanceData.sol';\nimport './HooksDataForBorrower.sol';\n\ncontract MarketLens {\n  WildcatArchController public immutable archController;\n  HooksFactory public immutable hooksFactory;\n\n  constructor(address _archController, address _hooksFactory) {\n    archController = WildcatArchController(_archController);\n    hooksFactory = HooksFactory(_hooksFactory);\n  }\n\n  // ========================================================================== //\n  //                         All hooks data for borrower                        //\n  // ========================================================================== //\n\n  function getHooksDataForBorrower(\n    address borrower\n  ) public view returns (HooksDataForBorrower memory data) {\n    data.fill(archController, hooksFactory, borrower);\n  }\n\n  // ========================================================================== //\n  //                        Hooks instances for borrower                        //\n  // ========================================================================== //\n\n  function getHooksInstancesForBorrower(\n    address borrower\n  ) public view returns (HooksInstanceData[] memory arr) {\n    address[] memory hooksInstances = hooksFactory.getHooksInstancesForBorrower(borrower);\n    arr = new HooksInstanceData[](arr.length);\n    for (uint i; i < hooksInstances.length; i++) {\n      arr[i].fill(hooksInstances[i], hooksFactory);\n    }\n  }\n\n  // ========================================================================== //\n  //                        Hooks templates for borrower                        //\n  // ========================================================================== //\n\n  function getHooksTemplateForBorrower(\n    address borrower,\n    address hooksTemplate\n  ) public view returns (HooksTemplateData memory data) {\n    data.fill(hooksFactory, hooksTemplate, borrower);\n  }\n\n  function getHooksTemplatesForBorrower(\n    address borrower,\n    address[] memory hooksTemplates\n  ) public view returns (HooksTemplateData[] memory data) {\n    data = new HooksTemplateData[](hooksTemplates.length);\n    for (uint i; i < hooksTemplates.length; i++) {\n      data[i].fill(hooksFactory, hooksTemplates[i], borrower);\n    }\n  }\n\n  function getAllHooksTemplatesForBorrower(\n    address borrower\n  ) public view returns (HooksTemplateData[] memory data) {\n    address[] memory hooksTemplates = hooksFactory.getHooksTemplates();\n    return getHooksTemplatesForBorrower(borrower, hooksTemplates);\n  }\n\n  // ========================================================================== //\n  //                                 Token info                                 //\n  // ========================================================================== //\n\n  function getTokenInfo(address token) public view returns (TokenMetadata memory info) {\n    info.fill(token);\n  }\n\n  function getTokensInfo(\n    address[] memory tokens\n  ) public view returns (TokenMetadata[] memory info) {\n    info = new TokenMetadata[](tokens.length);\n    for (uint256 i; i < tokens.length; i++) {\n      info[i].fill(tokens[i]);\n    }\n  }\n\n  // ========================================================================== //\n  //                                   Markets                                  //\n  // ========================================================================== //\n\n  function getMarketsForHooksTemplateCount(address hooksTemplate) external view returns (uint256) {\n    return hooksFactory.getMarketsForHooksTemplateCount(hooksTemplate);\n  }\n\n  function getMarketData(address market) public view returns (MarketData memory data) {\n    data.fill(WildcatMarket(market));\n  }\n\n  function getMarketsData(address[] memory markets) public view returns (MarketData[] memory data) {\n    data = new MarketData[](markets.length);\n    for (uint256 i; i < markets.length; i++) {\n      data[i].fill(WildcatMarket(markets[i]));\n    }\n  }\n\n  function getPaginatedMarketsDataForHooksTemplate(\n    address hooksTemplate,\n    uint256 start,\n    uint256 end\n  ) public view returns (MarketData[] memory data) {\n    address[] memory markets = hooksFactory.getMarketsForHooksTemplate(hooksTemplate, start, end);\n    return getMarketsData(markets);\n  }\n\n  function getAllMarketsDataForHooksTemplate(\n    address hooksTemplate\n  ) external view returns (MarketData[] memory data) {\n    address[] memory markets = hooksFactory.getMarketsForHooksTemplate(hooksTemplate);\n    return getMarketsData(markets);\n  }\n\n  // ========================================================================== //\n  //                         Markets with lender status                         //\n  // ========================================================================== //\n\n  function getMarketDataWithLenderStatus(\n    address lender,\n    address market\n  ) public view returns (MarketDataWithLenderStatus memory data) {\n    data.fill(WildcatMarket(market), lender);\n  }\n\n  function getMarketsDataWithLenderStatus(\n    address lender,\n    address[] memory markets\n  ) public view returns (MarketDataWithLenderStatus[] memory data) {\n    data = new MarketDataWithLenderStatus[](markets.length);\n    for (uint256 i; i < markets.length; i++) {\n      data[i].fill(WildcatMarket(markets[i]), lender);\n    }\n  }\n\n  // ========================================================================== //\n  //                        Lender status in market only                        //\n  // ========================================================================== //\n\n  function getLenderAccountData(\n    address lender,\n    address market\n  ) external view returns (LenderAccountData memory data) {\n    data.fill(WildcatMarket(market), lender);\n  }\n\n  function getLenderAccountData(\n    address lender,\n    address[] memory markets\n  ) external view returns (LenderAccountData[] memory arr) {\n    arr = new LenderAccountData[](markets.length);\n    for (uint256 i; i < markets.length; i++) {\n      arr[i].fill(WildcatMarket(markets[i]), lender);\n    }\n  }\n\n  function queryLenderAccount(\n    LenderAccountQuery memory query\n  ) external view returns (LenderAccountQueryResult memory result) {\n    result.fill(query);\n  }\n\n  function queryLenderAccounts(\n    LenderAccountQuery[] memory queries\n  ) external view returns (LenderAccountQueryResult[] memory result) {\n    result = new LenderAccountQueryResult[](queries.length);\n    for (uint256 i; i < queries.length; i++) {\n      result[i].fill(queries[i]);\n    }\n  }\n\n  /* -------------------------------------------------------------------------- */\n  /*                          Withdrawal batch queries                          */\n  /* -------------------------------------------------------------------------- */\n\n  function getWithdrawalBatchData(\n    address market,\n    uint32 expiry\n  ) public view returns (WithdrawalBatchData memory data) {\n    data.fill(WildcatMarket(market), expiry);\n  }\n\n  function getWithdrawalBatchesData(\n    address market,\n    uint32[] memory expiries\n  ) public view returns (WithdrawalBatchData[] memory data) {\n    data = new WithdrawalBatchData[](expiries.length);\n    for (uint256 i; i < expiries.length; i++) {\n      data[i].fill(WildcatMarket(market), expiries[i]);\n    }\n  }\n\n  /* -------------------------------------------------------------------------- */\n  /*                    Withdrawal batch queries with account                   */\n  /* -------------------------------------------------------------------------- */\n\n  function getWithdrawalBatchesDataWithLenderStatus(\n    address market,\n    uint32[] memory expiries,\n    address lender\n  ) external view returns (WithdrawalBatchDataWithLenderStatus[] memory statuses) {\n    statuses = new WithdrawalBatchDataWithLenderStatus[](expiries.length);\n    for (uint256 i; i < expiries.length; i++) {\n      statuses[i].fill(WildcatMarket(market), expiries[i], lender);\n    }\n  }\n\n  function getWithdrawalBatchDataWithLenderStatus(\n    address market,\n    uint32 expiry,\n    address lender\n  ) external view returns (WithdrawalBatchDataWithLenderStatus memory status) {\n    status.fill(WildcatMarket(market), expiry, lender);\n  }\n\n  function getWithdrawalBatchDataWithLendersStatus(\n    address market,\n    uint32 expiry,\n    address[] calldata lenders\n  )\n    external\n    view\n    returns (WithdrawalBatchData memory batch, WithdrawalBatchLenderStatus[] memory statuses)\n  {\n    batch.fill(WildcatMarket(market), expiry);\n\n    statuses = new WithdrawalBatchLenderStatus[](lenders.length);\n    for (uint256 i; i < lenders.length; i++) {\n      statuses[i].fill(WildcatMarket(market), batch, lenders[i]);\n    }\n  }\n}\n"},"src/lens/MarketData.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.20;\n\nimport '../WildcatArchController.sol';\nimport '../market/WildcatMarket.sol';\nimport '../types/HooksConfig.sol';\nimport '../access/MarketConstraintHooks.sol';\nimport './HooksConfigData.sol';\nimport './HooksInstanceData.sol';\nimport './HooksTemplateData.sol';\nimport './LenderAccountData.sol';\nimport './TokenData.sol';\nimport './WithdrawalBatchData.sol';\n\nusing MarketDataLib for MarketData global;\nusing MarketDataLib for MarketDataWithLenderStatus global;\nusing MarketDataLib for LenderAccountQueryResult global;\n\nstruct MarketData {\n  // -- Tokens metadata --\n  TokenMetadata marketToken;\n  TokenMetadata underlyingToken;\n  address hooksFactory;\n  address borrower;\n  MarketHooksData hooksConfig;\n  uint256 withdrawalBatchDuration;\n  address feeRecipient;\n  uint256 delinquencyFeeBips;\n  uint256 delinquencyGracePeriod;\n  HooksInstanceData hooks;\n  // -- Temporary excess reserve ratio --\n  bool temporaryReserveRatio;\n  uint256 originalAnnualInterestBips;\n  uint256 originalReserveRatioBips;\n  uint256 temporaryReserveRatioExpiry;\n  // -- Market state --\n  bool isClosed;\n  uint256 protocolFeeBips;\n  uint256 reserveRatioBips;\n  uint256 annualInterestBips;\n  uint256 scaleFactor;\n  uint256 totalSupply;\n  uint256 maxTotalSupply;\n  uint256 scaledTotalSupply;\n  uint256 totalAssets;\n  uint256 lastAccruedProtocolFees;\n  uint256 normalizedUnclaimedWithdrawals;\n  uint256 scaledPendingWithdrawals;\n  uint256 pendingWithdrawalExpiry;\n  bool isDelinquent;\n  uint256 timeDelinquent;\n  uint256 lastInterestAccruedTimestamp;\n  uint32[] unpaidWithdrawalBatchExpiries;\n  uint256 coverageLiquidity;\n}\n\nstruct MarketDataWithLenderStatus {\n  MarketData market;\n  LenderAccountData lenderStatus;\n}\n\nstruct LenderAccountQuery {\n  address lender;\n  address market;\n  uint32[] withdrawalBatchExpiries;\n}\n\nstruct LenderAccountQueryResult {\n  MarketData market;\n  LenderAccountData lenderStatus;\n  WithdrawalBatchDataWithLenderStatus[] withdrawalBatches;\n}\n\nlibrary MarketDataLib {\n  using MathUtils for uint256;\n\n  error NotV2Market();\n\n  function fill(MarketData memory data, WildcatMarket market) internal view {\n    data.marketToken.fill(address(market));\n    data.underlyingToken.fill(market.asset());\n    string memory version = market.version();\n    bool isV2;\n    assembly {\n      let versionByte := and(mload(add(version, 1)), 0xff)\n      isV2 := eq(versionByte, 0x32)\n    }\n    if (!isV2) {\n      revert NotV2Market();\n    }\n    data.fillConfig();\n    data.fillTemporaryExcessReserveRatio();\n    data.fillState();\n  }\n\n  function fillConfig(MarketData memory data) internal view {\n    address marketAddress = address(data.marketToken.token);\n    WildcatMarket market = WildcatMarket(marketAddress);\n    data.hooksFactory = market.factory();\n    data.borrower = market.borrower();\n    data.hooksConfig.fill(marketAddress);\n    data.withdrawalBatchDuration = market.withdrawalBatchDuration();\n    data.feeRecipient = market.feeRecipient();\n    data.delinquencyFeeBips = market.delinquencyFeeBips();\n    data.delinquencyGracePeriod = market.delinquencyGracePeriod();\n    address hooksAddress = data.hooksConfig.hooksAddress;\n    data.hooks.fill(hooksAddress, HooksFactory(data.hooksFactory));\n  }\n\n  function fillTemporaryExcessReserveRatio(MarketData memory data) internal view {\n    address marketAddress = data.marketToken.token;\n    address hooksAddress = data.hooks.hooksAddress;\n    (\n      data.originalAnnualInterestBips,\n      data.originalReserveRatioBips,\n      data.temporaryReserveRatioExpiry\n    ) = MarketConstraintHooks(hooksAddress).temporaryExcessReserveRatio(marketAddress);\n    data.temporaryReserveRatio = data.temporaryReserveRatioExpiry > 0;\n  }\n\n  function fillState(MarketData memory data) internal view {\n    WildcatMarket market = WildcatMarket(data.marketToken.token);\n    MarketState memory state = market.currentState();\n    data.isClosed = state.isClosed;\n    data.protocolFeeBips = state.protocolFeeBips;\n    data.reserveRatioBips = state.reserveRatioBips;\n    data.annualInterestBips = state.annualInterestBips;\n    data.scaleFactor = state.scaleFactor;\n    data.totalSupply = state.totalSupply();\n    data.maxTotalSupply = state.maxTotalSupply;\n    data.scaledTotalSupply = state.scaledTotalSupply;\n    data.totalAssets = market.totalAssets();\n    data.lastAccruedProtocolFees = market.accruedProtocolFees();\n    data.normalizedUnclaimedWithdrawals = state.normalizedUnclaimedWithdrawals;\n    data.scaledPendingWithdrawals = state.scaledPendingWithdrawals;\n    data.pendingWithdrawalExpiry = state.pendingWithdrawalExpiry;\n    data.isDelinquent = state.isDelinquent;\n    data.timeDelinquent = state.timeDelinquent;\n    data.lastInterestAccruedTimestamp = state.lastInterestAccruedTimestamp;\n\n    if (state.pendingWithdrawalExpiry == 0) {\n      uint32 expiredBatchExpiry = market.previousState().pendingWithdrawalExpiry;\n      if (expiredBatchExpiry > 0) {\n        WithdrawalBatch memory expiredBatch = market.getWithdrawalBatch(expiredBatchExpiry);\n\n        if (expiredBatch.scaledTotalAmount == expiredBatch.scaledAmountBurned) {\n          data.pendingWithdrawalExpiry = expiredBatchExpiry;\n        } else {\n          uint32[] memory unpaidWithdrawalBatchExpiries = data.unpaidWithdrawalBatchExpiries;\n          data.unpaidWithdrawalBatchExpiries = new uint32[](\n            unpaidWithdrawalBatchExpiries.length + 1\n          );\n          for (uint256 i; i < unpaidWithdrawalBatchExpiries.length; i++) {\n            data.unpaidWithdrawalBatchExpiries[i] = unpaidWithdrawalBatchExpiries[i];\n          }\n          data.unpaidWithdrawalBatchExpiries[\n            unpaidWithdrawalBatchExpiries.length\n          ] = expiredBatchExpiry;\n        }\n      }\n    }\n\n    data.coverageLiquidity = state.liquidityRequired();\n  }\n\n  function getUnpaidAndPendingWithdrawalBatches(\n    MarketData memory data\n  ) internal view returns (WithdrawalBatchData[] memory unpaidAndPendingWithdrawalBatches) {\n    WildcatMarket market = WildcatMarket(data.marketToken.token);\n    bool hasPendingWithdrawalBatch = data.pendingWithdrawalExpiry > 0;\n    uint256 unpaidExpiriesCount = data.unpaidWithdrawalBatchExpiries.length;\n    unpaidAndPendingWithdrawalBatches = new WithdrawalBatchData[](\n      unpaidExpiriesCount + (hasPendingWithdrawalBatch ? 1 : 0)\n    );\n    for (uint256 i; i < unpaidExpiriesCount; i++) {\n      unpaidAndPendingWithdrawalBatches[i].fill(market, data.unpaidWithdrawalBatchExpiries[i]);\n    }\n    if (data.pendingWithdrawalExpiry > 0) {\n      unpaidAndPendingWithdrawalBatches[unpaidExpiriesCount].fill(\n        market,\n        uint32(data.pendingWithdrawalExpiry)\n      );\n    }\n  }\n\n  function fill(\n    MarketDataWithLenderStatus memory data,\n    WildcatMarket market,\n    address lender\n  ) internal view {\n    data.market.fill(market);\n    data.lenderStatus.fill(data.market, lender);\n  }\n\n  function fill(\n    LenderAccountQueryResult memory result,\n    LenderAccountQuery memory query\n  ) internal view {\n    WildcatMarket market = WildcatMarket(query.market);\n    result.market.fill(market);\n    result.lenderStatus.fill(result.market, query.lender);\n\n    result.withdrawalBatches = new WithdrawalBatchDataWithLenderStatus[](\n      query.withdrawalBatchExpiries.length\n    );\n    for (uint256 i; i < query.withdrawalBatchExpiries.length; i++) {\n      result.withdrawalBatches[i].fill(market, query.withdrawalBatchExpiries[i], query.lender);\n    }\n  }\n}\n"},"src/lens/TokenData.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.20;\n\nimport '../interfaces/IERC20.sol';\n\nusing TokenMetadataLib for TokenMetadata global;\n\nstruct TokenMetadata {\n  address token;\n  string name;\n  string symbol;\n  uint256 decimals;\n  bool isMock;\n}\n\nlibrary TokenMetadataLib {\n  function checkIsMock(address tokenAddress) internal view returns (bool isMock) {\n    assembly {\n      mstore(0, 0x28ccaa29)\n      let success := staticcall(gas(), tokenAddress, 0x1c, 4, 0, 32)\n      isMock := and(success, eq(mload(0), 1))\n    }\n  }\n\n  function fill(TokenMetadata memory data, address tokenAddress) internal view {\n    if (tokenAddress == address(0)) {\n      return;\n    }\n    data.token = tokenAddress;\n    IERC20 token = IERC20(tokenAddress);\n    data.name = token.name();\n    data.symbol = token.symbol();\n    data.decimals = token.decimals();\n    data.isMock = checkIsMock(tokenAddress);\n  }\n}\n"},"src/lens/HooksInstanceData.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.20;\n\nimport '../interfaces/WildcatStructsAndEnums.sol';\nimport { OpenTermHooks, HookedMarket as OpenTermHookedMarket } from '../access/OpenTermHooks.sol';\nimport { FixedTermHooks, HookedMarket as FixedTermHookedMarket } from '../access/FixedTermHooks.sol';\nimport '../access/IHooks.sol';\nimport '../HooksFactory.sol';\nimport './HooksConfigData.sol';\nimport './HooksTemplateData.sol';\nimport './RoleProviderData.sol';\n\nusing HooksInstanceDataLib for HooksInstanceData global;\n\nstruct HooksInstanceData {\n  address hooksAddress;\n  address borrower;\n  HooksInstanceKind kind;\n  address hooksTemplate;\n  string hooksTemplateName;\n  MarketParameterConstraints constraints;\n  HooksDeploymentFlags deploymentFlags;\n  RoleProviderData[] pullProviders;\n  RoleProviderData[] pushProviders;\n  uint256 totalMarkets;\n}\n\nlibrary HooksInstanceDataLib {\n  using RoleProviderDataLib for *;\n\n  function fill(\n    HooksInstanceData memory data,\n    address hooksAddress,\n    HooksFactory factory\n  ) internal view {\n    data.hooksAddress = hooksAddress;\n\n    data.hooksTemplate = factory.getHooksTemplateForInstance(hooksAddress);\n    data.hooksTemplateName = factory.getHooksTemplateDetails(data.hooksTemplate).name;\n\n    IHooks hooks = IHooks(hooksAddress);\n\n    bytes32 versionHash = keccak256(bytes(data.hooksTemplateName));\n    if (versionHash == keccak256('OpenTermHooks')) {\n      data.kind = HooksInstanceKind.OpenTerm;\n    } else if (versionHash == keccak256('FixedTermHooks')) {\n      data.kind = HooksInstanceKind.FixedTermLoan;\n    }\n\n    if (data.kind != HooksInstanceKind.Unknown) {\n      OpenTermHooks hooks = OpenTermHooks(hooksAddress);\n      if (data.borrower == address(0)) {\n        data.borrower = hooks.borrower();\n      }\n      data.pullProviders = hooks.getPullProviders().toRoleProviderDatas();\n      data.pushProviders = hooks.getPushProviders().toRoleProviderDatas();\n      data.constraints = hooks.getParameterConstraints();\n    }\n    data.deploymentFlags.fill(hooks.config());\n    data.totalMarkets = factory.getMarketsForHooksInstanceCount(hooksAddress);\n  }\n}\n"},"src/lens/HooksDataForBorrower.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport './HooksTemplateData.sol';\nimport './HooksInstanceData.sol';\nimport '../WildcatArchController.sol';\n\nusing HooksDataForBorrowerLib for HooksDataForBorrower global;\n\nstruct HooksDataForBorrower {\n  address borrower;\n  bool isRegisteredBorrower;\n  HooksTemplateData[] hooksTemplates;\n  HooksInstanceData[] hooksInstances;\n}\n\nlibrary HooksDataForBorrowerLib {\n  function fill(\n    HooksDataForBorrower memory data,\n    WildcatArchController archController,\n    HooksFactory factory,\n    address borrower\n  ) internal view {\n    data.borrower = borrower;\n    data.isRegisteredBorrower = archController.isRegisteredBorrower(borrower);\n    address[] memory hooksInstances = factory.getHooksInstancesForBorrower(borrower);\n    data.hooksInstances = new HooksInstanceData[](hooksInstances.length);\n    for (uint i; i < hooksInstances.length; i++) {\n      data.hooksInstances[i].fill(hooksInstances[i], factory);\n    }\n    address[] memory hooksTemplates = factory.getHooksTemplates();\n    data.hooksTemplates = new HooksTemplateData[](hooksTemplates.length);\n    for (uint i; i < hooksTemplates.length; i++) {\n      data.hooksTemplates[i].fill(factory, hooksTemplates[i], borrower);\n    }\n  }\n}\n"},"src/WildcatArchController.sol":{"content":"// SPDX-License-Identifier: Apache-2.0 WITH LicenseRef-Commons-Clause-1.0\npragma solidity >=0.8.20;\n\nimport { EnumerableSet } from 'openzeppelin/contracts/utils/structs/EnumerableSet.sol';\nimport 'solady/auth/Ownable.sol';\nimport './spherex/SphereXConfig.sol';\nimport './libraries/MathUtils.sol';\nimport './interfaces/ISphereXProtectedRegisteredBase.sol';\n\ncontract WildcatArchController is SphereXConfig, Ownable {\n  using EnumerableSet for EnumerableSet.AddressSet;\n\n  // ========================================================================== //\n  //                                   Storage                                  //\n  // ========================================================================== //\n\n  EnumerableSet.AddressSet internal _markets;\n  EnumerableSet.AddressSet internal _controllerFactories;\n  EnumerableSet.AddressSet internal _borrowers;\n  EnumerableSet.AddressSet internal _controllers;\n  EnumerableSet.AddressSet internal _assetBlacklist;\n\n  // ========================================================================== //\n  //                              Events and Errors                             //\n  // ========================================================================== //\n\n  error NotControllerFactory();\n  error NotController();\n\n  error BorrowerAlreadyExists();\n  error ControllerFactoryAlreadyExists();\n  error ControllerAlreadyExists();\n  error MarketAlreadyExists();\n\n  error BorrowerDoesNotExist();\n  error AssetAlreadyBlacklisted();\n  error ControllerFactoryDoesNotExist();\n  error ControllerDoesNotExist();\n  error AssetNotBlacklisted();\n  error MarketDoesNotExist();\n\n  event MarketAdded(address indexed controller, address market);\n  event MarketRemoved(address market);\n\n  event ControllerFactoryAdded(address controllerFactory);\n  event ControllerFactoryRemoved(address controllerFactory);\n\n  event BorrowerAdded(address borrower);\n  event BorrowerRemoved(address borrower);\n\n  event AssetBlacklisted(address asset);\n  event AssetPermitted(address asset);\n\n  event ControllerAdded(address indexed controllerFactory, address controller);\n  event ControllerRemoved(address controller);\n\n  // ========================================================================== //\n  //                                 Constructor                                //\n  // ========================================================================== //\n\n  constructor() SphereXConfig(msg.sender, address(0), address(0)) {\n    _initializeOwner(msg.sender);\n  }\n\n  // ========================================================================== //\n  //                            SphereX Engine Update                           //\n  // ========================================================================== //\n\n  /**\n   * @dev Update SphereX engine on registered contracts and add them as\n   *      allowed senders on the engine contract.\n   */\n  function updateSphereXEngineOnRegisteredContracts(\n    address[] calldata controllerFactories,\n    address[] calldata controllers,\n    address[] calldata markets\n  ) external spherexOnlyOperatorOrAdmin {\n    address engineAddress = sphereXEngine();\n    bytes memory changeSphereXEngineCalldata = abi.encodeWithSelector(\n      ISphereXProtectedRegisteredBase.changeSphereXEngine.selector,\n      engineAddress\n    );\n    bytes memory addAllowedSenderOnChainCalldata;\n    if (engineAddress != address(0)) {\n      addAllowedSenderOnChainCalldata = abi.encodeWithSelector(\n        ISphereXEngine.addAllowedSenderOnChain.selector,\n        address(0)\n      );\n    }\n    _updateSphereXEngineOnRegisteredContractsInSet(\n      _controllerFactories,\n      engineAddress,\n      controllerFactories,\n      changeSphereXEngineCalldata,\n      addAllowedSenderOnChainCalldata,\n      ControllerFactoryDoesNotExist.selector\n    );\n    _updateSphereXEngineOnRegisteredContractsInSet(\n      _controllers,\n      engineAddress,\n      controllers,\n      changeSphereXEngineCalldata,\n      addAllowedSenderOnChainCalldata,\n      ControllerDoesNotExist.selector\n    );\n    _updateSphereXEngineOnRegisteredContractsInSet(\n      _markets,\n      engineAddress,\n      markets,\n      changeSphereXEngineCalldata,\n      addAllowedSenderOnChainCalldata,\n      MarketDoesNotExist.selector\n    );\n  }\n\n  function _updateSphereXEngineOnRegisteredContractsInSet(\n    EnumerableSet.AddressSet storage set,\n    address engineAddress,\n    address[] memory contracts,\n    bytes memory changeSphereXEngineCalldata,\n    bytes memory addAllowedSenderOnChainCalldata,\n    bytes4 notInSetErrorSelectorBytes\n  ) internal {\n    for (uint256 i = 0; i < contracts.length; i++) {\n      address account = contracts[i];\n      if (!set.contains(account)) {\n        uint32 notInSetErrorSelector = uint32(notInSetErrorSelectorBytes);\n        assembly {\n          mstore(0, notInSetErrorSelector)\n          revert(0x1c, 0x04)\n        }\n      }\n      _callWith(account, changeSphereXEngineCalldata);\n      if (engineAddress != address(0)) {\n        assembly {\n          mstore(add(addAllowedSenderOnChainCalldata, 0x24), account)\n        }\n        _callWith(engineAddress, addAllowedSenderOnChainCalldata);\n        emit_NewAllowedSenderOnchain(account);\n      }\n    }\n  }\n\n  function _callWith(address target, bytes memory data) internal {\n    assembly {\n      if iszero(call(gas(), target, 0, add(data, 0x20), mload(data), 0, 0)) {\n        returndatacopy(0, 0, returndatasize())\n        revert(0, returndatasize())\n      }\n    }\n  }\n\n  /* ========================================================================== */\n  /*                                  Borrowers                                 */\n  /* ========================================================================== */\n\n  function registerBorrower(address borrower) external onlyOwner {\n    if (!_borrowers.add(borrower)) {\n      revert BorrowerAlreadyExists();\n    }\n    emit BorrowerAdded(borrower);\n  }\n\n  function removeBorrower(address borrower) external onlyOwner {\n    if (!_borrowers.remove(borrower)) {\n      revert BorrowerDoesNotExist();\n    }\n    emit BorrowerRemoved(borrower);\n  }\n\n  function isRegisteredBorrower(address borrower) external view returns (bool) {\n    return _borrowers.contains(borrower);\n  }\n\n  function getRegisteredBorrowers() external view returns (address[] memory) {\n    return _borrowers.values();\n  }\n\n  function getRegisteredBorrowers(\n    uint256 start,\n    uint256 end\n  ) external view returns (address[] memory arr) {\n    uint256 len = _borrowers.length();\n    end = MathUtils.min(end, len);\n    uint256 count = end - start;\n    arr = new address[](count);\n    for (uint256 i = 0; i < count; i++) {\n      arr[i] = _borrowers.at(start + i);\n    }\n  }\n\n  function getRegisteredBorrowersCount() external view returns (uint256) {\n    return _borrowers.length();\n  }\n\n  // ========================================================================== //\n  //                          Asset Blacklist Registry                          //\n  // ========================================================================== //\n\n  function addBlacklist(address asset) external onlyOwner {\n    if (!_assetBlacklist.add(asset)) {\n      revert AssetAlreadyBlacklisted();\n    }\n    emit AssetBlacklisted(asset);\n  }\n\n  function removeBlacklist(address asset) external onlyOwner {\n    if (!_assetBlacklist.remove(asset)) {\n      revert AssetNotBlacklisted();\n    }\n    emit AssetPermitted(asset);\n  }\n\n  function isBlacklistedAsset(address asset) external view returns (bool) {\n    return _assetBlacklist.contains(asset);\n  }\n\n  function getBlacklistedAssets() external view returns (address[] memory) {\n    return _assetBlacklist.values();\n  }\n\n  function getBlacklistedAssets(\n    uint256 start,\n    uint256 end\n  ) external view returns (address[] memory arr) {\n    uint256 len = _assetBlacklist.length();\n    end = MathUtils.min(end, len);\n    uint256 count = end - start;\n    arr = new address[](count);\n    for (uint256 i = 0; i < count; i++) {\n      arr[i] = _assetBlacklist.at(start + i);\n    }\n  }\n\n  function getBlacklistedAssetsCount() external view returns (uint256) {\n    return _assetBlacklist.length();\n  }\n\n  /* ========================================================================== */\n  /*                            Controller Factories                            */\n  /* ========================================================================== */\n\n  function registerControllerFactory(address factory) external onlyOwner {\n    if (!_controllerFactories.add(factory)) {\n      revert ControllerFactoryAlreadyExists();\n    }\n    _addAllowedSenderOnChain(factory);\n    emit ControllerFactoryAdded(factory);\n  }\n\n  function removeControllerFactory(address factory) external onlyOwner {\n    if (!_controllerFactories.remove(factory)) {\n      revert ControllerFactoryDoesNotExist();\n    }\n    emit ControllerFactoryRemoved(factory);\n  }\n\n  function isRegisteredControllerFactory(address factory) external view returns (bool) {\n    return _controllerFactories.contains(factory);\n  }\n\n  function getRegisteredControllerFactories() external view returns (address[] memory) {\n    return _controllerFactories.values();\n  }\n\n  function getRegisteredControllerFactories(\n    uint256 start,\n    uint256 end\n  ) external view returns (address[] memory arr) {\n    uint256 len = _controllerFactories.length();\n    end = MathUtils.min(end, len);\n    uint256 count = end - start;\n    arr = new address[](count);\n    for (uint256 i = 0; i < count; i++) {\n      arr[i] = _controllerFactories.at(start + i);\n    }\n  }\n\n  function getRegisteredControllerFactoriesCount() external view returns (uint256) {\n    return _controllerFactories.length();\n  }\n\n  /* ========================================================================== */\n  /*                                 Controllers                                */\n  /* ========================================================================== */\n\n  modifier onlyControllerFactory() {\n    if (!_controllerFactories.contains(msg.sender)) {\n      revert NotControllerFactory();\n    }\n    _;\n  }\n\n  function registerController(address controller) external onlyControllerFactory {\n    if (!_controllers.add(controller)) {\n      revert ControllerAlreadyExists();\n    }\n    _addAllowedSenderOnChain(controller);\n    emit ControllerAdded(msg.sender, controller);\n  }\n\n  function removeController(address controller) external onlyOwner {\n    if (!_controllers.remove(controller)) {\n      revert ControllerDoesNotExist();\n    }\n    emit ControllerRemoved(controller);\n  }\n\n  function isRegisteredController(address controller) external view returns (bool) {\n    return _controllers.contains(controller);\n  }\n\n  function getRegisteredControllers() external view returns (address[] memory) {\n    return _controllers.values();\n  }\n\n  function getRegisteredControllers(\n    uint256 start,\n    uint256 end\n  ) external view returns (address[] memory arr) {\n    uint256 len = _controllers.length();\n    end = MathUtils.min(end, len);\n    uint256 count = end - start;\n    arr = new address[](count);\n    for (uint256 i = 0; i < count; i++) {\n      arr[i] = _controllers.at(start + i);\n    }\n  }\n\n  function getRegisteredControllersCount() external view returns (uint256) {\n    return _controllers.length();\n  }\n\n  /* ========================================================================== */\n  /*                                   Markets                                   */\n  /* ========================================================================== */\n\n  modifier onlyController() {\n    if (!_controllers.contains(msg.sender)) {\n      revert NotController();\n    }\n    _;\n  }\n\n  function registerMarket(address market) external onlyController {\n    if (!_markets.add(market)) {\n      revert MarketAlreadyExists();\n    }\n    _addAllowedSenderOnChain(market);\n    emit MarketAdded(msg.sender, market);\n  }\n\n  function removeMarket(address market) external onlyOwner {\n    if (!_markets.remove(market)) {\n      revert MarketDoesNotExist();\n    }\n    emit MarketRemoved(market);\n  }\n\n  function isRegisteredMarket(address market) external view returns (bool) {\n    return _markets.contains(market);\n  }\n\n  function getRegisteredMarkets() external view returns (address[] memory) {\n    return _markets.values();\n  }\n\n  function getRegisteredMarkets(\n    uint256 start,\n    uint256 end\n  ) external view returns (address[] memory arr) {\n    uint256 len = _markets.length();\n    end = MathUtils.min(end, len);\n    uint256 count = end - start;\n    arr = new address[](count);\n    for (uint256 i = 0; i < count; i++) {\n      arr[i] = _markets.at(start + i);\n    }\n  }\n\n  function getRegisteredMarketsCount() external view returns (uint256) {\n    return _markets.length();\n  }\n}\n"},"src/market/WildcatMarket.sol":{"content":"// SPDX-License-Identifier: Apache-2.0 WITH LicenseRef-Commons-Clause-1.0\npragma solidity >=0.8.20;\n\nimport './WildcatMarketBase.sol';\nimport './WildcatMarketConfig.sol';\nimport './WildcatMarketToken.sol';\nimport './WildcatMarketWithdrawals.sol';\nimport '../WildcatSanctionsSentinel.sol';\n\ncontract WildcatMarket is\n  WildcatMarketBase,\n  WildcatMarketConfig,\n  WildcatMarketToken,\n  WildcatMarketWithdrawals\n{\n  using MathUtils for uint256;\n  using SafeCastLib for uint256;\n  using LibERC20 for address;\n  using BoolUtils for bool;\n\n  /**\n   * @dev Apply pending interest, delinquency fees and protocol fees\n   *      to the state and process the pending withdrawal batch if\n   *      one exists and has expired, then update the market's\n   *      delinquency status.\n   */\n  function updateState() external nonReentrant sphereXGuardExternal {\n    MarketState memory state = _getUpdatedState();\n    _writeState(state);\n  }\n\n  /**\n   * @dev Token rescue function for recovering tokens sent to the market\n   *      contract by mistake or otherwise outside of the normal course of\n   *      operation.\n   */\n  function rescueTokens(address token) external onlyBorrower {\n    if ((token == asset).or(token == address(this))) {\n      revert_BadRescueAsset();\n    }\n    token.safeTransferAll(msg.sender);\n  }\n\n  /**\n   * @dev Deposit up to `amount` underlying assets and mint market tokens\n   *      for `msg.sender`.\n   *\n   *      The actual deposit amount is limited by the market's maximum deposit\n   *      amount, which is the configured `maxTotalSupply` minus the current\n   *      total supply.\n   *\n   *      Reverts if the market is closed or if the scaled token amount\n   *      that would be minted for the deposit is zero.\n   */\n  function _depositUpTo(\n    uint256 amount\n  ) internal virtual nonReentrant returns (uint256 /* actualAmount */) {\n    // Get current state\n    MarketState memory state = _getUpdatedState();\n\n    if (state.isClosed) revert_DepositToClosedMarket();\n\n    // Reduce amount if it would exceed totalSupply\n    amount = MathUtils.min(amount, state.maximumDeposit());\n\n    // Scale the mint amount\n    uint104 scaledAmount = state.scaleAmount(amount).toUint104();\n    if (scaledAmount == 0) revert_NullMintAmount();\n\n    // Cache account data and revert if not authorized to deposit.\n    Account memory account = _getAccount(msg.sender);\n\n    hooks.onDeposit(msg.sender, scaledAmount, state);\n\n    // Transfer deposit from caller\n    asset.safeTransferFrom(msg.sender, address(this), amount);\n\n    account.scaledBalance += scaledAmount;\n    _accounts[msg.sender] = account;\n\n    emit_Transfer(_runtimeConstant(address(0)), msg.sender, amount);\n    emit_Deposit(msg.sender, amount, scaledAmount);\n\n    // Increase supply\n    state.scaledTotalSupply += scaledAmount;\n\n    // Update stored state\n    _writeState(state);\n\n    return amount;\n  }\n\n  /**\n   * @dev Deposit up to `amount` underlying assets and mint market tokens\n   *      for `msg.sender`.\n   *\n   *      The actual deposit amount is limited by the market's maximum deposit\n   *      amount, which is the configured `maxTotalSupply` minus the current\n   *      total supply.\n   *\n   *      Reverts if the market is closed or if the scaled token amount\n   *      that would be minted for the deposit is zero.\n   */\n  function depositUpTo(\n    uint256 amount\n  ) external virtual sphereXGuardExternal returns (uint256 /* actualAmount */) {\n    return _depositUpTo(amount);\n  }\n\n  /**\n   * @dev Deposit exactly `amount` underlying assets and mint market tokens\n   *      for `msg.sender`.\n   *\n   *     Reverts if the deposit amount would cause the market to exceed the\n   *     configured `maxTotalSupply`.\n   */\n  function deposit(uint256 amount) external virtual sphereXGuardExternal {\n    uint256 actualAmount = _depositUpTo(amount);\n    if (amount != actualAmount) revert_MaxSupplyExceeded();\n  }\n\n  /**\n   * @dev Withdraw available protocol fees to the fee recipient.\n   */\n  function collectFees() external nonReentrant sphereXGuardExternal {\n    MarketState memory state = _getUpdatedState();\n    if (state.accruedProtocolFees == 0) revert_NullFeeAmount();\n\n    uint128 withdrawableFees = state.withdrawableProtocolFees(totalAssets());\n    if (withdrawableFees == 0) revert_InsufficientReservesForFeeWithdrawal();\n\n    state.accruedProtocolFees -= withdrawableFees;\n    asset.safeTransfer(feeRecipient, withdrawableFees);\n    _writeState(state);\n    emit_FeesCollected(withdrawableFees);\n  }\n\n  /**\n   * @dev Withdraw funds from the market to the borrower.\n   *\n   *      Can only withdraw up to the assets that are not required\n   *      to meet the borrower's collateral obligations.\n   *\n   *      Reverts if the market is closed.\n   */\n  function borrow(uint256 amount) external onlyBorrower nonReentrant sphereXGuardExternal {\n    // Check if the borrower is flagged as a sanctioned entity on Chainalysis.\n    // Uses `isFlaggedByChainalysis` instead of `isSanctioned` to prevent the borrower\n    // overriding their sanction status.\n    if (_isFlaggedByChainalysis(borrower)) {\n      revert_BorrowWhileSanctioned();\n    }\n\n    MarketState memory state = _getUpdatedState();\n    if (state.isClosed) revert_BorrowFromClosedMarket();\n\n    uint256 borrowable = state.borrowableAssets(totalAssets());\n    if (amount > borrowable) revert_BorrowAmountTooHigh();\n\n    // Execute borrow hook if enabled\n    hooks.onBorrow(amount, state);\n\n    asset.safeTransfer(msg.sender, amount);\n    _writeState(state);\n    emit_Borrow(amount);\n  }\n\n  function _repay(MarketState memory state, uint256 amount, uint256 baseCalldataSize) internal {\n    if (amount == 0) revert_NullRepayAmount();\n    if (state.isClosed) revert_RepayToClosedMarket();\n\n    asset.safeTransferFrom(msg.sender, address(this), amount);\n    emit_DebtRepaid(msg.sender, amount);\n\n    // Execute repay hook if enabled\n    hooks.onRepay(amount, state, baseCalldataSize);\n  }\n\n  /**\n   * @dev Transfers funds from the caller to the market.\n   *\n   *      Any payments made through this function are considered\n   *      repayments from the borrower. Do *not* use this function\n   *      if you are a lender or an unrelated third party.\n   *\n   *      Reverts if the market is closed or `amount` is 0.\n   */\n  function repay(uint256 amount) external nonReentrant sphereXGuardExternal {\n    if (amount == 0) revert_NullRepayAmount();\n\n    asset.safeTransferFrom(msg.sender, address(this), amount);\n    emit_DebtRepaid(msg.sender, amount);\n\n    MarketState memory state = _getUpdatedState();\n    if (state.isClosed) revert_RepayToClosedMarket();\n\n    // Execute repay hook if enabled\n    hooks.onRepay(amount, state, _runtimeConstant(0x24));\n\n    _writeState(state);\n  }\n\n  function forceBuyBack(\n    address lender,\n    uint256 normalizedAmount\n  ) external nonReentrant onlyBorrower {\n    MarketState memory state = _getUpdatedState();\n    if (state.isDelinquent) revert_BuyBackOnDelinquentMarket();\n\n    uint104 scaledAmount = state.scaleAmount(normalizedAmount).toUint104();\n    if (scaledAmount == 0) revert_NullBuyBackAmount();\n\n    hooks.onForceBuyBack(lender, scaledAmount, state);\n\n    asset.safeTransferFrom(msg.sender, lender, normalizedAmount);\n\n    Account memory from = _accounts[lender];\n    from.scaledBalance -= scaledAmount;\n    _accounts[lender] = from;\n\n    Account memory to = _accounts[msg.sender];\n    to.scaledBalance += scaledAmount;\n    _accounts[msg.sender] = to;\n\n    emit_Transfer(lender, msg.sender, normalizedAmount);\n\n    uint32 expiry = _queueWithdrawal(\n      state,\n      to,\n      msg.sender,\n      scaledAmount,\n      normalizedAmount,\n      _runtimeConstant(0x44)\n    );\n    emit_ForceBuyBack(lender, scaledAmount, normalizedAmount, expiry);\n  }\n\n  /**\n   * @dev Sets the market APR to 0% and marks market as closed.\n   *\n   *      Can not be called if there are any unpaid withdrawal batches.\n   *\n   *      Transfers remaining debts from borrower if market is not fully\n   *      collateralized; otherwise, transfers any assets in excess of\n   *      debts to the borrower.\n   */\n  function closeMarket() external onlyBorrower nonReentrant sphereXGuardExternal {\n    MarketState memory state = _getUpdatedState();\n\n    if (state.isClosed) revert_MarketAlreadyClosed();\n\n    uint256 currentlyHeld = totalAssets();\n    uint256 totalDebts = state.totalDebts();\n    if (currentlyHeld < totalDebts) {\n      // Transfer remaining debts from borrower\n      uint256 remainingDebt = totalDebts - currentlyHeld;\n      _repay(state, remainingDebt, 0x04);\n      currentlyHeld += remainingDebt;\n    } else if (currentlyHeld > totalDebts) {\n      uint256 excessDebt = currentlyHeld - totalDebts;\n      // Transfer excess assets to borrower\n      asset.safeTransfer(borrower, excessDebt);\n      currentlyHeld -= excessDebt;\n    }\n    hooks.onCloseMarket(state);\n    state.annualInterestBips = 0;\n    state.isClosed = true;\n    state.reserveRatioBips = 10000;\n    // Ensures that delinquency fee doesn't increase scale factor further\n    // as doing so would mean last lender in market couldn't fully redeem\n    state.timeDelinquent = 0;\n\n    // Still track available liquidity in case of a rounding error\n    uint256 availableLiquidity = currentlyHeld -\n      (state.normalizedUnclaimedWithdrawals + state.accruedProtocolFees);\n\n    // If there is a pending withdrawal batch which is not fully paid off, set aside\n    // up to the available liquidity for that batch.\n    if (state.pendingWithdrawalExpiry != 0) {\n      uint32 expiry = state.pendingWithdrawalExpiry;\n      WithdrawalBatch memory batch = _withdrawalData.batches[expiry];\n      if (batch.scaledAmountBurned < batch.scaledTotalAmount) {\n        (, uint128 normalizedAmountPaid) = _applyWithdrawalBatchPayment(\n          batch,\n          state,\n          expiry,\n          availableLiquidity\n        );\n        availableLiquidity -= normalizedAmountPaid;\n        _withdrawalData.batches[expiry] = batch;\n      }\n\n      // Remove the pending batch to ensure new withdrawals are not\n      // added to it after the market is closed.\n      state.pendingWithdrawalExpiry = 0;\n      emit_WithdrawalBatchExpired(\n        expiry,\n        batch.scaledTotalAmount,\n        batch.scaledAmountBurned,\n        batch.normalizedAmountPaid\n      );\n      emit_WithdrawalBatchClosed(expiry);\n\n      // If the batch expiry is at the time of the market's closure, create\n      // a new empty batch that expires in one second to ensure new batches\n      // aren't created after the market is closed with the same expiry.\n      if (expiry == block.timestamp) {\n        uint32 newExpiry = expiry + 1;\n        emit_WithdrawalBatchCreated(newExpiry);\n        state.pendingWithdrawalExpiry = newExpiry;\n      }\n    }\n\n    uint256 numBatches = _withdrawalData.unpaidBatches.length();\n    for (uint256 i; i < numBatches; i++) {\n      // Process the next unpaid batch using available liquidity\n      uint256 normalizedAmountPaid = _processUnpaidWithdrawalBatch(state, availableLiquidity);\n      // Reduce liquidity available to next batch\n      availableLiquidity -= normalizedAmountPaid;\n    }\n\n    if (state.scaledPendingWithdrawals != 0) {\n      revert_CloseMarketWithUnpaidWithdrawals();\n    }\n\n    _writeState(state);\n    emit_MarketClosed(block.timestamp);\n  }\n\n  /**\n   * @dev Queues a full withdrawal of a sanctioned account's assets.\n   */\n  function _blockAccount(MarketState memory state, address accountAddress) internal override {\n    Account memory account = _accounts[accountAddress];\n    if (account.scaledBalance > 0) {\n      uint104 scaledAmount = account.scaledBalance;\n\n      uint256 normalizedAmount = state.normalizeAmount(scaledAmount);\n\n      uint32 expiry = _queueWithdrawal(\n        state,\n        account,\n        accountAddress,\n        scaledAmount,\n        normalizedAmount,\n        msg.data.length\n      );\n\n      emit_SanctionedAccountAssetsQueuedForWithdrawal(\n        accountAddress,\n        expiry,\n        scaledAmount,\n        normalizedAmount\n      );\n    }\n  }\n}\n"},"src/types/HooksConfig.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.20;\n\nimport '../access/IHooks.sol';\nimport '../libraries/MarketState.sol';\n\ntype HooksConfig is uint256;\n\nHooksConfig constant EmptyHooksConfig = HooksConfig.wrap(0);\n\nusing LibHooksConfig for HooksConfig global;\nusing LibHooksConfig for HooksDeploymentConfig global;\n\n// Type that contains only the flags for a specific hooks contract, with one\n// set of flags for optional hooks and one set of flags for required hooks.\ntype HooksDeploymentConfig is uint256;\n\nfunction encodeHooksDeploymentConfig(\n  HooksConfig optionalFlags,\n  HooksConfig requiredFlags\n) pure returns (HooksDeploymentConfig flags) {\n  assembly {\n    let cleanedOptionalFlags := and(0xffff, shr(0x50, optionalFlags))\n    let cleanedRequiredFlags := and(0xffff0000, shr(0x40, requiredFlags))\n    flags := or(cleanedOptionalFlags, cleanedRequiredFlags)\n  }\n}\n\n// --------------------- Bits after hook activation flag -------------------- //\n\n// Offsets are from the right\n\nuint256 constant Bit_Enabled_Deposit = 95;\nuint256 constant Bit_Enabled_QueueWithdrawal = 94;\nuint256 constant Bit_Enabled_ExecuteWithdrawal = 93;\nuint256 constant Bit_Enabled_Transfer = 92;\nuint256 constant Bit_Enabled_Borrow = 91;\nuint256 constant Bit_Enabled_Repay = 90;\nuint256 constant Bit_Enabled_CloseMarket = 89;\nuint256 constant Bit_Enabled_NukeFromOrbit = 88;\nuint256 constant Bit_Enabled_SetMaxTotalSupply = 87;\nuint256 constant Bit_Enabled_SetAnnualInterestAndReserveRatioBips = 86;\nuint256 constant Bit_Enabled_SetProtocolFeeBips = 85;\n\nuint256 constant MarketStateSize = 0x01c0;\n\nfunction encodeHooksConfig(\n  address hooksAddress,\n  bool useOnDeposit,\n  bool useOnQueueWithdrawal,\n  bool useOnExecuteWithdrawal,\n  bool useOnTransfer,\n  bool useOnBorrow,\n  bool useOnRepay,\n  bool useOnCloseMarket,\n  bool useOnNukeFromOrbit,\n  bool useOnSetMaxTotalSupply,\n  bool useOnSetAnnualInterestAndReserveRatioBips,\n  bool useOnSetProtocolFeeBips\n) pure returns (HooksConfig hooks) {\n  assembly {\n    hooks := shl(96, hooksAddress)\n    hooks := or(hooks, shl(Bit_Enabled_Deposit, useOnDeposit))\n    hooks := or(hooks, shl(Bit_Enabled_QueueWithdrawal, useOnQueueWithdrawal))\n    hooks := or(hooks, shl(Bit_Enabled_ExecuteWithdrawal, useOnExecuteWithdrawal))\n    hooks := or(hooks, shl(Bit_Enabled_Transfer, useOnTransfer))\n    hooks := or(hooks, shl(Bit_Enabled_Borrow, useOnBorrow))\n    hooks := or(hooks, shl(Bit_Enabled_Repay, useOnRepay))\n    hooks := or(hooks, shl(Bit_Enabled_CloseMarket, useOnCloseMarket))\n    hooks := or(hooks, shl(Bit_Enabled_NukeFromOrbit, useOnNukeFromOrbit))\n    hooks := or(hooks, shl(Bit_Enabled_SetMaxTotalSupply, useOnSetMaxTotalSupply))\n    hooks := or(\n      hooks,\n      shl(\n        Bit_Enabled_SetAnnualInterestAndReserveRatioBips,\n        useOnSetAnnualInterestAndReserveRatioBips\n      )\n    )\n    hooks := or(hooks, shl(Bit_Enabled_SetProtocolFeeBips, useOnSetProtocolFeeBips))\n  }\n}\n\nlibrary LibHooksConfig {\n  function setHooksAddress(\n    HooksConfig hooks,\n    address _hooksAddress\n  ) internal pure returns (HooksConfig updatedHooks) {\n    assembly {\n      // Shift twice to clear the address\n      updatedHooks := shr(160, shl(160, hooks))\n      // Set the new address\n      updatedHooks := or(updatedHooks, shl(96, _hooksAddress))\n    }\n  }\n\n  /**\n   * @dev Create a merged HooksConfig with the shared flags of `a` and `b`\n   *      and the address of `a`.\n   */\n  function mergeSharedFlags(\n    HooksConfig a,\n    HooksConfig b\n  ) internal pure returns (HooksConfig merged) {\n    assembly {\n      let addressA := shl(0x60, shr(0x60, a))\n      let flagsA := shl(0xa0, a)\n      let flagsB := shl(0xa0, b)\n      let mergedFlags := shr(0xa0, and(flagsA, flagsB))\n      merged := or(addressA, mergedFlags)\n    }\n  }\n\n  /**\n   * @dev Create a merged HooksConfig with the shared flags of `a` and `b`\n   *      and the address of `a`.\n   */\n  function mergeAllFlags(HooksConfig a, HooksConfig b) internal pure returns (HooksConfig merged) {\n    assembly {\n      let addressA := shl(0x60, shr(0x60, a))\n      let flagsA := shl(0xa0, a)\n      let flagsB := shl(0xa0, b)\n      let mergedFlags := shr(0xa0, or(flagsA, flagsB))\n      merged := or(addressA, mergedFlags)\n    }\n  }\n\n  function mergeFlags(\n    HooksConfig config,\n    HooksDeploymentConfig flags\n  ) internal pure returns (HooksConfig merged) {\n    assembly {\n      let _hooksAddress := shl(96, shr(96, config))\n      // Position flags at the end of the word\n      let configFlags := shr(0x50, config)\n      // Optional flags are already in the right position, required flags must be\n      // shifted to align with the other flags. The leading and trailing bits for all 3\n      // words will be masked out at the end\n      let _optionalFlags := flags\n      let _requiredFlags := shr(0x10, flags)\n      let mergedFlags := and(0xffff, or(and(configFlags, _optionalFlags), _requiredFlags))\n\n      merged := or(_hooksAddress, shl(0x50, mergedFlags))\n    }\n  }\n\n  function optionalFlags(HooksDeploymentConfig flags) internal pure returns (HooksConfig config) {\n    assembly {\n      config := shl(0x50, and(flags, 0xffff))\n    }\n  }\n\n  function requiredFlags(HooksDeploymentConfig flags) internal pure returns (HooksConfig config) {\n    assembly {\n      config := shl(0x40, and(flags, 0xffff0000))\n    }\n  }\n\n  // ========================================================================== //\n  //                              Parameter Readers                             //\n  // ========================================================================== //\n\n  function readFlag(HooksConfig hooks, uint256 bitsAfter) internal pure returns (bool flagged) {\n    assembly {\n      flagged := and(shr(bitsAfter, hooks), 1)\n    }\n  }\n\n  function setFlag(\n    HooksConfig hooks,\n    uint256 bitsAfter\n  ) internal pure returns (HooksConfig updatedHooks) {\n    assembly {\n      updatedHooks := or(hooks, shl(bitsAfter, 1))\n    }\n  }\n\n  function clearFlag(\n    HooksConfig hooks,\n    uint256 bitsAfter\n  ) internal pure returns (HooksConfig updatedHooks) {\n    assembly {\n      updatedHooks := and(hooks, not(shl(bitsAfter, 1)))\n    }\n  }\n\n  /// @dev Address of the hooks contract\n  function hooksAddress(HooksConfig hooks) internal pure returns (address _hooks) {\n    assembly {\n      _hooks := shr(96, hooks)\n    }\n  }\n\n  /// @dev Whether to call hook contract for deposit\n  function useOnDeposit(HooksConfig hooks) internal pure returns (bool) {\n    return hooks.readFlag(Bit_Enabled_Deposit);\n  }\n\n  /// @dev Whether to call hook contract for queueWithdrawal\n  function useOnQueueWithdrawal(HooksConfig hooks) internal pure returns (bool) {\n    return hooks.readFlag(Bit_Enabled_QueueWithdrawal);\n  }\n\n  /// @dev Whether to call hook contract for executeWithdrawal\n  function useOnExecuteWithdrawal(HooksConfig hooks) internal pure returns (bool) {\n    return hooks.readFlag(Bit_Enabled_ExecuteWithdrawal);\n  }\n\n  /// @dev Whether to call hook contract for transfer\n  function useOnTransfer(HooksConfig hooks) internal pure returns (bool) {\n    return hooks.readFlag(Bit_Enabled_Transfer);\n  }\n\n  /// @dev Whether to call hook contract for borrow\n  function useOnBorrow(HooksConfig hooks) internal pure returns (bool) {\n    return hooks.readFlag(Bit_Enabled_Borrow);\n  }\n\n  /// @dev Whether to call hook contract for repay\n  function useOnRepay(HooksConfig hooks) internal pure returns (bool) {\n    return hooks.readFlag(Bit_Enabled_Repay);\n  }\n\n  /// @dev Whether to call hook contract for closeMarket\n  function useOnCloseMarket(HooksConfig hooks) internal pure returns (bool) {\n    return hooks.readFlag(Bit_Enabled_CloseMarket);\n  }\n\n  /// @dev Whether to call hook contract when account sanctioned\n  function useOnNukeFromOrbit(HooksConfig hooks) internal pure returns (bool) {\n    return hooks.readFlag(Bit_Enabled_NukeFromOrbit);\n  }\n\n  /// @dev Whether to call hook contract for setMaxTotalSupply\n  function useOnSetMaxTotalSupply(HooksConfig hooks) internal pure returns (bool) {\n    return hooks.readFlag(Bit_Enabled_SetMaxTotalSupply);\n  }\n\n  /// @dev Whether to call hook contract for setAnnualInterestAndReserveRatioBips\n  function useOnSetAnnualInterestAndReserveRatioBips(\n    HooksConfig hooks\n  ) internal pure returns (bool) {\n    return hooks.readFlag(Bit_Enabled_SetAnnualInterestAndReserveRatioBips);\n  }\n\n  /// @dev Whether to call hook contract for setProtocolFeeBips\n  function useOnSetProtocolFeeBips(HooksConfig hooks) internal pure returns (bool) {\n    return hooks.readFlag(Bit_Enabled_SetProtocolFeeBips);\n  }\n\n  // ========================================================================== //\n  //                              Hook for deposit                              //\n  // ========================================================================== //\n\n  uint256 internal constant DepositCalldataSize = 0x24;\n  // Size of lender + scaledAmount + state + extraData.offset + extraData.length\n  uint256 internal constant DepositHook_Base_Size = 0x0244;\n  uint256 internal constant DepositHook_ScaledAmount_Offset = 0x20;\n  uint256 internal constant DepositHook_State_Offset = 0x40;\n  uint256 internal constant DepositHook_ExtraData_Head_Offset = 0x200;\n  uint256 internal constant DepositHook_ExtraData_Length_Offset = 0x0220;\n  uint256 internal constant DepositHook_ExtraData_TailOffset = 0x0240;\n\n  function onDeposit(\n    HooksConfig self,\n    address lender,\n    uint256 scaledAmount,\n    MarketState memory state\n  ) internal {\n    address target = self.hooksAddress();\n    uint32 onDepositSelector = uint32(IHooks.onDeposit.selector);\n    if (self.useOnDeposit()) {\n      assembly {\n        let extraCalldataBytes := sub(calldatasize(), DepositCalldataSize)\n        let cdPointer := mload(0x40)\n        let headPointer := add(cdPointer, 0x20)\n        // Write selector for `onDeposit`\n        mstore(cdPointer, onDepositSelector)\n        // Write `lender` to hook calldata\n        mstore(headPointer, lender)\n        // Write `scaledAmount` to hook calldata\n        mstore(add(headPointer, DepositHook_ScaledAmount_Offset), scaledAmount)\n        // Copy market state to hook calldata\n        mcopy(add(headPointer, DepositHook_State_Offset), state, MarketStateSize)\n        // Write bytes offset for `extraData`\n        mstore(\n          add(headPointer, DepositHook_ExtraData_Head_Offset),\n          DepositHook_ExtraData_Length_Offset\n        )\n        // Write length for `extraData`\n        mstore(add(headPointer, DepositHook_ExtraData_Length_Offset), extraCalldataBytes)\n        // Copy `extraData` from end of calldata to hook calldata\n        calldatacopy(\n          add(headPointer, DepositHook_ExtraData_TailOffset),\n          DepositCalldataSize,\n          extraCalldataBytes\n        )\n\n        let size := add(DepositHook_Base_Size, extraCalldataBytes)\n\n        if iszero(call(gas(), target, 0, add(cdPointer, 0x1c), size, 0, 0)) {\n          returndatacopy(0, 0, returndatasize())\n          revert(0, returndatasize())\n        }\n      }\n    }\n  }\n\n  // ========================================================================== //\n  //                          Hook for queueWithdrawal                          //\n  // ========================================================================== //\n\n  // Size of lender + scaledAmount + state + extraData.offset + extraData.length\n  uint256 internal constant QueueWithdrawalHook_Base_Size = 0x0264;\n  uint256 internal constant QueueWithdrawalHook_Expiry_Offset = 0x20;\n  uint256 internal constant QueueWithdrawalHook_ScaledAmount_Offset = 0x40;\n  uint256 internal constant QueueWithdrawalHook_State_Offset = 0x60;\n  uint256 internal constant QueueWithdrawalHook_ExtraData_Head_Offset = 0x220;\n  uint256 internal constant QueueWithdrawalHook_ExtraData_Length_Offset = 0x0240;\n  uint256 internal constant QueueWithdrawalHook_ExtraData_TailOffset = 0x0260;\n\n  function onQueueWithdrawal(\n    HooksConfig self,\n    address lender,\n    uint32 expiry,\n    uint256 scaledAmount,\n    MarketState memory state,\n    uint256 baseCalldataSize\n  ) internal {\n    address target = self.hooksAddress();\n    uint32 onQueueWithdrawalSelector = uint32(IHooks.onQueueWithdrawal.selector);\n    if (self.useOnQueueWithdrawal()) {\n      assembly {\n        let extraCalldataBytes := sub(calldatasize(), baseCalldataSize)\n        let cdPointer := mload(0x40)\n        let headPointer := add(cdPointer, 0x20)\n        // Write selector for `onQueueWithdrawal`\n        mstore(cdPointer, onQueueWithdrawalSelector)\n        // Write `lender` to hook calldata\n        mstore(headPointer, lender)\n        // Write `expiry` to hook calldata\n        mstore(add(headPointer, QueueWithdrawalHook_Expiry_Offset), expiry)\n        // Write `scaledAmount` to hook calldata\n        mstore(add(headPointer, QueueWithdrawalHook_ScaledAmount_Offset), scaledAmount)\n        // Copy market state to hook calldata\n        mcopy(add(headPointer, QueueWithdrawalHook_State_Offset), state, MarketStateSize)\n        // Write bytes offset for `extraData`\n        mstore(\n          add(headPointer, QueueWithdrawalHook_ExtraData_Head_Offset),\n          QueueWithdrawalHook_ExtraData_Length_Offset\n        )\n        // Write length for `extraData`\n        mstore(add(headPointer, QueueWithdrawalHook_ExtraData_Length_Offset), extraCalldataBytes)\n        // Copy `extraData` from end of calldata to hook calldata\n        calldatacopy(\n          add(headPointer, QueueWithdrawalHook_ExtraData_TailOffset),\n          baseCalldataSize,\n          extraCalldataBytes\n        )\n\n        let size := add(QueueWithdrawalHook_Base_Size, extraCalldataBytes)\n\n        if iszero(call(gas(), target, 0, add(cdPointer, 0x1c), size, 0, 0)) {\n          returndatacopy(0, 0, returndatasize())\n          revert(0, returndatasize())\n        }\n      }\n    }\n  }\n\n  // ========================================================================== //\n  //                         Hook for executeWithdrawal                         //\n  // ========================================================================== //\n\n  // Size of lender + scaledAmount + state + extraData.offset + extraData.length\n  uint256 internal constant ExecuteWithdrawalHook_Base_Size = 0x0244;\n  uint256 internal constant ExecuteWithdrawalHook_ScaledAmount_Offset = 0x20;\n  uint256 internal constant ExecuteWithdrawalHook_State_Offset = 0x40;\n  uint256 internal constant ExecuteWithdrawalHook_ExtraData_Head_Offset = 0x0200;\n  uint256 internal constant ExecuteWithdrawalHook_ExtraData_Length_Offset = 0x0220;\n  uint256 internal constant ExecuteWithdrawalHook_ExtraData_TailOffset = 0x0240;\n\n  function onExecuteWithdrawal(\n    HooksConfig self,\n    address lender,\n    uint256 scaledAmount,\n    MarketState memory state,\n    uint256 baseCalldataSize\n  ) internal {\n    address target = self.hooksAddress();\n    uint32 onExecuteWithdrawalSelector = uint32(IHooks.onExecuteWithdrawal.selector);\n    if (self.useOnExecuteWithdrawal()) {\n      assembly {\n        let extraCalldataBytes := sub(calldatasize(), baseCalldataSize)\n        let cdPointer := mload(0x40)\n        let headPointer := add(cdPointer, 0x20)\n        // Write selector for `onExecuteWithdrawal`\n        mstore(cdPointer, onExecuteWithdrawalSelector)\n        // Write `lender` to hook calldata\n        mstore(headPointer, lender)\n        // Write `scaledAmount` to hook calldata\n        mstore(add(headPointer, ExecuteWithdrawalHook_ScaledAmount_Offset), scaledAmount)\n        // Copy market state to hook calldata\n        mcopy(add(headPointer, ExecuteWithdrawalHook_State_Offset), state, MarketStateSize)\n        // Write bytes offset for `extraData`\n        mstore(\n          add(headPointer, ExecuteWithdrawalHook_ExtraData_Head_Offset),\n          ExecuteWithdrawalHook_ExtraData_Length_Offset\n        )\n        // Write length for `extraData`\n        mstore(add(headPointer, ExecuteWithdrawalHook_ExtraData_Length_Offset), extraCalldataBytes)\n        // Copy `extraData` from end of calldata to hook calldata\n        calldatacopy(\n          add(headPointer, ExecuteWithdrawalHook_ExtraData_TailOffset),\n          baseCalldataSize,\n          extraCalldataBytes\n        )\n\n        let size := add(ExecuteWithdrawalHook_Base_Size, extraCalldataBytes)\n\n        if iszero(call(gas(), target, 0, add(cdPointer, 0x1c), size, 0, 0)) {\n          returndatacopy(0, 0, returndatasize())\n          revert(0, returndatasize())\n        }\n      }\n    }\n  }\n\n  // ========================================================================== //\n  //                              Hook for transfer                             //\n  // ========================================================================== //\n\n  // Size of caller + from + to + scaledAmount + state + extraData.offset + extraData.length\n  uint256 internal constant TransferHook_Base_Size = 0x0284;\n  uint256 internal constant TransferHook_From_Offset = 0x20;\n  uint256 internal constant TransferHook_To_Offset = 0x40;\n  uint256 internal constant TransferHook_ScaledAmount_Offset = 0x60;\n  uint256 internal constant TransferHook_State_Offset = 0x80;\n  uint256 internal constant TransferHook_ExtraData_Head_Offset = 0x240;\n  uint256 internal constant TransferHook_ExtraData_Length_Offset = 0x0260;\n  uint256 internal constant TransferHook_ExtraData_TailOffset = 0x0280;\n\n  function onTransfer(\n    HooksConfig self,\n    address from,\n    address to,\n    uint256 scaledAmount,\n    MarketState memory state,\n    uint256 baseCalldataSize\n  ) internal {\n    address target = self.hooksAddress();\n    uint32 onTransferSelector = uint32(IHooks.onTransfer.selector);\n    if (self.useOnTransfer()) {\n      assembly {\n        let extraCalldataBytes := sub(calldatasize(), baseCalldataSize)\n        let cdPointer := mload(0x40)\n        let headPointer := add(cdPointer, 0x20)\n        // Write selector for `onTransfer`\n        mstore(cdPointer, onTransferSelector)\n        // Write `caller` to hook calldata\n        mstore(headPointer, caller())\n        // Write `from` to hook calldata\n        mstore(add(headPointer, TransferHook_From_Offset), from)\n        // Write `to` to hook calldata\n        mstore(add(headPointer, TransferHook_To_Offset), to)\n        // Write `scaledAmount` to hook calldata\n        mstore(add(headPointer, TransferHook_ScaledAmount_Offset), scaledAmount)\n        // Copy market state to hook calldata\n        mcopy(add(headPointer, TransferHook_State_Offset), state, MarketStateSize)\n        // Write bytes offset for `extraData`\n        mstore(\n          add(headPointer, TransferHook_ExtraData_Head_Offset),\n          TransferHook_ExtraData_Length_Offset\n        )\n        // Write length for `extraData`\n        mstore(add(headPointer, TransferHook_ExtraData_Length_Offset), extraCalldataBytes)\n        // Copy `extraData` from end of calldata to hook calldata\n        calldatacopy(\n          add(headPointer, TransferHook_ExtraData_TailOffset),\n          baseCalldataSize,\n          extraCalldataBytes\n        )\n\n        let size := add(TransferHook_Base_Size, extraCalldataBytes)\n\n        if iszero(call(gas(), target, 0, add(cdPointer, 0x1c), size, 0, 0)) {\n          returndatacopy(0, 0, returndatasize())\n          revert(0, returndatasize())\n        }\n      }\n    }\n  }\n\n  // ========================================================================== //\n  //                               Hook for borrow                              //\n  // ========================================================================== //\n\n  uint256 internal constant BorrowCalldataSize = 0x24;\n  // Size of normalizedAmount + state + extraData.offset + extraData.length\n  uint256 internal constant BorrowHook_Base_Size = 0x0224;\n  uint256 internal constant BorrowHook_State_Offset = 0x20;\n  uint256 internal constant BorrowHook_ExtraData_Head_Offset = 0x01e0;\n  uint256 internal constant BorrowHook_ExtraData_Length_Offset = 0x0200;\n  uint256 internal constant BorrowHook_ExtraData_TailOffset = 0x0220;\n\n  function onBorrow(HooksConfig self, uint256 normalizedAmount, MarketState memory state) internal {\n    address target = self.hooksAddress();\n    uint32 onBorrowSelector = uint32(IHooks.onBorrow.selector);\n    if (self.useOnBorrow()) {\n      assembly {\n        let extraCalldataBytes := sub(calldatasize(), BorrowCalldataSize)\n        let ptr := mload(0x40)\n        let headPointer := add(ptr, 0x20)\n\n        mstore(ptr, onBorrowSelector)\n        // Copy `normalizedAmount` to hook calldata\n        mstore(headPointer, normalizedAmount)\n        // Copy market state to hook calldata\n        mcopy(add(headPointer, BorrowHook_State_Offset), state, MarketStateSize)\n        // Write bytes offset for `extraData`\n        mstore(\n          add(headPointer, BorrowHook_ExtraData_Head_Offset),\n          BorrowHook_ExtraData_Length_Offset\n        )\n        // Write length for `extraData`\n        mstore(add(headPointer, BorrowHook_ExtraData_Length_Offset), extraCalldataBytes)\n        // Copy `extraData` from end of calldata to hook calldata\n        calldatacopy(\n          add(headPointer, BorrowHook_ExtraData_TailOffset),\n          BorrowCalldataSize,\n          extraCalldataBytes\n        )\n\n        let size := add(RepayHook_Base_Size, extraCalldataBytes)\n        if iszero(call(gas(), target, 0, add(ptr, 0x1c), size, 0, 0)) {\n          returndatacopy(0, 0, returndatasize())\n          revert(0, returndatasize())\n        }\n      }\n    }\n  }\n\n  // ========================================================================== //\n  //                               Hook for repay                               //\n  // ========================================================================== //\n\n  // Size of normalizedAmount + state + extraData.offset + extraData.length\n  uint256 internal constant RepayHook_Base_Size = 0x0224;\n  uint256 internal constant RepayHook_State_Offset = 0x20;\n  uint256 internal constant RepayHook_ExtraData_Head_Offset = 0x01e0;\n  uint256 internal constant RepayHook_ExtraData_Length_Offset = 0x0200;\n  uint256 internal constant RepayHook_ExtraData_TailOffset = 0x0220;\n\n  function onRepay(\n    HooksConfig self,\n    uint256 normalizedAmount,\n    MarketState memory state,\n    uint256 baseCalldataSize\n  ) internal {\n    address target = self.hooksAddress();\n    uint32 onRepaySelector = uint32(IHooks.onRepay.selector);\n    if (self.useOnRepay()) {\n      assembly {\n        let extraCalldataBytes := sub(calldatasize(), baseCalldataSize)\n        let ptr := mload(0x40)\n        let headPointer := add(ptr, 0x20)\n\n        mstore(ptr, onRepaySelector)\n        // Copy `normalizedAmount` to hook calldata\n        mstore(headPointer, normalizedAmount)\n        // Copy market state to hook calldata\n        mcopy(add(headPointer, RepayHook_State_Offset), state, MarketStateSize)\n        // Write bytes offset for `extraData`\n        mstore(add(headPointer, RepayHook_ExtraData_Head_Offset), RepayHook_ExtraData_Length_Offset)\n        // Write length for `extraData`\n        mstore(add(headPointer, RepayHook_ExtraData_Length_Offset), extraCalldataBytes)\n        // Copy `extraData` from end of calldata to hook calldata\n        calldatacopy(\n          add(headPointer, RepayHook_ExtraData_TailOffset),\n          baseCalldataSize,\n          extraCalldataBytes\n        )\n\n        let size := add(RepayHook_Base_Size, extraCalldataBytes)\n        if iszero(call(gas(), target, 0, add(ptr, 0x1c), size, 0, 0)) {\n          returndatacopy(0, 0, returndatasize())\n          revert(0, returndatasize())\n        }\n      }\n    }\n  }\n\n  // ========================================================================== //\n  //                            Hook for closeMarket                            //\n  // ========================================================================== //\n\n  // Size of calldata to `market.closeMarket`\n  uint256 internal constant CloseMarketCalldataSize = 0x04;\n\n  // Base size of calldata for `hooks.onCloseMarket()`\n  uint256 internal constant CloseMarketHook_Base_Size = 0x0204;\n  uint256 internal constant CloseMarketHook_ExtraData_Head_Offset = MarketStateSize;\n  uint256 internal constant CloseMarketHook_ExtraData_Length_Offset = 0x01e0;\n  uint256 internal constant CloseMarketHook_ExtraData_TailOffset = 0x0200;\n\n  function onCloseMarket(HooksConfig self, MarketState memory state) internal {\n    address target = self.hooksAddress();\n    uint32 onCloseMarketSelector = uint32(IHooks.onCloseMarket.selector);\n    if (self.useOnCloseMarket()) {\n      assembly {\n        let extraCalldataBytes := sub(calldatasize(), CloseMarketCalldataSize)\n        let cdPointer := mload(0x40)\n        let headPointer := add(cdPointer, 0x20)\n        // Write selector for `onCloseMarket`\n        mstore(cdPointer, onCloseMarketSelector)\n        // Copy market state to hook calldata\n        mcopy(headPointer, state, MarketStateSize)\n        // Write bytes offset for `extraData`\n        mstore(\n          add(headPointer, CloseMarketHook_ExtraData_Head_Offset),\n          CloseMarketHook_ExtraData_Length_Offset\n        )\n        // Write length for `extraData`\n        mstore(add(headPointer, CloseMarketHook_ExtraData_Length_Offset), extraCalldataBytes)\n        // Copy `extraData` from end of calldata to hook calldata\n        calldatacopy(\n          add(headPointer, CloseMarketHook_ExtraData_TailOffset),\n          CloseMarketCalldataSize,\n          extraCalldataBytes\n        )\n\n        let size := add(CloseMarketHook_Base_Size, extraCalldataBytes)\n\n        if iszero(call(gas(), target, 0, add(cdPointer, 0x1c), size, 0, 0)) {\n          returndatacopy(0, 0, returndatasize())\n          revert(0, returndatasize())\n        }\n      }\n    }\n  }\n\n  // ========================================================================== //\n  //                         Hook for setMaxTotalSupply                         //\n  // ========================================================================== //\n\n  uint256 internal constant SetMaxTotalSupplyCalldataSize = 0x24;\n  // Size of maxTotalSupply + state + extraData.offset + extraData.length\n  uint256 internal constant SetMaxTotalSupplyHook_Base_Size = 0x0224;\n  uint256 internal constant SetMaxTotalSupplyHook_State_Offset = 0x20;\n  uint256 internal constant SetMaxTotalSupplyHook_ExtraData_Head_Offset = 0x01e0;\n  uint256 internal constant SetMaxTotalSupplyHook_ExtraData_Length_Offset = 0x0200;\n  uint256 internal constant SetMaxTotalSupplyHook_ExtraData_TailOffset = 0x0220;\n\n  function onSetMaxTotalSupply(\n    HooksConfig self,\n    uint256 maxTotalSupply,\n    MarketState memory state\n  ) internal {\n    address target = self.hooksAddress();\n    uint32 onSetMaxTotalSupplySelector = uint32(IHooks.onSetMaxTotalSupply.selector);\n    if (self.useOnSetMaxTotalSupply()) {\n      assembly {\n        let extraCalldataBytes := sub(calldatasize(), SetMaxTotalSupplyCalldataSize)\n        let cdPointer := mload(0x40)\n        let headPointer := add(cdPointer, 0x20)\n        // Write selector for `onSetMaxTotalSupply`\n        mstore(cdPointer, onSetMaxTotalSupplySelector)\n        // Write `maxTotalSupply` to hook calldata\n        mstore(headPointer, maxTotalSupply)\n        // Copy market state to hook calldata\n        mcopy(add(headPointer, SetMaxTotalSupplyHook_State_Offset), state, MarketStateSize)\n        // Write bytes offset for `extraData`\n        mstore(\n          add(headPointer, SetMaxTotalSupplyHook_ExtraData_Head_Offset),\n          SetMaxTotalSupplyHook_ExtraData_Length_Offset\n        )\n        // Write length for `extraData`\n        mstore(add(headPointer, SetMaxTotalSupplyHook_ExtraData_Length_Offset), extraCalldataBytes)\n        // Copy `extraData` from end of calldata to hook calldata\n        calldatacopy(\n          add(headPointer, SetMaxTotalSupplyHook_ExtraData_TailOffset),\n          SetMaxTotalSupplyCalldataSize,\n          extraCalldataBytes\n        )\n\n        let size := add(SetMaxTotalSupplyHook_Base_Size, extraCalldataBytes)\n\n        if iszero(call(gas(), target, 0, add(cdPointer, 0x1c), size, 0, 0)) {\n          returndatacopy(0, 0, returndatasize())\n          revert(0, returndatasize())\n        }\n      }\n    }\n  }\n\n  // ========================================================================== //\n  //                       Hook for setAnnualInterestBips                       //\n  // ========================================================================== //\n\n  uint256 internal constant SetAnnualInterestAndReserveRatioBipsCalldataSize = 0x44;\n  // Size of annualInterestBips + state + extraData.offset + extraData.length\n  uint256 internal constant SetAnnualInterestAndReserveRatioBipsHook_Base_Size = 0x0244;\n  uint256 internal constant SetAnnualInterestAndReserveRatioBipsHook_ReserveRatioBits_Offset = 0x20;\n  uint256 internal constant SetAnnualInterestAndReserveRatioBipsHook_State_Offset = 0x40;\n  uint256 internal constant SetAnnualInterestAndReserveRatioBipsHook_ExtraData_Head_Offset = 0x0200;\n  uint256 internal constant SetAnnualInterestAndReserveRatioBipsHook_ExtraData_Length_Offset =\n    0x0220;\n  uint256 internal constant SetAnnualInterestAndReserveRatioBipsHook_ExtraData_TailOffset = 0x0240;\n\n  function onSetAnnualInterestAndReserveRatioBips(\n    HooksConfig self,\n    uint16 annualInterestBips,\n    uint16 reserveRatioBips,\n    MarketState memory state\n  ) internal returns (uint16 newAnnualInterestBips, uint16 newReserveRatioBips) {\n    address target = self.hooksAddress();\n    uint32 onSetAnnualInterestBipsSelector = uint32(\n      IHooks.onSetAnnualInterestAndReserveRatioBips.selector\n    );\n    if (self.useOnSetAnnualInterestAndReserveRatioBips()) {\n      assembly {\n        let extraCalldataBytes := sub(\n          calldatasize(),\n          SetAnnualInterestAndReserveRatioBipsCalldataSize\n        )\n        let cdPointer := mload(0x40)\n        let headPointer := add(cdPointer, 0x20)\n        // Write selector for `onSetAnnualInterestBips`\n        mstore(cdPointer, onSetAnnualInterestBipsSelector)\n        // Write `annualInterestBips` to hook calldata\n        mstore(headPointer, annualInterestBips)\n        // Write `reserveRatioBips` to hook calldata\n        mstore(\n          add(headPointer, SetAnnualInterestAndReserveRatioBipsHook_ReserveRatioBits_Offset),\n          reserveRatioBips\n        )\n        // Copy market state to hook calldata\n        mcopy(\n          add(headPointer, SetAnnualInterestAndReserveRatioBipsHook_State_Offset),\n          state,\n          MarketStateSize\n        )\n        // Write bytes offset for `extraData`\n        mstore(\n          add(headPointer, SetAnnualInterestAndReserveRatioBipsHook_ExtraData_Head_Offset),\n          SetAnnualInterestAndReserveRatioBipsHook_ExtraData_Length_Offset\n        )\n        // Write length for `extraData`\n        mstore(\n          add(headPointer, SetAnnualInterestAndReserveRatioBipsHook_ExtraData_Length_Offset),\n          extraCalldataBytes\n        )\n        // Copy `extraData` from end of calldata to hook calldata\n        calldatacopy(\n          add(headPointer, SetAnnualInterestAndReserveRatioBipsHook_ExtraData_TailOffset),\n          SetAnnualInterestAndReserveRatioBipsCalldataSize,\n          extraCalldataBytes\n        )\n\n        let size := add(SetAnnualInterestAndReserveRatioBipsHook_Base_Size, extraCalldataBytes)\n\n        // Returndata is expected to have the new values for `annualInterestBips` and `reserveRatioBips`\n        if or(\n          lt(returndatasize(), 0x40),\n          iszero(call(gas(), target, 0, add(cdPointer, 0x1c), size, 0, 0x40))\n        ) {\n          returndatacopy(0, 0, returndatasize())\n          revert(0, returndatasize())\n        }\n\n        newAnnualInterestBips := and(mload(0), 0xffff)\n        newReserveRatioBips := and(mload(0x20), 0xffff)\n      }\n    } else {\n      (newAnnualInterestBips, newReserveRatioBips) = (annualInterestBips, reserveRatioBips);\n    }\n  }\n\n  // ========================================================================== //\n  //                     Hook for protocol fee bips updated                     //\n  // ========================================================================== //\n\n  uint256 internal constant SetProtocolFeeBipsCalldataSize = 0x24;\n  // Size of protocolFeeBips + state + extraData.offset + extraData.length\n  uint256 internal constant SetProtocolFeeBips_Base_Size = 0x0224;\n  uint256 internal constant SetProtocolFeeBips_State_Offset = 0x20;\n  uint256 internal constant SetProtocolFeeBips_ExtraData_Head_Offset = 0x01e0;\n  uint256 internal constant SetProtocolFeeBips_ExtraData_Length_Offset = 0x0200;\n  uint256 internal constant SetProtocolFeeBips_ExtraData_TailOffset = 0x0220;\n\n  function onSetProtocolFeeBips(\n    HooksConfig self,\n    uint protocolFeeBips,\n    MarketState memory state\n  ) internal {\n    address target = self.hooksAddress();\n    uint32 onSetProtocolFeeBipsSelector = uint32(IHooks.onSetProtocolFeeBips.selector);\n    if (self.useOnSetProtocolFeeBips()) {\n      assembly {\n        let extraCalldataBytes := sub(calldatasize(), SetProtocolFeeBipsCalldataSize)\n        let cdPointer := mload(0x40)\n        let headPointer := add(cdPointer, 0x20)\n        // Write selector for `onSetProtocolFeeBips`\n        mstore(cdPointer, onSetProtocolFeeBipsSelector)\n        // Write `protocolFeeBips` to hook calldata\n        mstore(headPointer, protocolFeeBips)\n        // Copy market state to hook calldata\n        mcopy(add(headPointer, SetProtocolFeeBips_State_Offset), state, MarketStateSize)\n        // Write bytes offset for `extraData`\n        mstore(\n          add(headPointer, SetProtocolFeeBips_ExtraData_Head_Offset),\n          SetProtocolFeeBips_ExtraData_Length_Offset\n        )\n        // Write length for `extraData`\n        mstore(add(headPointer, SetProtocolFeeBips_ExtraData_Length_Offset), extraCalldataBytes)\n        // Copy `extraData` from end of calldata to hook calldata\n        calldatacopy(\n          add(headPointer, SetProtocolFeeBips_ExtraData_TailOffset),\n          SetProtocolFeeBipsCalldataSize,\n          extraCalldataBytes\n        )\n\n        let size := add(SetProtocolFeeBips_Base_Size, extraCalldataBytes)\n\n        if iszero(call(gas(), target, 0, add(cdPointer, 0x1c), size, 0, 0)) {\n          returndatacopy(0, 0, returndatasize())\n          revert(0, returndatasize())\n        }\n      }\n    }\n  }\n\n  // ========================================================================== //\n  //                       Hook for assets sent to escrow                       //\n  // ========================================================================== //\n\n  uint256 internal constant NukeFromOrbitCalldataSize = 0x24;\n  // Size of lender + state + extraData.offset + extraData.length\n  uint256 internal constant NukeFromOrbit_Base_Size = 0x0224;\n  uint256 internal constant NukeFromOrbit_State_Offset = 0x20;\n  uint256 internal constant NukeFromOrbit_ExtraData_Head_Offset = 0x01e0;\n  uint256 internal constant NukeFromOrbit_ExtraData_Length_Offset = 0x0200;\n  uint256 internal constant NukeFromOrbit_ExtraData_TailOffset = 0x0220;\n\n  function onNukeFromOrbit(HooksConfig self, address lender, MarketState memory state) internal {\n    address target = self.hooksAddress();\n    uint32 onNukeFromOrbitSelector = uint32(IHooks.onNukeFromOrbit.selector);\n    if (self.useOnNukeFromOrbit()) {\n      assembly {\n        let extraCalldataBytes := sub(calldatasize(), NukeFromOrbitCalldataSize)\n        let cdPointer := mload(0x40)\n        let headPointer := add(cdPointer, 0x20)\n        // Write selector for `onNukeFromOrbit`\n        mstore(cdPointer, onNukeFromOrbitSelector)\n        // Write `lender` to hook calldata\n        mstore(headPointer, lender)\n        // Copy market state to hook calldata\n        mcopy(add(headPointer, NukeFromOrbit_State_Offset), state, MarketStateSize)\n        // Write bytes offset for `extraData`\n        mstore(\n          add(headPointer, NukeFromOrbit_ExtraData_Head_Offset),\n          NukeFromOrbit_ExtraData_Length_Offset\n        )\n        // Write length for `extraData`\n        mstore(add(headPointer, NukeFromOrbit_ExtraData_Length_Offset), extraCalldataBytes)\n        // Copy `extraData` from end of calldata to hook calldata\n        calldatacopy(\n          add(headPointer, NukeFromOrbit_ExtraData_TailOffset),\n          NukeFromOrbitCalldataSize,\n          extraCalldataBytes\n        )\n\n        let size := add(NukeFromOrbit_Base_Size, extraCalldataBytes)\n\n        if iszero(call(gas(), target, 0, add(cdPointer, 0x1c), size, 0, 0)) {\n          returndatacopy(0, 0, returndatasize())\n          revert(0, returndatasize())\n        }\n      }\n    }\n  }\n\n  // ========================================================================== //\n  //                           Hook for forced buyback                          //\n  // ========================================================================== //\n\n  uint256 internal constant ForceBuyBackCalldataSize = 0x44;\n  // Size of lender + scaledAmount + state + extraData.offset + extraData.length\n  uint256 internal constant ForceBuyBackHook_Base_Size = 0x0244;\n  uint256 internal constant ForceBuyBackHook_ScaledAmount_Offset = 0x20;\n  uint256 internal constant ForceBuyBackHook_State_Offset = 0x40;\n  uint256 internal constant ForceBuyBackHook_ExtraData_Head_Offset = 0x0200;\n  uint256 internal constant ForceBuyBackHook_ExtraData_Length_Offset = 0x0220;\n  uint256 internal constant ForceBuyBackHook_ExtraData_TailOffset = 0x0240;\n\n  function onForceBuyBack(\n    HooksConfig self,\n    address lender,\n    uint256 scaledAmount,\n    MarketState memory state\n  ) internal {\n    address target = self.hooksAddress();\n    uint32 onForceBuyBackSelector = uint32(IHooks.onForceBuyBack.selector);\n    assembly {\n      let extraCalldataBytes := sub(calldatasize(), ForceBuyBackCalldataSize)\n      let cdPointer := mload(0x40)\n      let headPointer := add(cdPointer, 0x20)\n      // Write selector for `onForceBuyBack`\n      mstore(cdPointer, onForceBuyBackSelector)\n      // Write `lender` to hook calldata\n      mstore(headPointer, lender)\n      // Write `scaledAmount` to hook calldata\n      mstore(add(headPointer, ForceBuyBackHook_ScaledAmount_Offset), scaledAmount)\n      // Copy market state to hook calldata\n      mcopy(add(headPointer, ForceBuyBackHook_State_Offset), state, MarketStateSize)\n      // Write bytes offset for `extraData`\n      mstore(\n        add(headPointer, ForceBuyBackHook_ExtraData_Head_Offset),\n        ForceBuyBackHook_ExtraData_Length_Offset\n      )\n      // Write length for `extraData`\n      mstore(add(headPointer, ForceBuyBackHook_ExtraData_Length_Offset), extraCalldataBytes)\n      // Copy `extraData` from end of calldata to hook calldata\n      calldatacopy(\n        add(headPointer, ForceBuyBackHook_ExtraData_TailOffset),\n        ForceBuyBackCalldataSize,\n        extraCalldataBytes\n      )\n\n      let size := add(ForceBuyBackHook_Base_Size, extraCalldataBytes)\n\n      if iszero(call(gas(), target, 0, add(cdPointer, 0x1c), size, 0, 0)) {\n        returndatacopy(0, 0, returndatasize())\n        revert(0, returndatasize())\n      }\n    }\n  }\n}\n"},"src/access/MarketConstraintHooks.sol":{"content":"// SPDX-License-Identifier: Apache-2.0 WITH LicenseRef-Commons-Clause-1.0\npragma solidity >=0.8.20;\n\nimport './IHooks.sol';\nimport '../libraries/BoolUtils.sol';\n\nstruct TemporaryReserveRatio {\n  uint16 originalAnnualInterestBips;\n  uint16 originalReserveRatioBips;\n  uint32 expiry;\n}\n\nabstract contract MarketConstraintHooks is IHooks {\n  using BoolUtils for bool;\n\n  error DelinquencyGracePeriodOutOfBounds();\n  error ReserveRatioBipsOutOfBounds();\n  error DelinquencyFeeBipsOutOfBounds();\n  error WithdrawalBatchDurationOutOfBounds();\n  error AnnualInterestBipsOutOfBounds();\n\n  event TemporaryExcessReserveRatioActivated(\n    address indexed market,\n    uint256 originalReserveRatioBips,\n    uint256 temporaryReserveRatioBips,\n    uint256 temporaryReserveRatioExpiry\n  );\n\n  event TemporaryExcessReserveRatioUpdated(\n    address indexed market,\n    uint256 originalReserveRatioBips,\n    uint256 temporaryReserveRatioBips,\n    uint256 temporaryReserveRatioExpiry\n  );\n\n  event TemporaryExcessReserveRatioCanceled(address indexed market);\n\n  event TemporaryExcessReserveRatioExpired(address indexed market);\n\n  uint32 internal constant MinimumDelinquencyGracePeriod = 0;\n  uint32 internal constant MaximumDelinquencyGracePeriod = 90 days;\n\n  uint16 internal constant MinimumReserveRatioBips = 0;\n  uint16 internal constant MaximumReserveRatioBips = 10_000;\n\n  uint16 internal constant MinimumDelinquencyFeeBips = 0;\n  uint16 internal constant MaximumDelinquencyFeeBips = 10_000;\n\n  uint32 internal constant MinimumWithdrawalBatchDuration = 0;\n  uint32 internal constant MaximumWithdrawalBatchDuration = 365 days;\n\n  uint16 internal constant MinimumAnnualInterestBips = 0;\n  uint16 internal constant MaximumAnnualInterestBips = 10_000;\n\n  mapping(address => TemporaryReserveRatio) public temporaryExcessReserveRatio;\n\n  function assertValueInRange(\n    uint256 value,\n    uint256 min,\n    uint256 max,\n    bytes4 errorSelector\n  ) internal pure {\n    assembly {\n      if or(lt(value, min), gt(value, max)) {\n        mstore(0, errorSelector)\n        revert(0, 4)\n      }\n    }\n  }\n\n  /**\n   * @dev Enforce constraints on market parameters, ensuring that\n   *      `annualInterestBips`, `delinquencyFeeBips`, `withdrawalBatchDuration`,\n   *      `reserveRatioBips` and `delinquencyGracePeriod` are within the\n   *      allowed ranges and that `namePrefix` and `symbolPrefix` are not null.\n   */\n  function enforceParameterConstraints(\n    uint16 annualInterestBips,\n    uint16 delinquencyFeeBips,\n    uint32 withdrawalBatchDuration,\n    uint16 reserveRatioBips,\n    uint32 delinquencyGracePeriod\n  ) internal view virtual {\n    assertValueInRange(\n      annualInterestBips,\n      MinimumAnnualInterestBips,\n      MaximumAnnualInterestBips,\n      AnnualInterestBipsOutOfBounds.selector\n    );\n    assertValueInRange(\n      delinquencyFeeBips,\n      MinimumDelinquencyFeeBips,\n      MaximumDelinquencyFeeBips,\n      DelinquencyFeeBipsOutOfBounds.selector\n    );\n    assertValueInRange(\n      withdrawalBatchDuration,\n      MinimumWithdrawalBatchDuration,\n      MaximumWithdrawalBatchDuration,\n      WithdrawalBatchDurationOutOfBounds.selector\n    );\n    assertValueInRange(\n      reserveRatioBips,\n      MinimumReserveRatioBips,\n      MaximumReserveRatioBips,\n      ReserveRatioBipsOutOfBounds.selector\n    );\n    assertValueInRange(\n      delinquencyGracePeriod,\n      MinimumDelinquencyGracePeriod,\n      MaximumDelinquencyGracePeriod,\n      DelinquencyGracePeriodOutOfBounds.selector\n    );\n  }\n\n  /**\n   * @dev Returns immutable constraints on market parameters that\n   *      the controller variant will enforce.\n   */\n  function getParameterConstraints()\n    external\n    pure\n    returns (MarketParameterConstraints memory constraints)\n  {\n    constraints.minimumDelinquencyGracePeriod = MinimumDelinquencyGracePeriod;\n    constraints.maximumDelinquencyGracePeriod = MaximumDelinquencyGracePeriod;\n    constraints.minimumReserveRatioBips = MinimumReserveRatioBips;\n    constraints.maximumReserveRatioBips = MaximumReserveRatioBips;\n    constraints.minimumDelinquencyFeeBips = MinimumDelinquencyFeeBips;\n    constraints.maximumDelinquencyFeeBips = MaximumDelinquencyFeeBips;\n    constraints.minimumWithdrawalBatchDuration = MinimumWithdrawalBatchDuration;\n    constraints.maximumWithdrawalBatchDuration = MaximumWithdrawalBatchDuration;\n    constraints.minimumAnnualInterestBips = MinimumAnnualInterestBips;\n    constraints.maximumAnnualInterestBips = MaximumAnnualInterestBips;\n  }\n\n  function _onCreateMarket(\n    address /* deployer */,\n    address /* marketAddress */,\n    DeployMarketInputs calldata parameters,\n    bytes calldata /* extraData */\n  ) internal virtual override returns (HooksConfig) {\n    enforceParameterConstraints(\n      parameters.annualInterestBips,\n      parameters.delinquencyFeeBips,\n      parameters.withdrawalBatchDuration,\n      parameters.reserveRatioBips,\n      parameters.delinquencyGracePeriod\n    );\n  }\n\n  /**\n   * @dev Returns the new temporary reserve ratio for a given interest rate\n   *      change. This is calculated as no change if the rate change is LEQ\n   *      a 25% decrease, otherwise double the relative difference between\n   *      the old and new APR rates (in bips), bounded to a maximum of 100%.\n   *      If this value is lower than the existing reserve ratio, the existing\n   *      reserve ratio is returned instead.\n   */\n  function _calculateTemporaryReserveRatioBips(\n    uint256 annualInterestBips,\n    uint256 originalAnnualInterestBips,\n    uint256 originalReserveRatioBips\n  ) internal pure returns (uint16 temporaryReserveRatioBips) {\n    // Calculate the relative reduction in the interest rate in bips,\n    // bound to a maximum of 100%\n    uint256 relativeDiff = MathUtils.mulDiv(\n      10000,\n      originalAnnualInterestBips - annualInterestBips,\n      originalAnnualInterestBips\n    );\n\n    // If the reduction is 25% (2500 bips) or less, return the original reserve ratio\n    if (relativeDiff <= 2500) {\n      temporaryReserveRatioBips = uint16(originalReserveRatioBips);\n    } else {\n      // Calculate double the relative reduction in the interest rate in bips,\n      // bound to a maximum of 100%\n      uint256 boundRelativeDiff = MathUtils.min(10000, 2 * relativeDiff);\n\n      // If the bound relative diff is lower than the existing reserve ratio, return the latter.\n      temporaryReserveRatioBips = uint16(\n        MathUtils.max(boundRelativeDiff, originalReserveRatioBips)\n      );\n    }\n  }\n\n  /**\n   * @dev Hook to enforce constraints on changes to the annual interest rate\n   *      and reserve ratio. Reducing the APR triggers an update period of two weeks,\n   *      during which the market's reserve ratio is temporarily increased proportionally\n   *      to the reduction. The original APR is pegged to the previous value during this\n   *      time to prevent abuse of the allowed 25% unpenalized reduction.\n   *\n   * @param annualInterestBips The new annual interest rate in bips provided by the borrower.\n   * @param {} Unused parameter for the reserve ratio bips provided by the borrower.\n   * @param intermediateState The current state of the market.\n   * @param {} Unused parameter for extra data.\n   *\n   * @return newAnnualInterestBips The new annual interest rate in bips to be set.\n   *                               always equal to the input parameter.\n   * @return newReserveRatioBips The new reserve ratio in bips to be set.\n   */\n  function onSetAnnualInterestAndReserveRatioBips(\n    uint16 annualInterestBips,\n    uint16 /* reserveRatioBips */,\n    MarketState calldata intermediateState,\n    bytes calldata /* extraData */\n  ) public virtual override returns (uint16 newAnnualInterestBips, uint16 newReserveRatioBips) {\n    (newAnnualInterestBips, newReserveRatioBips) = (\n      annualInterestBips,\n      intermediateState.reserveRatioBips\n    );\n    address market = msg.sender;\n\n    assertValueInRange(\n      annualInterestBips,\n      MinimumAnnualInterestBips,\n      MaximumAnnualInterestBips,\n      AnnualInterestBipsOutOfBounds.selector\n    );\n\n    // Get the existing temporary reserve ratio from storage, if any\n    TemporaryReserveRatio memory tmp = temporaryExcessReserveRatio[market];\n\n    if (tmp.expiry > 0) {\n      bool canExpire = (annualInterestBips >= intermediateState.annualInterestBips).and(\n        block.timestamp >= tmp.expiry\n      );\n      bool canCancel = annualInterestBips >= tmp.originalAnnualInterestBips;\n      if (canExpire.or(canCancel)) {\n        // If the update period has expired and the provided value doesn't reduce it further,\n        // or it is not expired but the new value undoes the reduction for the current update\n        // period, reset the temporary reserve ratio.\n        if (canExpire) {\n          emit TemporaryExcessReserveRatioExpired(market);\n        } else {\n          emit TemporaryExcessReserveRatioCanceled(market);\n        }\n        delete temporaryExcessReserveRatio[market];\n        return (newAnnualInterestBips, tmp.originalReserveRatioBips);\n      }\n    }\n\n    // Get the original values for the ongoing or newly created update period.\n    (uint16 originalAnnualInterestBips, uint16 originalReserveRatioBips) = tmp.expiry == 0\n      ? (intermediateState.annualInterestBips, intermediateState.reserveRatioBips)\n      : (tmp.originalAnnualInterestBips, tmp.originalReserveRatioBips);\n\n    if (annualInterestBips < originalAnnualInterestBips) {\n      // If the new interest rate is lower than the original, calculate a temporarily\n      // increased reserve ratio as:\n      // relativeReduction <= 0.25 ? originalReserveRatio : max(originalReserveRatio, min(2 * relativeReduction, 100%))\n      uint16 temporaryReserveRatioBips = _calculateTemporaryReserveRatioBips(\n        annualInterestBips,\n        originalAnnualInterestBips,\n        originalReserveRatioBips\n      );\n      uint32 expiry = uint32(block.timestamp + 2 weeks);\n      if (tmp.expiry == 0) {\n        // If there is no existing temporary reserve ratio, store the current\n        // interest rate and reserve ratio as the original values.\n        emit TemporaryExcessReserveRatioActivated(\n          market,\n          originalReserveRatioBips,\n          temporaryReserveRatioBips,\n          expiry\n        );\n        tmp.originalAnnualInterestBips = originalAnnualInterestBips;\n        tmp.originalReserveRatioBips = originalReserveRatioBips;\n      } else {\n        // If the new APR is lower than the original but higher than the current rate,\n        // update the reserve ratio but leave the previous expiry; otherwise, reset the timer.\n        if (annualInterestBips >= intermediateState.annualInterestBips) {\n          expiry = tmp.expiry;\n        }\n        emit TemporaryExcessReserveRatioUpdated(\n          market,\n          originalReserveRatioBips,\n          temporaryReserveRatioBips,\n          expiry\n        );\n      }\n      tmp.expiry = expiry;\n      temporaryExcessReserveRatio[market] = tmp;\n      newReserveRatioBips = temporaryReserveRatioBips;\n    }\n  }\n}\n"},"src/lens/HooksConfigData.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport '../types/HooksConfig.sol';\nimport '../access/IHooks.sol';\nimport { HookedMarket as OpenTermHookedMarket, OpenTermHooks } from '../access/OpenTermHooks.sol';\nimport { HookedMarket as FixedTermHookedMarket, FixedTermHooks } from '../access/FixedTermHooks.sol';\nimport { WildcatMarket } from '../market/WildcatMarket.sol';\n\nenum HooksInstanceKind {\n  Unknown,\n  OpenTerm,\n  FixedTermLoan\n}\n\nusing HooksConfigDataLib for HooksConfigData global;\nusing HooksConfigDataLib for HooksDeploymentFlags global;\nusing HooksConfigDataLib for MarketHooksData global;\n\nstruct HooksConfigData {\n  bool useOnDeposit;\n  bool useOnQueueWithdrawal;\n  bool useOnExecuteWithdrawal;\n  bool useOnTransfer;\n  bool useOnBorrow;\n  bool useOnRepay;\n  bool useOnCloseMarket;\n  bool useOnNukeFromOrbit;\n  bool useOnSetMaxTotalSupply;\n  bool useOnSetAnnualInterestAndReserveRatioBips;\n  bool useOnSetProtocolFeeBips;\n}\n\nstruct HooksDeploymentFlags {\n  HooksConfigData optional;\n  HooksConfigData required;\n}\n\nstruct MarketHooksData {\n  address hooksAddress;\n  HooksConfigData flags;\n  HooksInstanceKind kind;\n  // Shared flags\n  bool transferRequiresAccess;\n  bool depositRequiresAccess;\n  uint128 minimumDeposit;\n  bool transfersDisabled;\n  bool allowForceBuyBacks;\n  // Fixed term loan flags\n  bool withdrawalRequiresAccess;\n  uint32 fixedTermEndTime;\n  bool allowClosureBeforeTerm;\n  bool allowTermReduction;\n}\n\nlibrary HooksConfigDataLib {\n  using HooksConfigDataLib for *;\n\n  function fill(MarketHooksData memory data, address marketAddress) internal view {\n    WildcatMarket market = WildcatMarket(marketAddress);\n    HooksConfig encodedHooksConfig = market.hooks();\n    data.hooksAddress = encodedHooksConfig.hooksAddress();\n    data.flags.fill(encodedHooksConfig);\n    bytes32 versionHash = keccak256(bytes(IHooks(encodedHooksConfig.hooksAddress()).version()));\n    if (versionHash == keccak256(bytes('OpenTermHooks'))) {\n      data.kind = HooksInstanceKind.OpenTerm;\n      OpenTermHooks hooks = OpenTermHooks(data.hooksAddress);\n      OpenTermHookedMarket memory hookedMarket = hooks.getHookedMarket(marketAddress);\n      data.transferRequiresAccess = hookedMarket.transferRequiresAccess;\n      data.depositRequiresAccess = hookedMarket.depositRequiresAccess;\n      data.minimumDeposit = hookedMarket.minimumDeposit;\n      data.transfersDisabled = hookedMarket.transfersDisabled;\n      data.allowForceBuyBacks = hookedMarket.allowForceBuyBacks;\n    } else if (versionHash == keccak256(bytes('FixedTermHooks'))) {\n      data.kind = HooksInstanceKind.FixedTermLoan;\n      FixedTermHooks hooks = FixedTermHooks(data.hooksAddress);\n      FixedTermHookedMarket memory hookedMarket = hooks.getHookedMarket(marketAddress);\n      data.transferRequiresAccess = hookedMarket.transferRequiresAccess;\n      data.depositRequiresAccess = hookedMarket.depositRequiresAccess;\n      data.withdrawalRequiresAccess = hookedMarket.withdrawalRequiresAccess;\n      data.minimumDeposit = hookedMarket.minimumDeposit;\n      data.fixedTermEndTime = hookedMarket.fixedTermEndTime;\n      data.transfersDisabled = hookedMarket.transfersDisabled;\n      data.allowClosureBeforeTerm = hookedMarket.allowClosureBeforeTerm;\n      data.allowTermReduction = hookedMarket.allowTermReduction;\n      data.allowForceBuyBacks = hookedMarket.allowForceBuyBacks;\n    }\n  }\n\n  function fill(HooksConfigData memory data, HooksConfig hooksConfig) internal pure {\n    data.useOnDeposit = hooksConfig.useOnDeposit();\n    data.useOnQueueWithdrawal = hooksConfig.useOnQueueWithdrawal();\n    data.useOnExecuteWithdrawal = hooksConfig.useOnExecuteWithdrawal();\n    data.useOnTransfer = hooksConfig.useOnTransfer();\n    data.useOnBorrow = hooksConfig.useOnBorrow();\n    data.useOnRepay = hooksConfig.useOnRepay();\n    data.useOnCloseMarket = hooksConfig.useOnCloseMarket();\n    data.useOnNukeFromOrbit = hooksConfig.useOnNukeFromOrbit();\n    data.useOnSetMaxTotalSupply = hooksConfig.useOnSetMaxTotalSupply();\n    data.useOnSetAnnualInterestAndReserveRatioBips = hooksConfig\n      .useOnSetAnnualInterestAndReserveRatioBips();\n    data.useOnSetProtocolFeeBips = hooksConfig.useOnSetProtocolFeeBips();\n  }\n\n  function fill(HooksDeploymentFlags memory data, HooksDeploymentConfig config) internal pure {\n    data.optional.fill(config.optionalFlags());\n    data.required.fill(config.requiredFlags());\n  }\n}\n"},"src/lens/HooksTemplateData.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport '../HooksFactory.sol';\nimport './TokenData.sol';\n\nusing HooksTemplateDataLib for HooksTemplateData global;\nusing HooksTemplateDataLib for FeeConfiguration global;\n\nstruct HooksTemplateData {\n  address hooksTemplate;\n  FeeConfiguration fees;\n  bool exists;\n  bool enabled;\n  uint24 index;\n  string name;\n  uint256 totalMarkets;\n}\n\nstruct FeeConfiguration {\n  address feeRecipient;\n  /// @dev Basis points paid on interest for markets deployed using hooks\n  ///      based on this template\n  uint16 protocolFeeBips;\n  /// @dev Asset used to pay origination fee\n  TokenMetadata originationFeeToken;\n  /// @dev Amount of `originationFeeAsset` paid to deploy a new market using\n  ///      an instance of this template.\n  uint256 originationFeeAmount;\n  /// @dev Balance of the borrower in `originationFeeAsset`\n  uint256 borrowerOriginationFeeBalance;\n  /// @dev Approval from the borrower for the hooks factory to transfer `originationFeeAsset`\n  uint256 borrowerOriginationFeeApproval;\n}\n\nlibrary HooksTemplateDataLib {\n  function fill(\n    HooksTemplateData memory data,\n    HooksFactory factory,\n    address hooksTemplate,\n    address borrower\n  ) internal view {\n    HooksTemplate memory template = factory.getHooksTemplateDetails(hooksTemplate);\n    data.hooksTemplate = hooksTemplate;\n    data.exists = template.exists;\n    data.enabled = template.enabled;\n    data.index = template.index;\n    data.name = template.name;\n    data.totalMarkets = factory.getMarketsForHooksTemplateCount(hooksTemplate);\n    data.fees.fill(template, factory, borrower);\n  }\n\n  function fill(\n    FeeConfiguration memory data,\n    HooksTemplate memory template,\n    HooksFactory factory,\n    address borrower\n  ) internal view {\n    data.feeRecipient = template.feeRecipient;\n    data.protocolFeeBips = template.protocolFeeBips;\n    data.originationFeeAmount = template.originationFeeAmount;\n    if (template.originationFeeAsset != address(0)) {\n      data.originationFeeToken.fill(template.originationFeeAsset);\n      if (borrower != address(0)) {\n        IERC20 feeAsset = IERC20(template.originationFeeAsset);\n        data.borrowerOriginationFeeBalance = feeAsset.balanceOf(borrower);\n        data.borrowerOriginationFeeApproval = feeAsset.allowance(borrower, address(factory));\n      }\n    }\n  }\n}\n"},"src/lens/LenderAccountData.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.20;\n\nimport '../WildcatArchController.sol';\nimport { OpenTermHooks } from '../access/OpenTermHooks.sol';\nimport './TokenData.sol';\nimport '../types/HooksConfig.sol';\nimport '../types/LenderStatus.sol';\nimport './HooksConfigData.sol';\nimport './HooksTemplateData.sol';\nimport './MarketData.sol';\nimport './RoleProviderData.sol';\n\nusing LenderAccountDataLib for LenderAccountData global;\n\nstruct LenderAccountData {\n  address lender;\n  uint256 scaledBalance;\n  uint256 normalizedBalance;\n  uint256 underlyingBalance;\n  uint256 underlyingApproval;\n  // Hooks data\n  bool isBlockedFromDeposits;\n  RoleProviderData lastProvider;\n  bool canRefresh;\n  uint32 lastApprovalTimestamp;\n  bool isKnownLender;\n}\n\ninterface IVersionedContract {\n  function version() external view returns (string memory);\n}\n\nlibrary LenderAccountDataLib {\n  function fill(\n    LenderAccountData memory data,\n    WildcatMarket market,\n    IERC20 underlying,\n    OpenTermHooks hooks,\n    address lenderAddress\n  ) internal view {\n    data.lender = lenderAddress;\n\n    data.scaledBalance = market.scaledBalanceOf(lenderAddress);\n    data.normalizedBalance = market.balanceOf(lenderAddress);\n\n    data.underlyingBalance = underlying.balanceOf(lenderAddress);\n    data.underlyingApproval = underlying.allowance(lenderAddress, address(market));\n    if (address(hooks) != address(0)) {\n      LenderStatus memory status = hooks.getLenderStatus(lenderAddress);\n      if (status.lastProvider != address(0)) {\n        data.isBlockedFromDeposits = status.isBlockedFromDeposits;\n        data.lastProvider.fill(hooks.getRoleProvider(status.lastProvider));\n        data.canRefresh = status.canRefresh;\n        data.lastApprovalTimestamp = status.lastApprovalTimestamp;\n      }\n      data.isKnownLender = hooks.isKnownLenderOnMarket(lenderAddress, address(market));\n    }\n  }\n\n  function fill(\n    LenderAccountData memory data,\n    WildcatMarket market,\n    address lenderAddress\n  ) internal view {\n    IERC20 underlying = IERC20(market.asset());\n    OpenTermHooks hooks = OpenTermHooks(market.hooks().hooksAddress());\n    data.fill(market, underlying, hooks, lenderAddress);\n  }\n\n  function fill(\n    LenderAccountData memory data,\n    MarketData memory market,\n    address lenderAddress\n  ) internal view {\n    data.fill(\n      WildcatMarket(market.marketToken.token),\n      IERC20(market.underlyingToken.token),\n      OpenTermHooks(market.hooksConfig.hooksAddress),\n      lenderAddress\n    );\n  }\n}\n"},"src/lens/WithdrawalBatchData.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.20;\n\nimport '../WildcatArchController.sol';\nimport '../market/WildcatMarket.sol';\nimport '../types/HooksConfig.sol';\nimport '../access/MarketConstraintHooks.sol';\nimport './HooksConfigData.sol';\nimport './HooksInstanceData.sol';\nimport './HooksTemplateData.sol';\nimport './LenderAccountData.sol';\nimport './TokenData.sol';\n\nusing WithdrawalBatchDataLib for WithdrawalBatchData global;\nusing WithdrawalBatchDataLib for WithdrawalBatchLenderStatus global;\nusing WithdrawalBatchDataLib for WithdrawalBatchDataWithLenderStatus global;\n\nenum BatchStatus {\n  Pending,\n  Expired,\n  Unpaid,\n  Complete\n}\n\nstruct WithdrawalBatchData {\n  uint32 expiry;\n  BatchStatus status;\n  uint256 scaledTotalAmount;\n  uint256 scaledAmountBurned;\n  uint256 normalizedAmountPaid;\n  uint256 normalizedTotalAmount;\n}\n\nstruct WithdrawalBatchLenderStatus {\n  address lender;\n  uint256 scaledAmount;\n  uint256 normalizedAmountWithdrawn;\n  uint256 normalizedAmountOwed;\n  uint256 availableWithdrawalAmount;\n}\n\nstruct WithdrawalBatchDataWithLenderStatus {\n  WithdrawalBatchData batch;\n  WithdrawalBatchLenderStatus lenderStatus;\n}\n\nlibrary WithdrawalBatchDataLib {\n  function fill(\n    WithdrawalBatchData memory data,\n    WildcatMarket market,\n    uint32 expiry\n  ) internal view {\n    WithdrawalBatch memory batch = market.getWithdrawalBatch(expiry);\n    data.expiry = expiry;\n    data.scaledTotalAmount = batch.scaledTotalAmount;\n    data.scaledAmountBurned = batch.scaledAmountBurned;\n    data.normalizedAmountPaid = batch.normalizedAmountPaid;\n    if (expiry >= block.timestamp) {\n      data.status = BatchStatus.Pending;\n    } else if (expiry > market.previousState().lastInterestAccruedTimestamp) {\n      data.status = BatchStatus.Expired;\n    } else {\n      data.status = data.scaledAmountBurned == data.scaledTotalAmount\n        ? BatchStatus.Complete\n        : BatchStatus.Unpaid;\n    }\n    if (data.scaledAmountBurned != data.scaledTotalAmount) {\n      uint256 scaledAmountOwed = data.scaledTotalAmount - data.scaledAmountBurned;\n      uint256 normalizedAmountOwed = MathUtils.rayMul(scaledAmountOwed, market.scaleFactor());\n      data.normalizedTotalAmount = data.normalizedAmountPaid + normalizedAmountOwed;\n    } else {\n      data.normalizedTotalAmount = data.normalizedAmountPaid;\n    }\n  }\n\n  function fill(\n    WithdrawalBatchLenderStatus memory data,\n    WildcatMarket market,\n    WithdrawalBatchData memory batch,\n    address lender\n  ) internal view {\n    data.lender = lender;\n    AccountWithdrawalStatus memory status = market.getAccountWithdrawalStatus(lender, batch.expiry);\n    data.scaledAmount = status.scaledAmount;\n    data.normalizedAmountWithdrawn = status.normalizedAmountWithdrawn;\n    data.normalizedAmountOwed =\n      MathUtils.mulDiv(batch.normalizedTotalAmount, data.scaledAmount, batch.scaledTotalAmount) -\n      data.normalizedAmountWithdrawn;\n    data.availableWithdrawalAmount =\n      MathUtils.mulDiv(batch.normalizedAmountPaid, data.scaledAmount, batch.scaledTotalAmount) -\n      data.normalizedAmountWithdrawn;\n  }\n\n  function fill(\n    WithdrawalBatchDataWithLenderStatus memory data,\n    WildcatMarket market,\n    uint32 expiry,\n    address lender\n  ) internal view {\n    data.batch.fill(market, expiry);\n    data.lenderStatus.fill(market, data.batch, lender);\n  }\n}\n"},"src/interfaces/IERC20.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.20;\n\ninterface IERC20 {\n  event Transfer(address indexed from, address indexed to, uint256 value);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n\n  function totalSupply() external view returns (uint256);\n\n  function balanceOf(address account) external view returns (uint256);\n\n  function transfer(address recipient, uint256 amount) external returns (bool);\n\n  function allowance(address owner, address spender) external view returns (uint256);\n\n  function approve(address spender, uint256 amount) external returns (bool);\n\n  function increaseAllowance(address spender, uint256 addedValue) external returns (bool);\n\n  function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool);\n\n  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n  function name() external view returns (string memory);\n\n  function symbol() external view returns (string memory);\n\n  function decimals() external view returns (uint8);\n}\n"},"src/interfaces/WildcatStructsAndEnums.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.20;\n\nimport { MarketState } from '../libraries/MarketState.sol';\n\nimport { HooksConfig } from '../types/HooksConfig.sol';\n\nstruct MarketParameters {\n  address asset;\n  uint8 decimals;\n  bytes32 packedNameWord0;\n  bytes32 packedNameWord1;\n  bytes32 packedSymbolWord0;\n  bytes32 packedSymbolWord1;\n  address borrower;\n  address feeRecipient;\n  address sentinel;\n  uint128 maxTotalSupply;\n  uint16 protocolFeeBips;\n  uint16 annualInterestBips;\n  uint16 delinquencyFeeBips;\n  uint32 withdrawalBatchDuration;\n  uint16 reserveRatioBips;\n  uint32 delinquencyGracePeriod;\n  address archController;\n  address sphereXEngine;\n  HooksConfig hooks;\n}\n\nstruct DeployMarketInputs {\n  address asset;\n  string namePrefix;\n  string symbolPrefix;\n  uint128 maxTotalSupply;\n  uint16 annualInterestBips;\n  uint16 delinquencyFeeBips;\n  uint32 withdrawalBatchDuration;\n  uint16 reserveRatioBips;\n  uint32 delinquencyGracePeriod;\n  HooksConfig hooks;\n}\n\nstruct MarketControllerParameters {\n  address archController;\n  address borrower;\n  address sentinel;\n  address marketInitCodeStorage;\n  uint256 marketInitCodeHash;\n  uint32 minimumDelinquencyGracePeriod;\n  uint32 maximumDelinquencyGracePeriod;\n  uint16 minimumReserveRatioBips;\n  uint16 maximumReserveRatioBips;\n  uint16 minimumDelinquencyFeeBips;\n  uint16 maximumDelinquencyFeeBips;\n  uint32 minimumWithdrawalBatchDuration;\n  uint32 maximumWithdrawalBatchDuration;\n  uint16 minimumAnnualInterestBips;\n  uint16 maximumAnnualInterestBips;\n  address sphereXEngine;\n}\n\nstruct ProtocolFeeConfiguration {\n  address feeRecipient;\n  address originationFeeAsset;\n  uint80 originationFeeAmount;\n  uint16 protocolFeeBips;\n}\n\nstruct MarketParameterConstraints {\n  uint32 minimumDelinquencyGracePeriod;\n  uint32 maximumDelinquencyGracePeriod;\n  uint16 minimumReserveRatioBips;\n  uint16 maximumReserveRatioBips;\n  uint16 minimumDelinquencyFeeBips;\n  uint16 maximumDelinquencyFeeBips;\n  uint32 minimumWithdrawalBatchDuration;\n  uint32 maximumWithdrawalBatchDuration;\n  uint16 minimumAnnualInterestBips;\n  uint16 maximumAnnualInterestBips;\n}\n"},"src/access/OpenTermHooks.sol":{"content":"// SPDX-License-Identifier: Apache-2.0 WITH LicenseRef-Commons-Clause-1.0\npragma solidity ^0.8.20;\n\nimport './MarketConstraintHooks.sol';\nimport '../libraries/SafeCastLib.sol';\nimport './BaseAccessControls.sol';\n\nusing BoolUtils for bool;\nusing MathUtils for uint256;\nusing SafeCastLib for uint256;\n\nstruct HookedMarket {\n  bool isHooked;\n  bool transferRequiresAccess;\n  bool depositRequiresAccess;\n  uint128 minimumDeposit;\n  bool transfersDisabled;\n  bool allowForceBuyBacks;\n}\n\n/**\n * @title OpenTermHooks\n * @dev Hooks contract for wildcat markets. Restricts access to deposits\n *      to accounts that have credentials from approved role providers, or\n *      which are manually approved by the borrower.\n *\n *      Withdrawals are restricted in the same way for users that have not\n *      made a deposit, while users who have made a deposit at any point (or\n *      received market tokens while having deposit access) will always remain\n *      approved, even if their access is later revoked.\n *\n *      Deposit access may be canceled by the borrower.\n */\ncontract OpenTermHooks is BaseAccessControls, MarketConstraintHooks {\n  // ========================================================================== //\n  //                                   Events                                   //\n  // ========================================================================== //\n  event MinimumDepositUpdated(address market, uint128 newMinimumDeposit);\n  event DisabledForceBuyBacks(address market);\n\n  // ========================================================================== //\n  //                                   Errors                                   //\n  // ========================================================================== //\n\n  error NotHookedMarket();\n  error DepositBelowMinimum();\n  error TransfersDisabled();\n  error ForceBuyBacksDisabled();\n\n  // ========================================================================== //\n  //                                    State                                   //\n  // ========================================================================== //\n\n  HooksDeploymentConfig public immutable override config;\n\n  mapping(address => HookedMarket) internal _hookedMarkets;\n\n  // ========================================================================== //\n  //                                 Constructor                                //\n  // ========================================================================== //\n\n  /**\n   * @param _deployer Address of the account that called the factory.\n   * @param args Optional abi-encoded `NameAndProviderInputs` struct to initialize\n   *             the providers and name for the hooks instance.\n   */\n  constructor(address _deployer, bytes memory args) BaseAccessControls(_deployer) IHooks() {\n    HooksConfig optionalFlags = encodeHooksConfig({\n      hooksAddress: address(0),\n      useOnDeposit: true,\n      useOnQueueWithdrawal: true,\n      useOnExecuteWithdrawal: false,\n      useOnTransfer: true,\n      useOnBorrow: false,\n      useOnRepay: false,\n      useOnCloseMarket: false,\n      useOnNukeFromOrbit: false,\n      useOnSetMaxTotalSupply: false,\n      useOnSetAnnualInterestAndReserveRatioBips: false,\n      useOnSetProtocolFeeBips: false\n    });\n    HooksConfig requiredFlags = EmptyHooksConfig.setFlag(\n      Bit_Enabled_SetAnnualInterestAndReserveRatioBips\n    );\n    config = encodeHooksDeploymentConfig(optionalFlags, requiredFlags);\n\n    if (args.length > 0) {\n      NameAndProviderInputs memory inputs = abi.decode(args, (NameAndProviderInputs));\n      _initialize(inputs);\n    }\n  }\n\n  function version() external pure override returns (string memory) {\n    return 'OpenTermHooks';\n  }\n\n  function _readBoolCd(bytes calldata data, uint offset) internal pure returns (bool value) {\n    assembly {\n      value := and(calldataload(add(data.offset, offset)), 1)\n    }\n  }\n\n  function _readUint128Cd(bytes calldata data) internal pure returns (uint128 value) {\n    uint _value;\n    assembly {\n      _value := calldataload(data.offset)\n    }\n    return _value.toUint128();\n  }\n\n  /**\n   * @dev Called when market is deployed using this contract as its `hooks`.\n   *\n   *     @param deployer      Address of the account that called the factory - must\n   *                          match the borrower address.\n   *     @param marketAddress Address of the market being deployed.\n   *     @param parameters    Parameters used to deploy the market.\n   *     @param hooksData     Extra data passed to the market deployment function containing\n   *                          the parameters for the hooks.\n   *\n   *     `hooksData` is a tuple of (\n   *        uint128? minimumDeposit,\n   *        bool? transfersDisabled,\n   *        bool? allowForceBuyBacks\n   *     )\n   *     Where none of the parameters are mandatory.\n   *\n   *      Note: Called inside the root `onCreateMarket` in the base contract,\n   *      so no need to verify the caller is the factory.\n   */\n  function _onCreateMarket(\n    address deployer,\n    address marketAddress,\n    DeployMarketInputs calldata parameters,\n    bytes calldata hooksData\n  ) internal override returns (HooksConfig marketHooksConfig) {\n    // Validate the deploy parameters\n    super._onCreateMarket(deployer, marketAddress, parameters, hooksData);\n    if (deployer != borrower) revert CallerNotBorrower();\n    marketHooksConfig = parameters.hooks;\n\n    // Read `minimumDeposit`, `transfersDisabled`, and `allowForceBuyBacks` from `hooksData`\n    // If the calldata does not contain sufficient bytes for a parameter, it will be read as zero.\n    //\n    // Use the deposit and transfer flags to determine whether those require access control.\n    // These are tracked separately because if the market enables `onQueueWithdrawal`, deposit\n    // and transfer hooks will also be  enabled, but may not require access control.\n    HookedMarket memory hookedMarket = HookedMarket({\n      isHooked: true,\n      transferRequiresAccess: marketHooksConfig.useOnTransfer(),\n      depositRequiresAccess: marketHooksConfig.useOnDeposit(),\n      minimumDeposit: _readUint128Cd(hooksData),\n      transfersDisabled: _readBoolCd(hooksData, 0x20),\n      allowForceBuyBacks: _readBoolCd(hooksData, 0x40)\n    });\n\n    if (hookedMarket.minimumDeposit > 0) {\n      // If there is a minimum deposit, the deposit hook must be enabled\n      marketHooksConfig = marketHooksConfig.setFlag(Bit_Enabled_Deposit);\n      emit MinimumDepositUpdated(marketAddress, hookedMarket.minimumDeposit);\n    }\n    if (hookedMarket.transfersDisabled) {\n      // If transfers are disabled, the transfer hook must be enabled\n      marketHooksConfig = marketHooksConfig.setFlag(Bit_Enabled_Transfer);\n    }\n\n    if (marketHooksConfig.useOnQueueWithdrawal()) {\n      marketHooksConfig = marketHooksConfig.setFlag(Bit_Enabled_Transfer).setFlag(\n        Bit_Enabled_Deposit\n      );\n    }\n    marketHooksConfig = marketHooksConfig.mergeFlags(config);\n    _hookedMarkets[address(marketAddress)] = hookedMarket;\n  }\n\n  // ========================================================================== //\n  //                              Market Management                             //\n  // ========================================================================== //\n\n  function setMinimumDeposit(address market, uint128 newMinimumDeposit) external onlyBorrower {\n    HookedMarket storage hookedMarket = _hookedMarkets[market];\n    if (!hookedMarket.isHooked) revert NotHookedMarket();\n    hookedMarket.minimumDeposit = newMinimumDeposit;\n    emit MinimumDepositUpdated(market, newMinimumDeposit);\n  }\n\n  function disableForceBuyBacks(address market) external onlyBorrower {\n    HookedMarket storage hookedMarket = _hookedMarkets[market];\n    if (!hookedMarket.isHooked) revert NotHookedMarket();\n    if (hookedMarket.allowForceBuyBacks) {\n      hookedMarket.allowForceBuyBacks = false;\n      emit DisabledForceBuyBacks(market);\n    }\n  }\n\n  // ========================================================================== //\n  //                               Market Queries                               //\n  // ========================================================================== //\n\n  function getHookedMarket(address marketAddress) external view returns (HookedMarket memory) {\n    return _hookedMarkets[marketAddress];\n  }\n\n  function getHookedMarkets(\n    address[] calldata marketAddresses\n  ) external view returns (HookedMarket[] memory hookedMarkets) {\n    hookedMarkets = new HookedMarket[](marketAddresses.length);\n    for (uint256 i = 0; i < marketAddresses.length; i++) {\n      hookedMarkets[i] = _hookedMarkets[marketAddresses[i]];\n    }\n  }\n\n  // ========================================================================== //\n  //                                    Hooks                                   //\n  // ========================================================================== //\n\n  /**\n   * @dev Called when a lender attempts to deposit.\n   *      Passes the check if the deposit amount is at least the minimum deposit\n   *      amount, the lender is not blocked from depositing, and either the lender\n   *      has a valid credential or the market does not require access for deposits.\n   */\n  function onDeposit(\n    address lender,\n    uint scaledAmount,\n    MarketState calldata state,\n    bytes calldata hooksData\n  ) external override {\n    HookedMarket memory market = _hookedMarkets[msg.sender];\n    if (!market.isHooked) revert NotHookedMarket();\n\n    // Retrieve the lender's status from storage\n    LenderStatus memory status = _lenderStatus[lender];\n\n    // Check that the lender is not blocked\n    if (status.isBlockedFromDeposits) revert NotApprovedLender();\n\n    // Check that the deposit amount is at or above the market's minimum\n    uint normalizedAmount = scaledAmount.rayMul(state.scaleFactor);\n    if (market.minimumDeposit > normalizedAmount) {\n      revert DepositBelowMinimum();\n    }\n\n    // Attempt to validate the lender's access\n    // Uses the inner method here as storage may need to be updated if this\n    // is their first deposit\n    (bool hasValidCredential, bool roleUpdated) = _tryValidateAccessInner(\n      status,\n      lender,\n      hooksData\n    );\n\n    if (market.depositRequiresAccess.and(!hasValidCredential)) {\n      revert NotApprovedLender();\n    }\n\n    _writeLenderStatus(status, lender, hasValidCredential, roleUpdated, true);\n  }\n\n  /**\n   * @dev Called when a lender attempts to queue a withdrawal.\n   *      Passes the check if the lender has previously deposited or received\n   *      market tokens while having the ability to deposit, or currently has a\n   *      valid credential from an approved role provider.\n   */\n  function onQueueWithdrawal(\n    address lender,\n    uint32 /* expiry */,\n    uint /* scaledAmount */,\n    MarketState calldata /* state */,\n    bytes calldata hooksData\n  ) external override {\n    LenderStatus memory status = _lenderStatus[lender];\n    if (\n      !isKnownLenderOnMarket[lender][msg.sender] && !_tryValidateAccess(status, lender, hooksData)\n    ) {\n      revert NotApprovedLender();\n    }\n  }\n\n  /**\n   * @dev Hook not implemented for this contract.\n   */\n  function onExecuteWithdrawal(\n    address lender,\n    uint128 /* normalizedAmountWithdrawn */,\n    MarketState calldata /* state */,\n    bytes calldata hooksData\n  ) external override {}\n\n  /**\n   * @dev Called when a lender attempts to transfer market tokens on a market\n   *      that requires credentials for either transfers or withdrawals.\n   *\n   *      Allows the transfer if the recipient:\n   *      - is a known lender OR\n   *      - is not blocked AND\n   *        - has a valid credential OR\n   *        - market does not require a credential for transfers\n   *\n   *    If the recipient is not a known lender but does have a valid\n   *    credential, they will be marked as a known lender.\n   */\n  function onTransfer(\n    address /* caller */,\n    address /* from */,\n    address to,\n    uint /* scaledAmount */,\n    MarketState calldata /* state */,\n    bytes calldata extraData\n  ) external override {\n    HookedMarket memory market = _hookedMarkets[msg.sender];\n\n    if (!market.isHooked) revert NotHookedMarket();\n\n    if (market.transfersDisabled) {\n      revert TransfersDisabled();\n    }\n\n    // If the recipient is a known lender, skip access control checks.\n    if (!isKnownLenderOnMarket[to][msg.sender]) {\n      LenderStatus memory toStatus = _lenderStatus[to];\n      // Respect `isBlockedFromDeposits` only if the recipient is not a known lender\n      if (toStatus.isBlockedFromDeposits) revert NotApprovedLender();\n\n      // Attempt to validate the lender's access even if the market does not require\n      // a credential for transfers, as the recipient may need to be updated to reflect\n      // their new status as a known lender.\n      (bool hasValidCredential, bool wasUpdated) = _tryValidateAccessInner(toStatus, to, extraData);\n\n      // Revert if the recipient does not have a valid credential and the market requires one\n      if (market.transferRequiresAccess.and(!hasValidCredential)) {\n        revert NotApprovedLender();\n      }\n\n      _writeLenderStatus(toStatus, to, hasValidCredential, wasUpdated, true);\n    }\n  }\n\n  /**\n   * @dev Hook not implemented for this contract.\n   */\n  function onBorrow(\n    uint /* normalizedAmount */,\n    MarketState calldata /* state */,\n    bytes calldata /* extraData */\n  ) external override {}\n\n  /**\n   * @dev Hook not implemented for this contract.\n   */\n  function onRepay(\n    uint normalizedAmount,\n    MarketState calldata state,\n    bytes calldata hooksData\n  ) external override {}\n\n  function onCloseMarket(\n    MarketState calldata /* state */,\n    bytes calldata /* hooksData */\n  ) external override {}\n\n  function onNukeFromOrbit(\n    address /* lender */,\n    MarketState calldata /* state */,\n    bytes calldata /* hooksData */\n  ) external override {}\n\n  function onSetMaxTotalSupply(\n    uint256 /* maxTotalSupply */,\n    MarketState calldata /* state */,\n    bytes calldata /* hooksData */\n  ) external override {}\n\n  function onSetAnnualInterestAndReserveRatioBips(\n    uint16 annualInterestBips,\n    uint16 reserveRatioBips,\n    MarketState calldata intermediateState,\n    bytes calldata hooksData\n  )\n    public\n    virtual\n    override\n    returns (uint16 updatedAnnualInterestBips, uint16 updatedReserveRatioBips)\n  {\n    return\n      super.onSetAnnualInterestAndReserveRatioBips(\n        annualInterestBips,\n        reserveRatioBips,\n        intermediateState,\n        hooksData\n      );\n  }\n\n  function onSetProtocolFeeBips(\n    uint16 /* protocolFeeBips */,\n    MarketState memory /* intermediateState */,\n    bytes calldata /* extraData */\n  ) external override {}\n\n  function onForceBuyBack(\n    address /* lender */,\n    uint /* scaledAmount */,\n    MarketState calldata /* intermediateState */,\n    bytes calldata /* extraData */\n  ) external virtual override {\n    HookedMarket memory market = _hookedMarkets[msg.sender];\n    if (!market.isHooked) revert NotHookedMarket();\n    if (!market.allowForceBuyBacks) revert ForceBuyBacksDisabled();\n    // If the borrower does not already have a credential, grant them one\n    LenderStatus storage status = _lenderStatus[borrower];\n    if (!status.hasCredential()) {\n      // Give the borrower a self-granted credential with no expiry so they are\n      // able to withdraw the purchased market tokens.\n      _setCredentialAndEmitAccessGranted(\n        status,\n        _roleProviders[borrower],\n        borrower,\n        uint32(block.timestamp)\n      );\n    }\n  }\n}\n"},"src/access/FixedTermHooks.sol":{"content":"// SPDX-License-Identifier: Apache-2.0 WITH LicenseRef-Commons-Clause-1.0\npragma solidity ^0.8.20;\n\nimport './MarketConstraintHooks.sol';\nimport '../libraries/SafeCastLib.sol';\nimport './BaseAccessControls.sol';\n\nusing BoolUtils for bool;\nusing MathUtils for uint256;\nusing SafeCastLib for uint256;\n\nstruct HookedMarket {\n  bool isHooked;\n  bool transferRequiresAccess;\n  bool depositRequiresAccess;\n  bool withdrawalRequiresAccess;\n  uint128 minimumDeposit;\n  uint32 fixedTermEndTime;\n  bool transfersDisabled;\n  bool allowClosureBeforeTerm;\n  bool allowTermReduction;\n  bool allowForceBuyBacks;\n}\n\n/**\n * @title FixedTermHooks\n * @dev Hooks contract for wildcat markets. Restricts access to deposits\n *      to accounts that have credentials from approved role providers, or\n *      which are manually approved by the borrower. Restricts withdrawals\n *      until a fixed loan term has elapsed, which can be reduced but not\n *      increased by the borrower.\n *\n *      Withdrawals are restricted in the same way for users that have not\n *      made a deposit, while users who have made a deposit at any point (or\n *      received market tokens while having deposit access) will always remain\n *      approved, even if their access is later revoked.\n *\n *      Deposit access may be canceled by the borrower.\n */\ncontract FixedTermHooks is BaseAccessControls, MarketConstraintHooks {\n  // ========================================================================== //\n  //                                   Events                                   //\n  // ========================================================================== //\n\n  event MinimumDepositUpdated(address market, uint128 newMinimumDeposit);\n  event FixedTermUpdated(address market, uint32 fixedTermEndTime);\n  event DisabledForceBuyBacks(address market);\n\n  // ========================================================================== //\n  //                                   Errors                                   //\n  // ========================================================================== //\n\n  error NotHookedMarket();\n  error DepositBelowMinimum();\n  error FixedTermNotProvided();\n  error InvalidFixedTerm();\n  error IncreaseFixedTerm();\n  error WithdrawBeforeTermEnd();\n  error NoReducingAprBeforeTermEnd();\n  error TransfersDisabled();\n  error ForceBuyBacksDisabled();\n  error ForceBuyBackDisabledBeforeTerm();\n  error ClosureDisabledBeforeTerm();\n  error TermReductionDisabled();\n\n  // ========================================================================== //\n  //                                    State                                   //\n  // ========================================================================== //\n\n  uint32 public constant MaximumLoanTerm = 365 days;\n\n  HooksDeploymentConfig public immutable override config;\n\n  mapping(address => HookedMarket) internal _hookedMarkets;\n\n  // ========================================================================== //\n  //                                 Constructor                                //\n  // ========================================================================== //\n\n  /**\n   * @param _deployer Address of the account that called the factory.\n   * @param args Optional abi-encoded `NameAndProviderInputs` struct to initialize\n   *             the providers and name for the hooks instance.\n   */\n  constructor(address _deployer, bytes memory args) BaseAccessControls(_deployer) IHooks() {\n    HooksConfig optionalFlags = encodeHooksConfig({\n      hooksAddress: address(0),\n      useOnDeposit: true,\n      useOnQueueWithdrawal: false,\n      useOnExecuteWithdrawal: false,\n      useOnTransfer: true,\n      useOnBorrow: false,\n      useOnRepay: false,\n      useOnCloseMarket: false,\n      useOnNukeFromOrbit: false,\n      useOnSetMaxTotalSupply: false,\n      useOnSetAnnualInterestAndReserveRatioBips: false,\n      useOnSetProtocolFeeBips: false\n    });\n    HooksConfig requiredFlags = EmptyHooksConfig\n      .setFlag(Bit_Enabled_SetAnnualInterestAndReserveRatioBips)\n      .setFlag(Bit_Enabled_CloseMarket)\n      .setFlag(Bit_Enabled_QueueWithdrawal);\n    config = encodeHooksDeploymentConfig(optionalFlags, requiredFlags);\n\n    if (args.length > 0) {\n      NameAndProviderInputs memory inputs = abi.decode(args, (NameAndProviderInputs));\n      _initialize(inputs);\n    }\n  }\n\n  function version() external pure override returns (string memory) {\n    return 'FixedTermHooks';\n  }\n\n  function _readBoolCd(bytes calldata data, uint offset) internal pure returns (bool value) {\n    assembly {\n      value := and(calldataload(add(data.offset, offset)), 1)\n    }\n  }\n\n  function _readUint32Cd(bytes calldata data) internal pure returns (uint32 value) {\n    uint _value;\n    assembly {\n      _value := calldataload(data.offset)\n    }\n    return _value.toUint32();\n  }\n\n  function _readUint128Cd(bytes calldata data, uint offset) internal pure returns (uint128 value) {\n    uint _value;\n    assembly {\n      _value := calldataload(add(data.offset, offset))\n    }\n    return _value.toUint128();\n  }\n\n  /**\n   * @dev Called when market is deployed using this contract as its `hooks`.\n   *\n   *     @param deployer      Address of the account that called the factory - must\n   *                          match the borrower address.\n   *     @param marketAddress Address of the market being deployed.\n   *     @param parameters    Parameters used to deploy the market.\n   *     @param hooksData     Extra data passed to the market deployment function containing\n   *                          the parameters for the hooks.\n   *\n   *     `hooksData` is a tuple of (\n   *        uint32 fixedTermEndTime,\n   *        uint128? minimumDeposit,\n   *        bool? transfersDisabled,\n   *        bool? allowForceBuyBacks,\n   *        bool? allowClosureBeforeTerm,\n   *        bool? allowTermReduction\n   *     )\n   *     Where none of the parameters are mandatory except `fixedTermEndTime`.\n   *\n   *      Note: Called inside the root `onCreateMarket` in the base contract,\n   *      so no need to verify the caller is the factory.\n   */\n  function _onCreateMarket(\n    address deployer,\n    address marketAddress,\n    DeployMarketInputs calldata parameters,\n    bytes calldata hooksData\n  ) internal override returns (HooksConfig marketHooksConfig) {\n    // Validate the deploy parameters\n    super._onCreateMarket(deployer, marketAddress, parameters, hooksData);\n    if (deployer != borrower) revert CallerNotBorrower();\n    if (hooksData.length < 32) revert FixedTermNotProvided();\n\n    marketHooksConfig = parameters.hooks;\n\n    uint32 fixedTermEndTime = _readUint32Cd(hooksData);\n\n    if (\n      fixedTermEndTime < block.timestamp || (fixedTermEndTime - block.timestamp) > MaximumLoanTerm\n    ) {\n      revert InvalidFixedTerm();\n    }\n    emit FixedTermUpdated(marketAddress, fixedTermEndTime);\n\n    // Use the deposit and transfer flags to determine whether those require\n    // access control. These are tracked separately because if the market\n    // enables `onQueueWithdrawal`, deposit and transfer hooks will also be\n    // enabled, but may not require access control.\n    // Initialisations to zero here (and subsequent updates) are just because\n    // of stack-too-deep errors otherwise.\n\n    // Read `minimumDeposit`, `transfersDisabled`, `allowClosureBeforeTerm` and `allowTermReduction`\n    // from `hooksData`.\n    // If the calldata does not contain sufficient bytes for a parameter, it will be read as zero.\n    HookedMarket memory hookedMarket = HookedMarket({\n      isHooked: true,\n      transferRequiresAccess: marketHooksConfig.useOnTransfer(),\n      depositRequiresAccess: marketHooksConfig.useOnDeposit(),\n      withdrawalRequiresAccess: marketHooksConfig.useOnQueueWithdrawal(),\n      fixedTermEndTime: fixedTermEndTime,\n      minimumDeposit: _readUint128Cd(hooksData, 0x20),\n      transfersDisabled: _readBoolCd(hooksData, 0x40),\n      allowForceBuyBacks: _readBoolCd(hooksData, 0x60),\n      allowClosureBeforeTerm: _readBoolCd(hooksData, 0x80),\n      allowTermReduction: _readBoolCd(hooksData, 0xa0)\n    });\n    if (hookedMarket.minimumDeposit > 0) {\n      marketHooksConfig = marketHooksConfig.setFlag(Bit_Enabled_Deposit);\n      emit MinimumDepositUpdated(marketAddress, hookedMarket.minimumDeposit);\n    }\n    if (hookedMarket.transfersDisabled) {\n      marketHooksConfig = marketHooksConfig.setFlag(Bit_Enabled_Transfer);\n    }\n\n    if (marketHooksConfig.useOnQueueWithdrawal()) {\n      marketHooksConfig = marketHooksConfig.setFlag(Bit_Enabled_Transfer).setFlag(\n        Bit_Enabled_Deposit\n      );\n    }\n    marketHooksConfig = marketHooksConfig.mergeFlags(config);\n    _hookedMarkets[address(marketAddress)] = hookedMarket;\n  }\n\n  // ========================================================================== //\n  //                              Market Management                             //\n  // ========================================================================== //\n\n  function setMinimumDeposit(address market, uint128 newMinimumDeposit) external onlyBorrower {\n    HookedMarket storage hookedMarket = _hookedMarkets[market];\n    if (!hookedMarket.isHooked) revert NotHookedMarket();\n    hookedMarket.minimumDeposit = newMinimumDeposit;\n    emit MinimumDepositUpdated(market, newMinimumDeposit);\n  }\n\n  function setFixedTermEndTime(address market, uint32 newFixedTermEndTime) external onlyBorrower {\n    HookedMarket storage hookedMarket = _hookedMarkets[market];\n    if (!hookedMarket.isHooked) revert NotHookedMarket();\n    if (!hookedMarket.allowTermReduction && newFixedTermEndTime <= hookedMarket.fixedTermEndTime)\n      revert TermReductionDisabled();\n    if (newFixedTermEndTime > hookedMarket.fixedTermEndTime) revert IncreaseFixedTerm();\n    hookedMarket.fixedTermEndTime = newFixedTermEndTime;\n    emit FixedTermUpdated(market, newFixedTermEndTime);\n  }\n\n  function disableForceBuyBacks(address market) external onlyBorrower {\n    HookedMarket storage hookedMarket = _hookedMarkets[market];\n    if (!hookedMarket.isHooked) revert NotHookedMarket();\n    if (hookedMarket.allowForceBuyBacks) {\n      hookedMarket.allowForceBuyBacks = false;\n      emit DisabledForceBuyBacks(market);\n    }\n  }\n\n  // ========================================================================== //\n  //                               Market Queries                               //\n  // ========================================================================== //\n\n  function getHookedMarket(address marketAddress) external view returns (HookedMarket memory) {\n    return _hookedMarkets[marketAddress];\n  }\n\n  function getHookedMarkets(\n    address[] calldata marketAddresses\n  ) external view returns (HookedMarket[] memory hookedMarkets) {\n    hookedMarkets = new HookedMarket[](marketAddresses.length);\n    for (uint256 i = 0; i < marketAddresses.length; i++) {\n      hookedMarkets[i] = _hookedMarkets[marketAddresses[i]];\n    }\n  }\n\n  // ========================================================================== //\n  //                                    Hooks                                   //\n  // ========================================================================== //\n\n  /**\n   * @dev Called when a lender attempts to deposit.\n   *      Passes the check if the lender is not blocked from deposits\n   *      and has a valid credential from an approved role provider.\n   */\n  function onDeposit(\n    address lender,\n    uint scaledAmount,\n    MarketState calldata state,\n    bytes calldata hooksData\n  ) external override {\n    HookedMarket memory market = _hookedMarkets[msg.sender];\n    if (!market.isHooked) revert NotHookedMarket();\n\n    // Retrieve the lender's status from storage\n    LenderStatus memory status = _lenderStatus[lender];\n\n    // Check that the lender is not blocked\n    if (status.isBlockedFromDeposits) revert NotApprovedLender();\n\n    // Check that the deposit amount is at or above the market's minimum\n    uint normalizedAmount = scaledAmount.rayMul(state.scaleFactor);\n    if (market.minimumDeposit > normalizedAmount) {\n      revert DepositBelowMinimum();\n    }\n\n    // Attempt to validate the lender's access\n    // Uses the inner method here as storage may need to be updated if this\n    // is their first deposit\n    (bool hasValidCredential, bool roleUpdated) = _tryValidateAccessInner(\n      status,\n      lender,\n      hooksData\n    );\n\n    if (market.depositRequiresAccess.and(!hasValidCredential)) {\n      revert NotApprovedLender();\n    }\n\n    _writeLenderStatus(status, lender, hasValidCredential, roleUpdated, true);\n  }\n\n  /**\n   * @dev Called when a lender attempts to queue a withdrawal.\n   *      Passes the check if the lender has previously deposited or received\n   *      market tokens while having the ability to deposit, or currently has a\n   *      valid credential from an approved role provider.\n   */\n  function onQueueWithdrawal(\n    address lender,\n    uint32 /* expiry */,\n    uint /* scaledAmount */,\n    MarketState calldata /* state */,\n    bytes calldata hooksData\n  ) external override {\n    HookedMarket memory market = _hookedMarkets[msg.sender];\n    if (!market.isHooked) revert NotHookedMarket();\n    if (market.fixedTermEndTime > block.timestamp) {\n      revert WithdrawBeforeTermEnd();\n    }\n    LenderStatus memory status = _lenderStatus[lender];\n    if (market.withdrawalRequiresAccess) {\n      if (\n        !isKnownLenderOnMarket[lender][msg.sender] && !_tryValidateAccess(status, lender, hooksData)\n      ) {\n        revert NotApprovedLender();\n      }\n    }\n  }\n\n  /**\n   * @dev Hook not implemented for this contract.\n   */\n  function onExecuteWithdrawal(\n    address lender,\n    uint128 /* normalizedAmountWithdrawn */,\n    MarketState calldata /* state */,\n    bytes calldata hooksData\n  ) external override {}\n\n  /**\n   * @dev Called when a lender attempts to transfer market tokens on a market\n   *      that requires credentials for either transfers or withdrawals.\n   *\n   *      Allows the transfer if the recipient:\n   *      - is a known lender OR\n   *      - is not blocked AND\n   *        - has a valid credential OR\n   *        - market does not require a credential for transfers\n   *\n   *    If the recipient is not a known lender but does have a valid\n   *    credential, they will be marked as a known lender.\n   */\n  function onTransfer(\n    address /* caller */,\n    address /* from */,\n    address to,\n    uint /* scaledAmount */,\n    MarketState calldata /* state */,\n    bytes calldata extraData\n  ) external override {\n    HookedMarket memory market = _hookedMarkets[msg.sender];\n\n    if (!market.isHooked) revert NotHookedMarket();\n\n    if (market.transfersDisabled) {\n      revert TransfersDisabled();\n    }\n\n    // If the recipient is a known lender, skip access control checks.\n    if (!isKnownLenderOnMarket[to][msg.sender]) {\n      LenderStatus memory toStatus = _lenderStatus[to];\n      // Respect `isBlockedFromDeposits` only if the recipient is not a known lender\n      if (toStatus.isBlockedFromDeposits) revert NotApprovedLender();\n\n      // Attempt to validate the lender's access even if the market does not require\n      // a credential for transfers, as the recipient may need to be updated to reflect\n      // their new status as a known lender.\n      (bool hasValidCredential, bool wasUpdated) = _tryValidateAccessInner(toStatus, to, extraData);\n\n      // Revert if the recipient does not have a valid credential and the market requires one\n      if (market.transferRequiresAccess.and(!hasValidCredential)) {\n        revert NotApprovedLender();\n      }\n\n      _writeLenderStatus(toStatus, to, hasValidCredential, wasUpdated, true);\n    }\n  }\n\n  /**\n   * @dev Hook not implemented for this contract.\n   */\n  function onBorrow(\n    uint /* normalizedAmount */,\n    MarketState calldata /* state */,\n    bytes calldata /* extraData */\n  ) external override {}\n\n  /**\n   * @dev Hook not implemented for this contract.\n   */\n  function onRepay(\n    uint normalizedAmount,\n    MarketState calldata state,\n    bytes calldata hooksData\n  ) external override {}\n\n  function onCloseMarket(\n    MarketState calldata /* state */,\n    bytes calldata /* hooksData */\n  ) external override {\n    HookedMarket storage market = _hookedMarkets[msg.sender];\n    if (!market.isHooked) revert NotHookedMarket();\n    if (!market.allowClosureBeforeTerm && block.timestamp < market.fixedTermEndTime)\n      revert ClosureDisabledBeforeTerm();\n    if (market.fixedTermEndTime > block.timestamp) {\n      market.fixedTermEndTime = uint32(block.timestamp);\n      emit FixedTermUpdated(msg.sender, market.fixedTermEndTime);\n    }\n  }\n\n  function onNukeFromOrbit(\n    address /* lender */,\n    MarketState calldata /* state */,\n    bytes calldata /* hooksData */\n  ) external override {}\n\n  function onSetMaxTotalSupply(\n    uint256 /* maxTotalSupply */,\n    MarketState calldata /* state */,\n    bytes calldata /* hooksData */\n  ) external override {}\n\n  function onSetAnnualInterestAndReserveRatioBips(\n    uint16 annualInterestBips,\n    uint16 reserveRatioBips,\n    MarketState calldata intermediateState,\n    bytes calldata hooksData\n  )\n    public\n    virtual\n    override\n    returns (uint16 updatedAnnualInterestBips, uint16 updatedReserveRatioBips)\n  {\n    HookedMarket storage hookedMarket = _hookedMarkets[msg.sender];\n\n    /* Revert if market is still in fixed term and new APR is lower than it was */\n    if (\n      (hookedMarket.fixedTermEndTime > block.timestamp) &&\n      (annualInterestBips < intermediateState.annualInterestBips)\n    ) {\n      revert NoReducingAprBeforeTermEnd();\n    }\n\n    return\n      super.onSetAnnualInterestAndReserveRatioBips(\n        annualInterestBips,\n        reserveRatioBips,\n        intermediateState,\n        hooksData\n      );\n  }\n\n  function onSetProtocolFeeBips(\n    uint16 /* protocolFeeBips */,\n    MarketState memory /* intermediateState */,\n    bytes calldata /* extraData */\n  ) external override {}\n\n  function onForceBuyBack(\n    address /* lender */,\n    uint /* scaledAmount */,\n    MarketState calldata /* intermediateState */,\n    bytes calldata /* extraData */\n  ) external virtual override {\n    HookedMarket memory market = _hookedMarkets[msg.sender];\n    if (!market.isHooked) revert NotHookedMarket();\n    if (!market.allowForceBuyBacks) revert ForceBuyBacksDisabled();\n    if (market.fixedTermEndTime > block.timestamp) {\n      revert ForceBuyBackDisabledBeforeTerm();\n    }\n    // If the borrower does not already have a credential, grant them one\n    LenderStatus storage status = _lenderStatus[borrower];\n    if (!status.hasCredential()) {\n      // Give the borrower a self-granted credential with no expiry so they are\n      // able to withdraw the purchased market tokens.\n      _setCredentialAndEmitAccessGranted(\n        status,\n        _roleProviders[borrower],\n        borrower,\n        uint32(block.timestamp)\n      );\n    }\n  }\n}\n"},"src/access/IHooks.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport '../types/HooksConfig.sol';\nimport '../libraries/MarketState.sol';\nimport '../interfaces/WildcatStructsAndEnums.sol';\n\nabstract contract IHooks {\n  error CallerNotFactory();\n\n  address public immutable factory;\n\n  constructor() {\n    factory = msg.sender;\n  }\n\n  /// @dev Returns the version string of the hooks contract.\n  ///      Used to determine what the contract does and how `extraData` is interpreted.\n  function version() external view virtual returns (string memory);\n\n  /// @dev Returns the HooksDeploymentConfig type which contains the sets\n  ///      of optional and required hooks that this contract implements.\n  function config() external view virtual returns (HooksDeploymentConfig);\n\n  function onCreateMarket(\n    address deployer,\n    address marketAddress,\n    DeployMarketInputs calldata parameters,\n    bytes calldata extraData\n  ) external returns (HooksConfig) {\n    if (msg.sender != factory) revert CallerNotFactory();\n    return _onCreateMarket(deployer, marketAddress, parameters, extraData);\n  }\n\n  function _onCreateMarket(\n    address deployer,\n    address marketAddress,\n    DeployMarketInputs calldata parameters,\n    bytes calldata extraData\n  ) internal virtual returns (HooksConfig);\n\n  function onDeposit(\n    address lender,\n    uint256 scaledAmount,\n    MarketState calldata intermediateState,\n    bytes calldata extraData\n  ) external virtual;\n\n  function onQueueWithdrawal(\n    address lender,\n    uint32 expiry,\n    uint scaledAmount,\n    MarketState calldata intermediateState,\n    bytes calldata extraData\n  ) external virtual;\n\n  function onForceBuyBack(\n    address lender,\n    uint scaledAmount,\n    MarketState calldata intermediateState,\n    bytes calldata extraData\n  ) external virtual;\n\n  function onExecuteWithdrawal(\n    address lender,\n    uint128 normalizedAmountWithdrawn,\n    MarketState calldata intermediateState,\n    bytes calldata extraData\n  ) external virtual;\n\n  function onTransfer(\n    address caller,\n    address from,\n    address to,\n    uint scaledAmount,\n    MarketState calldata intermediateState,\n    bytes calldata extraData\n  ) external virtual;\n\n  function onBorrow(\n    uint normalizedAmount,\n    MarketState calldata intermediateState,\n    bytes calldata extraData\n  ) external virtual;\n\n  function onRepay(\n    uint normalizedAmount,\n    MarketState calldata intermediateState,\n    bytes calldata extraData\n  ) external virtual;\n\n  function onCloseMarket(\n    MarketState calldata intermediateState,\n    bytes calldata extraData\n  ) external virtual;\n\n  function onNukeFromOrbit(\n    address lender,\n    MarketState calldata intermediateState,\n    bytes calldata extraData\n  ) external virtual;\n\n  function onSetMaxTotalSupply(\n    uint256 maxTotalSupply,\n    MarketState calldata intermediateState,\n    bytes calldata extraData\n  ) external virtual;\n\n  function onSetAnnualInterestAndReserveRatioBips(\n    uint16 annualInterestBips,\n    uint16 reserveRatioBips,\n    MarketState calldata intermediateState,\n    bytes calldata extraData\n  ) external virtual returns (uint16 updatedAnnualInterestBips, uint16 updatedReserveRatioBips);\n\n  function onSetProtocolFeeBips(\n    uint16 protocolFeeBips,\n    MarketState memory intermediateState,\n    bytes calldata extraData\n  ) external virtual;\n}\n"},"src/HooksFactory.sol":{"content":"// SPDX-License-Identifier: Apache-2.0 WITH LicenseRef-Commons-Clause-1.0\npragma solidity >=0.8.20;\n\nimport './libraries/LibERC20.sol';\nimport './interfaces/IWildcatArchController.sol';\nimport './libraries/LibStoredInitCode.sol';\nimport './libraries/MathUtils.sol';\nimport './ReentrancyGuard.sol';\nimport './interfaces/WildcatStructsAndEnums.sol';\nimport './access/IHooks.sol';\nimport './IHooksFactory.sol';\nimport './types/TransientBytesArray.sol';\nimport './spherex/SphereXProtectedRegisteredBase.sol';\n\nstruct TmpMarketParameterStorage {\n  address borrower;\n  address asset;\n  address feeRecipient;\n  uint16 protocolFeeBips;\n  uint128 maxTotalSupply;\n  uint16 annualInterestBips;\n  uint16 delinquencyFeeBips;\n  uint32 withdrawalBatchDuration;\n  uint16 reserveRatioBips;\n  uint32 delinquencyGracePeriod;\n  bytes32 packedNameWord0;\n  bytes32 packedNameWord1;\n  bytes32 packedSymbolWord0;\n  bytes32 packedSymbolWord1;\n  uint8 decimals;\n  HooksConfig hooks;\n}\n\ncontract HooksFactory is SphereXProtectedRegisteredBase, ReentrancyGuard, IHooksFactory {\n  using LibERC20 for address;\n\n  TransientBytesArray internal constant _tmpMarketParameters =\n    TransientBytesArray.wrap(uint256(keccak256('Transient:TmpMarketParametersStorage')) - 1);\n\n  uint256 internal immutable ownCreate2Prefix = LibStoredInitCode.getCreate2Prefix(address(this));\n\n  address public immutable override marketInitCodeStorage;\n\n  uint256 public immutable override marketInitCodeHash;\n\n  address public immutable override sanctionsSentinel;\n\n  /**\n   * @dev Return the contract name \"WildcatHooksFactory\"\n   */\n  function name() external pure override returns (string memory) {\n    // Use yul to avoid duplicate memory allocation and reduce code size\n    // Uses words at 0x20, 0x40, 0x60\n    // 0x20 is overwritten with the ABI offset (32)\n    // 0x40 contains the free pointer which will be 1 byte when this function executes.\n    // The length of the string (19) is written to the last byte of the free pointer word.\n    // 0x60 is the zero slot, so it will not have any dirty bits when this function executes.\n    // It is overwritten with the name bytes in the same operation as the length.\n    assembly {\n      mstore(0x53, 0x1357696c64636174486f6f6b73466163746f7279)\n      mstore(0x20, 0x20)\n      return(0x20, 0x60)\n    }\n  }\n\n  address[] internal _hooksTemplates;\n\n  /// @dev Mapping from borrower to their deployed hooks instances\n  mapping(address borrower => address[] hooksInstances) internal _hooksInstancesByBorrower;\n\n  /**\n   * @dev Mapping from hooks template to markets created with it.\n   *      Used for pushing protocol fee changes to affected markets.\n   */\n  mapping(address hooksTemplate => address[] markets) internal _marketsByHooksTemplate;\n\n  /**\n   * @dev Mapping from hooks instance to markets deployed using it.\n   *      Intended primarily for off-chain queries.\n   */\n  mapping(address hooksInstance => address[] markets) internal _marketsByHooksInstance;\n\n  /**\n   * @dev Mapping from hooks template to its fee configuration and name\n   */\n  mapping(address hooksTemplate => HooksTemplate details) internal _templateDetails;\n\n  mapping(address hooksInstance => address hooksTemplate)\n    public\n    override getHooksTemplateForInstance;\n\n  constructor(\n    address archController_,\n    address _sanctionsSentinel,\n    address _marketInitCodeStorage,\n    uint256 _marketInitCodeHash\n  ) {\n    marketInitCodeStorage = _marketInitCodeStorage;\n    marketInitCodeHash = _marketInitCodeHash;\n    _archController = archController_;\n    sanctionsSentinel = _sanctionsSentinel;\n    __SphereXProtectedRegisteredBase_init(IWildcatArchController(archController_).sphereXEngine());\n  }\n\n  /**\n   * @dev Registers the factory as a controller with the arch-controller, allowing\n   *      it to register new markets.\n   *      Needs to be executed once at deployment.\n   *      Does not need checks for whether it has already been registered as the\n   *      arch-controller will revert if it is already registered.\n   */\n  function registerWithArchController() external override {\n    IWildcatArchController(_archController).registerController(address(this));\n  }\n\n  function archController() external view override returns (address) {\n    return _archController;\n  }\n\n  // ========================================================================== //\n  //                          Internal Storage Helpers                          //\n  // ========================================================================== //\n\n  /**\n   * @dev Get the temporary market parameters from transient storage.\n   */\n  function _getTmpMarketParameters()\n    internal\n    view\n    returns (TmpMarketParameterStorage memory parameters)\n  {\n    return abi.decode(_tmpMarketParameters.read(), (TmpMarketParameterStorage));\n  }\n\n  /**\n   * @dev Set the temporary market parameters in transient storage.\n   */\n  function _setTmpMarketParameters(TmpMarketParameterStorage memory parameters) internal {\n    _tmpMarketParameters.write(abi.encode(parameters));\n  }\n\n  // ========================================================================== //\n  //                                  Modifiers                                 //\n  // ========================================================================== //\n\n  modifier onlyArchControllerOwner() {\n    if (msg.sender != IWildcatArchController(_archController).owner()) {\n      revert CallerNotArchControllerOwner();\n    }\n    _;\n  }\n\n  // ========================================================================== //\n  //                               Hooks Templates                              //\n  // ========================================================================== //\n\n  function addHooksTemplate(\n    address hooksTemplate,\n    string calldata name,\n    address feeRecipient,\n    address originationFeeAsset,\n    uint80 originationFeeAmount,\n    uint16 protocolFeeBips\n  ) external override onlyArchControllerOwner {\n    if (_templateDetails[hooksTemplate].exists) {\n      revert HooksTemplateAlreadyExists();\n    }\n    _validateFees(feeRecipient, originationFeeAsset, originationFeeAmount, protocolFeeBips);\n    _templateDetails[hooksTemplate] = HooksTemplate({\n      exists: true,\n      name: name,\n      feeRecipient: feeRecipient,\n      originationFeeAsset: originationFeeAsset,\n      originationFeeAmount: originationFeeAmount,\n      protocolFeeBips: protocolFeeBips,\n      enabled: true,\n      index: uint24(_hooksTemplates.length)\n    });\n    _hooksTemplates.push(hooksTemplate);\n    emit HooksTemplateAdded(\n      hooksTemplate,\n      name,\n      feeRecipient,\n      originationFeeAsset,\n      originationFeeAmount,\n      protocolFeeBips\n    );\n  }\n\n  function _validateFees(\n    address feeRecipient,\n    address originationFeeAsset,\n    uint80 originationFeeAmount,\n    uint16 protocolFeeBips\n  ) internal pure {\n    bool hasOriginationFee = originationFeeAmount > 0;\n    bool nullFeeRecipient = feeRecipient == address(0);\n    bool nullOriginationFeeAsset = originationFeeAsset == address(0);\n    if (\n      (protocolFeeBips > 0 && nullFeeRecipient) ||\n      (hasOriginationFee && nullFeeRecipient) ||\n      (hasOriginationFee && nullOriginationFeeAsset) ||\n      protocolFeeBips > 1_000\n    ) {\n      revert InvalidFeeConfiguration();\n    }\n  }\n\n  /// @dev Update the fees for a hooks template\n  /// Note: The new fee structure will apply to all NEW markets created with existing\n  ///       or future instances of the hooks template, and the protocol fee can be pushed\n  ///       to existing markets using `pushProtocolFeeBipsUpdates`.\n  function updateHooksTemplateFees(\n    address hooksTemplate,\n    address feeRecipient,\n    address originationFeeAsset,\n    uint80 originationFeeAmount,\n    uint16 protocolFeeBips\n  ) external override onlyArchControllerOwner {\n    if (!_templateDetails[hooksTemplate].exists) {\n      revert HooksTemplateNotFound();\n    }\n    _validateFees(feeRecipient, originationFeeAsset, originationFeeAmount, protocolFeeBips);\n    HooksTemplate storage template = _templateDetails[hooksTemplate];\n    template.feeRecipient = feeRecipient;\n    template.originationFeeAsset = originationFeeAsset;\n    template.originationFeeAmount = originationFeeAmount;\n    template.protocolFeeBips = protocolFeeBips;\n    emit HooksTemplateFeesUpdated(\n      hooksTemplate,\n      feeRecipient,\n      originationFeeAsset,\n      originationFeeAmount,\n      protocolFeeBips\n    );\n  }\n\n  function disableHooksTemplate(address hooksTemplate) external override onlyArchControllerOwner {\n    if (!_templateDetails[hooksTemplate].exists) {\n      revert HooksTemplateNotFound();\n    }\n    _templateDetails[hooksTemplate].enabled = false;\n    // Emit an event to indicate that the template has been removed\n    emit HooksTemplateDisabled(hooksTemplate);\n  }\n\n  function getHooksTemplateDetails(\n    address hooksTemplate\n  ) external view override returns (HooksTemplate memory) {\n    return _templateDetails[hooksTemplate];\n  }\n\n  function isHooksTemplate(address hooksTemplate) external view override returns (bool) {\n    return _templateDetails[hooksTemplate].exists;\n  }\n\n  function getHooksTemplates() external view override returns (address[] memory) {\n    return _hooksTemplates;\n  }\n\n  function getHooksTemplates(\n    uint256 start,\n    uint256 end\n  ) external view override returns (address[] memory arr) {\n    uint256 len = _hooksTemplates.length;\n    end = MathUtils.min(end, len);\n    uint256 count = end - start;\n    arr = new address[](count);\n    for (uint256 i = 0; i < count; i++) {\n      arr[i] = _hooksTemplates[start + i];\n    }\n  }\n\n  function getHooksTemplatesCount() external view override returns (uint256) {\n    return _hooksTemplates.length;\n  }\n\n  function getMarketsForHooksTemplate(\n    address hooksTemplate\n  ) external view override returns (address[] memory) {\n    return _marketsByHooksTemplate[hooksTemplate];\n  }\n\n  function getMarketsForHooksTemplate(\n    address hooksTemplate,\n    uint256 start,\n    uint256 end\n  ) external view override returns (address[] memory arr) {\n    address[] storage markets = _marketsByHooksTemplate[hooksTemplate];\n    uint256 len = markets.length;\n    end = MathUtils.min(end, len);\n    uint256 count = end - start;\n    arr = new address[](count);\n    for (uint256 i = 0; i < count; i++) {\n      arr[i] = markets[start + i];\n    }\n  }\n\n  function getMarketsForHooksTemplateCount(\n    address hooksTemplate\n  ) external view override returns (uint256) {\n    return _marketsByHooksTemplate[hooksTemplate].length;\n  }\n\n  // ========================================================================== //\n  //                               Hooks Instances                              //\n  // ========================================================================== //\n\n  /// @dev Deploy a hooks instance for an approved template with constructor args.\n  ///      Callable by approved borrowers on the arch-controller.\n  ///      May require payment of origination fees.\n  function deployHooksInstance(\n    address hooksTemplate,\n    bytes calldata constructorArgs\n  ) external override nonReentrant returns (address hooksInstance) {\n    if (!IWildcatArchController(_archController).isRegisteredBorrower(msg.sender)) {\n      revert NotApprovedBorrower();\n    }\n    hooksInstance = _deployHooksInstance(hooksTemplate, constructorArgs);\n  }\n\n  function getHooksInstancesForBorrower(\n    address borrower\n  ) external view override returns (address[] memory) {\n    return _hooksInstancesByBorrower[borrower];\n  }\n\n  function getHooksInstancesCountForBorrower(\n    address borrower\n  ) external view override returns (uint256) {\n    return _hooksInstancesByBorrower[borrower].length;\n  }\n\n  function isHooksInstance(address hooksInstance) external view override returns (bool) {\n    return getHooksTemplateForInstance[hooksInstance] != address(0);\n  }\n\n  function _deployHooksInstance(\n    address hooksTemplate,\n    bytes calldata constructorArgs\n  ) internal returns (address hooksInstance) {\n    HooksTemplate storage template = _templateDetails[hooksTemplate];\n    if (!template.exists) {\n      revert HooksTemplateNotFound();\n    }\n    if (!template.enabled) {\n      revert HooksTemplateNotAvailable();\n    }\n\n    uint256 numHooksForBorrower = _hooksInstancesByBorrower[msg.sender].length;\n    bytes32 salt;\n    assembly {\n      salt := or(shl(96, caller()), numHooksForBorrower)\n      let initCodePointer := mload(0x40)\n      let initCodeSize := sub(extcodesize(hooksTemplate), 1)\n      // Copy code from target address to memory starting at byte 1\n      extcodecopy(hooksTemplate, initCodePointer, 1, initCodeSize)\n      let endInitCodePointer := add(initCodePointer, initCodeSize)\n      // Write the address of the caller as the first parameter\n      mstore(endInitCodePointer, caller())\n      // Write the offset to the encoded constructor args\n      mstore(add(endInitCodePointer, 0x20), 0x40)\n      // Write the length of the encoded constructor args\n      let constructorArgsSize := constructorArgs.length\n      mstore(add(endInitCodePointer, 0x40), constructorArgsSize)\n      // Copy constructor args to initcode after the bytes length\n      calldatacopy(add(endInitCodePointer, 0x60), constructorArgs.offset, constructorArgsSize)\n      // Get the full size of the initcode with the constructor args\n      let initCodeSizeWithArgs := add(add(initCodeSize, 0x60), constructorArgsSize)\n      // Deploy the contract with the initcode\n      hooksInstance := create2(0, initCodePointer, initCodeSizeWithArgs, salt)\n      if iszero(hooksInstance) {\n        mstore(0x00, 0x30116425) // DeploymentFailed()\n        revert(0x1c, 0x04)\n      }\n    }\n    _hooksInstancesByBorrower[msg.sender].push(hooksInstance);\n\n    emit HooksInstanceDeployed(hooksInstance, hooksTemplate);\n    getHooksTemplateForInstance[hooksInstance] = hooksTemplate;\n  }\n\n  // ========================================================================== //\n  //                                   Markets                                  //\n  // ========================================================================== //\n\n  function getMarketsForHooksInstance(\n    address hooksInstance\n  ) external view override returns (address[] memory) {\n    return _marketsByHooksInstance[hooksInstance];\n  }\n\n  function getMarketsForHooksInstance(\n    address hooksInstance,\n    uint256 start,\n    uint256 end\n  ) external view override returns (address[] memory arr) {\n    address[] storage markets = _marketsByHooksInstance[hooksInstance];\n    end = MathUtils.min(end, markets.length);\n    uint256 count = end - start;\n    arr = new address[](count);\n    for (uint256 i = 0; i < count; i++) {\n      arr[i] = markets[start + i];\n    }\n  }\n\n  function getMarketsForHooksInstanceCount(\n    address hooksInstance\n  ) external view override returns (uint256) {\n    return _marketsByHooksInstance[hooksInstance].length;\n  }\n\n  /**\n   * @dev Get the temporarily stored market parameters for a market that is\n   *      currently being deployed.\n   */\n  function getMarketParameters()\n    external\n    view\n    override\n    returns (MarketParameters memory parameters)\n  {\n    TmpMarketParameterStorage memory tmp = _getTmpMarketParameters();\n\n    parameters.asset = tmp.asset;\n    parameters.packedNameWord0 = tmp.packedNameWord0;\n    parameters.packedNameWord1 = tmp.packedNameWord1;\n    parameters.packedSymbolWord0 = tmp.packedSymbolWord0;\n    parameters.packedSymbolWord1 = tmp.packedSymbolWord1;\n    parameters.decimals = tmp.decimals;\n    parameters.borrower = tmp.borrower;\n    parameters.feeRecipient = tmp.feeRecipient;\n    parameters.sentinel = sanctionsSentinel;\n    parameters.maxTotalSupply = tmp.maxTotalSupply;\n    parameters.protocolFeeBips = tmp.protocolFeeBips;\n    parameters.annualInterestBips = tmp.annualInterestBips;\n    parameters.delinquencyFeeBips = tmp.delinquencyFeeBips;\n    parameters.withdrawalBatchDuration = tmp.withdrawalBatchDuration;\n    parameters.reserveRatioBips = tmp.reserveRatioBips;\n    parameters.delinquencyGracePeriod = tmp.delinquencyGracePeriod;\n    parameters.archController = _archController;\n    parameters.sphereXEngine = sphereXEngine();\n    parameters.hooks = tmp.hooks;\n  }\n\n  function computeMarketAddress(bytes32 salt) external view override returns (address) {\n    return LibStoredInitCode.calculateCreate2Address(ownCreate2Prefix, salt, marketInitCodeHash);\n  }\n\n  /**\n   * @dev Given a string of at most 63 bytes, produces a packed version with two words,\n   *      where the first word contains the length byte and the first 31 bytes of the string,\n   *      and the second word contains the second 32 bytes of the string.\n   */\n  function _packString(string memory str) internal pure returns (bytes32 word0, bytes32 word1) {\n    assembly {\n      let length := mload(str)\n      // Equivalent to:\n      // if (str.length > 63) revert NameOrSymbolTooLong();\n      if gt(length, 0x3f) {\n        mstore(0, 0x19a65cb6)\n        revert(0x1c, 0x04)\n      }\n      // Load the length and first 31 bytes of the string into the first word\n      // by reading from 31 bytes after the length pointer.\n      word0 := mload(add(str, 0x1f))\n      // If the string is less than 32 bytes, the second word will be zeroed out.\n      word1 := mul(mload(add(str, 0x3f)), gt(mload(str), 0x1f))\n    }\n  }\n\n  function _deployMarket(\n    DeployMarketInputs memory parameters,\n    bytes memory hooksData,\n    address hooksTemplate,\n    HooksTemplate memory templateDetails,\n    bytes32 salt,\n    address originationFeeAsset,\n    uint256 originationFeeAmount\n  ) internal returns (address market) {\n    if (IWildcatArchController(_archController).isBlacklistedAsset(parameters.asset)) {\n      revert AssetBlacklisted();\n    }\n    address hooksInstance = parameters.hooks.hooksAddress();\n\n    if (!(address(bytes20(salt)) == msg.sender || bytes20(salt) == bytes20(0))) {\n      revert SaltDoesNotContainSender();\n    }\n\n    if (\n      originationFeeAsset != templateDetails.originationFeeAsset ||\n      originationFeeAmount != templateDetails.originationFeeAmount\n    ) {\n      revert FeeMismatch();\n    }\n\n    if (originationFeeAsset != address(0)) {\n      originationFeeAsset.safeTransferFrom(\n        msg.sender,\n        templateDetails.feeRecipient,\n        originationFeeAmount\n      );\n    }\n\n    market = LibStoredInitCode.calculateCreate2Address(ownCreate2Prefix, salt, marketInitCodeHash);\n\n    parameters.hooks = IHooks(hooksInstance).onCreateMarket(\n      msg.sender,\n      market,\n      parameters,\n      hooksData\n    );\n    uint8 decimals = parameters.asset.decimals();\n\n    string memory name = string.concat(parameters.namePrefix, parameters.asset.name());\n    string memory symbol = string.concat(parameters.symbolPrefix, parameters.asset.symbol());\n\n    TmpMarketParameterStorage memory tmp = TmpMarketParameterStorage({\n      borrower: msg.sender,\n      asset: parameters.asset,\n      packedNameWord0: bytes32(0),\n      packedNameWord1: bytes32(0),\n      packedSymbolWord0: bytes32(0),\n      packedSymbolWord1: bytes32(0),\n      decimals: decimals,\n      feeRecipient: templateDetails.feeRecipient,\n      protocolFeeBips: templateDetails.protocolFeeBips,\n      maxTotalSupply: parameters.maxTotalSupply,\n      annualInterestBips: parameters.annualInterestBips,\n      delinquencyFeeBips: parameters.delinquencyFeeBips,\n      withdrawalBatchDuration: parameters.withdrawalBatchDuration,\n      reserveRatioBips: parameters.reserveRatioBips,\n      delinquencyGracePeriod: parameters.delinquencyGracePeriod,\n      hooks: parameters.hooks\n    });\n    {\n      (tmp.packedNameWord0, tmp.packedNameWord1) = _packString(name);\n      (tmp.packedSymbolWord0, tmp.packedSymbolWord1) = _packString(symbol);\n    }\n\n    _setTmpMarketParameters(tmp);\n\n    if (market.code.length != 0) {\n      revert MarketAlreadyExists();\n    }\n    LibStoredInitCode.create2WithStoredInitCode(marketInitCodeStorage, salt);\n\n    IWildcatArchController(_archController).registerMarket(market);\n\n    _tmpMarketParameters.setEmpty();\n\n    _marketsByHooksTemplate[hooksTemplate].push(market);\n    _marketsByHooksInstance[hooksInstance].push(market);\n\n    emit MarketDeployed(\n      hooksTemplate,\n      market,\n      name,\n      symbol,\n      tmp.asset,\n      tmp.maxTotalSupply,\n      tmp.annualInterestBips,\n      tmp.delinquencyFeeBips,\n      tmp.withdrawalBatchDuration,\n      tmp.reserveRatioBips,\n      tmp.delinquencyGracePeriod,\n      tmp.hooks\n    );\n  }\n\n  function deployMarket(\n    DeployMarketInputs calldata parameters,\n    bytes calldata hooksData,\n    bytes32 salt,\n    address originationFeeAsset,\n    uint256 originationFeeAmount\n  ) external override nonReentrant returns (address market) {\n    if (!IWildcatArchController(_archController).isRegisteredBorrower(msg.sender)) {\n      revert NotApprovedBorrower();\n    }\n    address hooksInstance = parameters.hooks.hooksAddress();\n    address hooksTemplate = getHooksTemplateForInstance[hooksInstance];\n    if (hooksTemplate == address(0)) {\n      revert HooksInstanceNotFound();\n    }\n    HooksTemplate memory templateDetails = _templateDetails[hooksTemplate];\n    market = _deployMarket(\n      parameters,\n      hooksData,\n      hooksTemplate,\n      templateDetails,\n      salt,\n      originationFeeAsset,\n      originationFeeAmount\n    );\n  }\n\n  function deployMarketAndHooks(\n    address hooksTemplate,\n    bytes calldata hooksTemplateArgs,\n    DeployMarketInputs memory parameters,\n    bytes calldata hooksData,\n    bytes32 salt,\n    address originationFeeAsset,\n    uint256 originationFeeAmount\n  ) external override nonReentrant returns (address market, address hooksInstance) {\n    if (!IWildcatArchController(_archController).isRegisteredBorrower(msg.sender)) {\n      revert NotApprovedBorrower();\n    }\n    HooksTemplate memory templateDetails = _templateDetails[hooksTemplate];\n    if (!templateDetails.exists) {\n      revert HooksTemplateNotFound();\n    }\n    hooksInstance = _deployHooksInstance(hooksTemplate, hooksTemplateArgs);\n    parameters.hooks = parameters.hooks.setHooksAddress(hooksInstance);\n    market = _deployMarket(\n      parameters,\n      hooksData,\n      hooksTemplate,\n      templateDetails,\n      salt,\n      originationFeeAsset,\n      originationFeeAmount\n    );\n  }\n\n  /**\n   * @dev Push any changes to the fee configuration of `hooksTemplate` to markets\n   *      using any instances of that template at `_marketsByHooksTemplate[hooksTemplate]`.\n   *      Starts at `marketStartIndex` and ends one before `marketEndIndex`  or markets.length,\n   *      whichever is lowest.\n   */\n  function pushProtocolFeeBipsUpdates(\n    address hooksTemplate,\n    uint marketStartIndex,\n    uint marketEndIndex\n  ) public override nonReentrant {\n    HooksTemplate memory details = _templateDetails[hooksTemplate];\n    if (!details.exists) revert HooksTemplateNotFound();\n\n    address[] storage markets = _marketsByHooksTemplate[hooksTemplate];\n    marketEndIndex = MathUtils.min(marketEndIndex, markets.length);\n    uint256 count = marketEndIndex - marketStartIndex;\n    uint256 setProtocolFeeBipsCalldataPointer;\n    uint16 protocolFeeBips = details.protocolFeeBips;\n    assembly {\n      // Write the calldata for `market.setProtocolFeeBips(protocolFeeBips)`\n      // this will be reused for every market\n      setProtocolFeeBipsCalldataPointer := mload(0x40)\n      mstore(0x40, add(setProtocolFeeBipsCalldataPointer, 0x40))\n      // Write selector for `setProtocolFeeBips(uint16)`\n      mstore(setProtocolFeeBipsCalldataPointer, 0xae6ea191)\n      mstore(add(setProtocolFeeBipsCalldataPointer, 0x20), protocolFeeBips)\n      // Add 28 bytes to get the exact pointer to the first byte of the selector\n      setProtocolFeeBipsCalldataPointer := add(setProtocolFeeBipsCalldataPointer, 0x1c)\n    }\n    for (uint256 i = 0; i < count; i++) {\n      address market = markets[marketStartIndex + i];\n      assembly {\n        if iszero(call(gas(), market, 0, setProtocolFeeBipsCalldataPointer, 0x24, 0, 0)) {\n          // Equivalent to `revert SetProtocolFeeBipsFailed()`\n          mstore(0, 0x4484a4a9)\n          revert(0x1c, 0x04)\n        }\n      }\n    }\n  }\n\n  /**\n   * @dev Push any changes to the fee configuration of `hooksTemplate` to all markets\n   *      using any instances of that template at `_marketsByHooksTemplate[hooksTemplate]`.\n   */\n  function pushProtocolFeeBipsUpdates(address hooksTemplate) external override {\n    pushProtocolFeeBipsUpdates(hooksTemplate, 0, type(uint256).max);\n  }\n}\n"},"src/lens/RoleProviderData.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.20;\n\nimport '../types/RoleProvider.sol';\n\nusing RoleProviderDataLib for RoleProviderData global;\n\nstruct RoleProviderData {\n  uint32 timeToLive;\n  address providerAddress;\n  uint24 pullProviderIndex;\n  uint24 pushProviderIndex;\n}\n\nlibrary RoleProviderDataLib {\n  function fill(RoleProviderData memory data, RoleProvider provider) internal pure {\n    (\n      data.timeToLive,\n      data.providerAddress,\n      data.pullProviderIndex,\n      data.pushProviderIndex\n    ) = provider.decodeRoleProvider();\n  }\n\n  function toRoleProviderDatas(\n    RoleProvider[] memory providers\n  ) internal pure returns (RoleProviderData[] memory data) {\n    data = new RoleProviderData[](providers.length);\n    for (uint256 i; i < providers.length; i++) {\n      data[i].fill(providers[i]);\n    }\n  }\n}\n"},"lib/openzeppelin-contracts/contracts/utils/structs/EnumerableSet.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastValue;\n                // Update the index for the moved value\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"},"lib/solady/src/auth/Ownable.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Simple single owner authorization mixin.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/auth/Ownable.sol)\n///\n/// @dev Note:\n/// This implementation does NOT auto-initialize the owner to `msg.sender`.\n/// You MUST call the `_initializeOwner` in the constructor / initializer.\n///\n/// While the ownable portion follows\n/// [EIP-173](https://eips.ethereum.org/EIPS/eip-173) for compatibility,\n/// the nomenclature for the 2-step ownership handover may be unique to this codebase.\nabstract contract Ownable {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                       CUSTOM ERRORS                        */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The caller is not authorized to call the function.\n    error Unauthorized();\n\n    /// @dev The `newOwner` cannot be the zero address.\n    error NewOwnerIsZeroAddress();\n\n    /// @dev The `pendingOwner` does not have a valid handover request.\n    error NoHandoverRequest();\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                           EVENTS                           */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The ownership is transferred from `oldOwner` to `newOwner`.\n    /// This event is intentionally kept the same as OpenZeppelin's Ownable to be\n    /// compatible with indexers and [EIP-173](https://eips.ethereum.org/EIPS/eip-173),\n    /// despite it not being as lightweight as a single argument event.\n    event OwnershipTransferred(address indexed oldOwner, address indexed newOwner);\n\n    /// @dev An ownership handover to `pendingOwner` has been requested.\n    event OwnershipHandoverRequested(address indexed pendingOwner);\n\n    /// @dev The ownership handover to `pendingOwner` has been canceled.\n    event OwnershipHandoverCanceled(address indexed pendingOwner);\n\n    /// @dev `keccak256(bytes(\"OwnershipTransferred(address,address)\"))`.\n    uint256 private constant _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE =\n        0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0;\n\n    /// @dev `keccak256(bytes(\"OwnershipHandoverRequested(address)\"))`.\n    uint256 private constant _OWNERSHIP_HANDOVER_REQUESTED_EVENT_SIGNATURE =\n        0xdbf36a107da19e49527a7176a1babf963b4b0ff8cde35ee35d6cd8f1f9ac7e1d;\n\n    /// @dev `keccak256(bytes(\"OwnershipHandoverCanceled(address)\"))`.\n    uint256 private constant _OWNERSHIP_HANDOVER_CANCELED_EVENT_SIGNATURE =\n        0xfa7b8eab7da67f412cc9575ed43464468f9bfbae89d1675917346ca6d8fe3c92;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                          STORAGE                           */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The owner slot is given by: `not(_OWNER_SLOT_NOT)`.\n    /// It is intentionally chosen to be a high value\n    /// to avoid collision with lower slots.\n    /// The choice of manual storage layout is to enable compatibility\n    /// with both regular and upgradeable contracts.\n    uint256 private constant _OWNER_SLOT_NOT = 0x8b78c6d8;\n\n    /// The ownership handover slot of `newOwner` is given by:\n    /// ```\n    ///     mstore(0x00, or(shl(96, user), _HANDOVER_SLOT_SEED))\n    ///     let handoverSlot := keccak256(0x00, 0x20)\n    /// ```\n    /// It stores the expiry timestamp of the two-step ownership handover.\n    uint256 private constant _HANDOVER_SLOT_SEED = 0x389a75e1;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                     INTERNAL FUNCTIONS                     */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Initializes the owner directly without authorization guard.\n    /// This function must be called upon initialization,\n    /// regardless of whether the contract is upgradeable or not.\n    /// This is to enable generalization to both regular and upgradeable contracts,\n    /// and to save gas in case the initial owner is not the caller.\n    /// For performance reasons, this function will not check if there\n    /// is an existing owner.\n    function _initializeOwner(address newOwner) internal virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Clean the upper 96 bits.\n            newOwner := shr(96, shl(96, newOwner))\n            // Store the new value.\n            sstore(not(_OWNER_SLOT_NOT), newOwner)\n            // Emit the {OwnershipTransferred} event.\n            log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, 0, newOwner)\n        }\n    }\n\n    /// @dev Sets the owner directly without authorization guard.\n    function _setOwner(address newOwner) internal virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ownerSlot := not(_OWNER_SLOT_NOT)\n            // Clean the upper 96 bits.\n            newOwner := shr(96, shl(96, newOwner))\n            // Emit the {OwnershipTransferred} event.\n            log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, sload(ownerSlot), newOwner)\n            // Store the new value.\n            sstore(ownerSlot, newOwner)\n        }\n    }\n\n    /// @dev Throws if the sender is not the owner.\n    function _checkOwner() internal view virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // If the caller is not the stored owner, revert.\n            if iszero(eq(caller(), sload(not(_OWNER_SLOT_NOT)))) {\n                mstore(0x00, 0x82b42900) // `Unauthorized()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    /// @dev Returns how long a two-step ownership handover is valid for in seconds.\n    /// Override to return a different value if needed.\n    /// Made internal to conserve bytecode. Wrap it in a public function if needed.\n    function _ownershipHandoverValidFor() internal view virtual returns (uint64) {\n        return 48 * 3600;\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                  PUBLIC UPDATE FUNCTIONS                   */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Allows the owner to transfer the ownership to `newOwner`.\n    function transferOwnership(address newOwner) public payable virtual onlyOwner {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(shl(96, newOwner)) {\n                mstore(0x00, 0x7448fbae) // `NewOwnerIsZeroAddress()`.\n                revert(0x1c, 0x04)\n            }\n        }\n        _setOwner(newOwner);\n    }\n\n    /// @dev Allows the owner to renounce their ownership.\n    function renounceOwnership() public payable virtual onlyOwner {\n        _setOwner(address(0));\n    }\n\n    /// @dev Request a two-step ownership handover to the caller.\n    /// The request will automatically expire in 48 hours (172800 seconds) by default.\n    function requestOwnershipHandover() public payable virtual {\n        unchecked {\n            uint256 expires = block.timestamp + _ownershipHandoverValidFor();\n            /// @solidity memory-safe-assembly\n            assembly {\n                // Compute and set the handover slot to `expires`.\n                mstore(0x0c, _HANDOVER_SLOT_SEED)\n                mstore(0x00, caller())\n                sstore(keccak256(0x0c, 0x20), expires)\n                // Emit the {OwnershipHandoverRequested} event.\n                log2(0, 0, _OWNERSHIP_HANDOVER_REQUESTED_EVENT_SIGNATURE, caller())\n            }\n        }\n    }\n\n    /// @dev Cancels the two-step ownership handover to the caller, if any.\n    function cancelOwnershipHandover() public payable virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute and set the handover slot to 0.\n            mstore(0x0c, _HANDOVER_SLOT_SEED)\n            mstore(0x00, caller())\n            sstore(keccak256(0x0c, 0x20), 0)\n            // Emit the {OwnershipHandoverCanceled} event.\n            log2(0, 0, _OWNERSHIP_HANDOVER_CANCELED_EVENT_SIGNATURE, caller())\n        }\n    }\n\n    /// @dev Allows the owner to complete the two-step ownership handover to `pendingOwner`.\n    /// Reverts if there is no existing ownership handover requested by `pendingOwner`.\n    function completeOwnershipHandover(address pendingOwner) public payable virtual onlyOwner {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute and set the handover slot to 0.\n            mstore(0x0c, _HANDOVER_SLOT_SEED)\n            mstore(0x00, pendingOwner)\n            let handoverSlot := keccak256(0x0c, 0x20)\n            // If the handover does not exist, or has expired.\n            if gt(timestamp(), sload(handoverSlot)) {\n                mstore(0x00, 0x6f5e8818) // `NoHandoverRequest()`.\n                revert(0x1c, 0x04)\n            }\n            // Set the handover slot to 0.\n            sstore(handoverSlot, 0)\n        }\n        _setOwner(pendingOwner);\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                   PUBLIC READ FUNCTIONS                    */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns the owner of the contract.\n    function owner() public view virtual returns (address result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := sload(not(_OWNER_SLOT_NOT))\n        }\n    }\n\n    /// @dev Returns the expiry timestamp for the two-step ownership handover to `pendingOwner`.\n    function ownershipHandoverExpiresAt(address pendingOwner)\n        public\n        view\n        virtual\n        returns (uint256 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute the handover slot.\n            mstore(0x0c, _HANDOVER_SLOT_SEED)\n            mstore(0x00, pendingOwner)\n            // Load the handover slot.\n            result := sload(keccak256(0x0c, 0x20))\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                         MODIFIERS                          */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Marks a function as only callable by the owner.\n    modifier onlyOwner() virtual {\n        _checkOwner();\n        _;\n    }\n}\n"},"src/spherex/SphereXConfig.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\n// (c) SphereX 2023 Terms&Conditions\npragma solidity ^0.8.20;\n\nimport { ISphereXEngine, ModifierLocals } from './ISphereXEngine.sol';\nimport './SphereXProtectedEvents.sol';\nimport './SphereXProtectedErrors.sol';\n\nabstract contract SphereXConfig {\n  // ========================================================================== //\n  //                                Storage Slots                               //\n  // ========================================================================== //\n\n  bytes32 private constant SPHEREX_ADMIN_STORAGE_SLOT =\n    bytes32(uint256(keccak256('eip1967.spherex.spherex')) - 1);\n  bytes32 private constant SPHEREX_PENDING_ADMIN_STORAGE_SLOT =\n    bytes32(uint256(keccak256('eip1967.spherex.pending')) - 1);\n  bytes32 private constant SPHEREX_OPERATOR_STORAGE_SLOT =\n    bytes32(uint256(keccak256('eip1967.spherex.operator')) - 1);\n  bytes32 private constant SPHEREX_ENGINE_STORAGE_SLOT =\n    bytes32(uint256(keccak256('eip1967.spherex.spherex_engine')) - 1);\n\n  // ========================================================================== //\n  //                                 Constructor                                //\n  // ========================================================================== //\n\n  constructor(address admin, address operator, address engine) {\n    _setAddress(SPHEREX_ADMIN_STORAGE_SLOT, admin);\n    emit_SpherexAdminTransferCompleted(address(0), admin);\n\n    _setAddress(SPHEREX_OPERATOR_STORAGE_SLOT, operator);\n    emit_ChangedSpherexOperator(address(0), operator);\n\n    _setSphereXEngine(engine);\n    emit_ChangedSpherexEngineAddress(address(0), engine);\n  }\n\n  // ========================================================================== //\n  //                              Events and Errors                             //\n  // ========================================================================== //\n\n  event ChangedSpherexOperator(address oldSphereXAdmin, address newSphereXAdmin);\n  event ChangedSpherexEngineAddress(address oldEngineAddress, address newEngineAddress);\n  event SpherexAdminTransferStarted(address currentAdmin, address pendingAdmin);\n  event SpherexAdminTransferCompleted(address oldAdmin, address newAdmin);\n  event NewAllowedSenderOnchain(address sender);\n\n  error SphereXOperatorRequired();\n  error SphereXAdminRequired();\n  error SphereXOperatorOrAdminRequired();\n  error SphereXNotPendingAdmin();\n  error SphereXNotEngine();\n\n  // ========================================================================== //\n  //                                  Modifiers                                 //\n  // ========================================================================== //\n\n  modifier onlySphereXAdmin() {\n    if (msg.sender != sphereXAdmin()) {\n      revert_SphereXAdminRequired();\n    }\n    _;\n  }\n\n  modifier spherexOnlyOperator() {\n    if (msg.sender != sphereXOperator()) {\n      revert_SphereXOperatorRequired();\n    }\n    _;\n  }\n\n  modifier spherexOnlyOperatorOrAdmin() {\n    if (msg.sender != sphereXOperator() && msg.sender != sphereXAdmin()) {\n      revert_SphereXOperatorOrAdminRequired();\n    }\n    _;\n  }\n\n  // ========================================================================== //\n  //                               Config Getters                               //\n  // ========================================================================== //\n\n  /**\n   * @dev Returns the current pending admin address, which is able to call\n   *      acceptSphereXAdminRole to become the admin.\n   */\n  function pendingSphereXAdmin() public view returns (address) {\n    return _getAddress(SPHEREX_PENDING_ADMIN_STORAGE_SLOT);\n  }\n\n  /// @dev Returns the current admin address, which is able to change the operator.\n  function sphereXAdmin() public view returns (address) {\n    return _getAddress(SPHEREX_ADMIN_STORAGE_SLOT);\n  }\n\n  /// @dev Returns the current operator address.\n  function sphereXOperator() public view returns (address) {\n    return _getAddress(SPHEREX_OPERATOR_STORAGE_SLOT);\n  }\n\n  /// @dev Returns the current engine address.\n  function sphereXEngine() public view returns (address) {\n    return _getAddress(SPHEREX_ENGINE_STORAGE_SLOT);\n  }\n\n  // ========================================================================== //\n  //                                 Management                                 //\n  // ========================================================================== //\n\n  /**\n   * @dev Set pending admin to `newAdmin`, allowing it to call \n   *      `acceptSphereXAdminRole()` to receive the admin role.\n   */\n  function transferSphereXAdminRole(address newAdmin) public virtual onlySphereXAdmin {\n    _setAddress(SPHEREX_PENDING_ADMIN_STORAGE_SLOT, newAdmin);\n    emit_SpherexAdminTransferStarted(sphereXAdmin(), newAdmin);\n  }\n\n  /// @dev Accepts a pending admin transfer.\n  function acceptSphereXAdminRole() public virtual {\n    if (msg.sender != pendingSphereXAdmin()) {\n      revert_SphereXNotPendingAdmin();\n    }\n    address oldAdmin = sphereXAdmin();\n    _setAddress(SPHEREX_ADMIN_STORAGE_SLOT, msg.sender);\n    _setAddress(SPHEREX_PENDING_ADMIN_STORAGE_SLOT, address(0));\n    emit_SpherexAdminTransferCompleted(oldAdmin, msg.sender);\n  }\n\n  /// @dev Changes the address of the SphereX operator.\n  function changeSphereXOperator(address newSphereXOperator) external onlySphereXAdmin {\n    address oldSphereXOperator = _getAddress(SPHEREX_OPERATOR_STORAGE_SLOT);\n    _setAddress(SPHEREX_OPERATOR_STORAGE_SLOT, newSphereXOperator);\n    emit_ChangedSpherexOperator(oldSphereXOperator, newSphereXOperator);\n  }\n\n  /**\n   * @dev  Changes the address of the SphereX engine.\n   *\n   *       This is also used to enable SphereX protection, which is disabled\n   *       when the engine address is 0.\n   */\n  function changeSphereXEngine(address newSphereXEngine) external spherexOnlyOperator {\n    address oldEngine = _getAddress(SPHEREX_ENGINE_STORAGE_SLOT);\n    _setSphereXEngine(newSphereXEngine);\n    emit_ChangedSpherexEngineAddress(oldEngine, newSphereXEngine);\n  }\n\n  /**\n   * @dev Checks the given address implements ISphereXEngine or is address(0)\n   * @param newSphereXEngine new address of the spherex engine\n   */\n  function _setSphereXEngine(address newSphereXEngine) internal {\n    if (\n      newSphereXEngine != address(0) &&\n      !ISphereXEngine(newSphereXEngine).supportsInterface(type(ISphereXEngine).interfaceId)\n    ) {\n      revert_SphereXNotEngine();\n    }\n    _setAddress(SPHEREX_ENGINE_STORAGE_SLOT, newSphereXEngine);\n  }\n\n  // ========================================================================== //\n  //                             Engine Interaction                             //\n  // ========================================================================== //\n\n  function _addAllowedSenderOnChain(address newSender) internal {\n    ISphereXEngine engine = ISphereXEngine(sphereXEngine());\n    if (address(engine) != address(0)) {\n      engine.addAllowedSenderOnChain(newSender);\n      emit_NewAllowedSenderOnchain(newSender);\n    }\n  }\n\n  // ========================================================================== //\n  //                          Internal Storage Helpers                          //\n  // ========================================================================== //\n\n  /// @dev Stores an address in an arbitrary slot\n  function _setAddress(bytes32 slot, address newAddress) internal {\n    assembly {\n      sstore(slot, newAddress)\n    }\n  }\n\n  /// @dev Returns an address from an arbitrary slot.\n  function _getAddress(bytes32 slot) internal view returns (address addr) {\n    assembly {\n      addr := sload(slot)\n    }\n  }\n}\n"},"src/libraries/MathUtils.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.20;\n\nimport './Errors.sol';\n\nuint256 constant BIP = 1e4;\nuint256 constant HALF_BIP = 0.5e4;\n\nuint256 constant RAY = 1e27;\nuint256 constant HALF_RAY = 0.5e27;\n\nuint256 constant BIP_RAY_RATIO = 1e23;\n\nuint256 constant SECONDS_IN_365_DAYS = 365 days;\n\nlibrary MathUtils {\n  /// @dev The multiply-divide operation failed, either due to a\n  /// multiplication overflow, or a division by a zero.\n  error MulDivFailed();\n\n  using MathUtils for uint256;\n\n  /**\n   * @dev Function to calculate the interest accumulated using a linear interest rate formula\n   *\n   * @param rateBip The interest rate, in bips\n   * @param timeDelta The time elapsed since the last interest accrual\n   * @return result The interest rate linearly accumulated during the timeDelta, in ray\n   */\n  function calculateLinearInterestFromBips(\n    uint256 rateBip,\n    uint256 timeDelta\n  ) internal pure returns (uint256 result) {\n    uint256 rate = rateBip.bipToRay();\n    uint256 accumulatedInterestRay = rate * timeDelta;\n    unchecked {\n      return accumulatedInterestRay / SECONDS_IN_365_DAYS;\n    }\n  }\n\n  /**\n   * @dev Return the smaller of `a` and `b`\n   */\n  function min(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    c = ternary(a < b, a, b);\n  }\n\n  /**\n   * @dev Return the larger of `a` and `b`.\n   */\n  function max(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    c = ternary(a < b, b, a);\n  }\n\n  /**\n   * @dev Saturation subtraction. Subtract `b` from `a` and return the result\n   *      if it is positive or zero if it underflows.\n   */\n  function satSub(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    assembly {\n      // (a > b) * (a - b)\n      // If a-b underflows, the product will be zero\n      c := mul(gt(a, b), sub(a, b))\n    }\n  }\n\n  /**\n   * @dev Saturation addition. Add `a` to `b` and return the result\n   *      if it is less than `maxValue` or `maxValue` if it overflows.\n   */\n  function satAdd(uint256 a, uint256 b, uint256 maxValue) internal pure returns (uint256 c) {\n    unchecked {\n      c = a + b;\n      return ternary(c < maxValue, c, maxValue);\n    }\n  }\n\n  /**\n   * @dev Return `valueIfTrue` if `condition` is true and `valueIfFalse` if it is false.\n   *      Equivalent to `condition ? valueIfTrue : valueIfFalse`\n   */\n  function ternary(\n    bool condition,\n    uint256 valueIfTrue,\n    uint256 valueIfFalse\n  ) internal pure returns (uint256 c) {\n    assembly {\n      c := add(valueIfFalse, mul(condition, sub(valueIfTrue, valueIfFalse)))\n    }\n  }\n\n  /**\n   * @dev Multiplies two bip, rounding half up to the nearest bip\n   *      see https://twitter.com/transmissions11/status/1451131036377571328\n   */\n  function bipMul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    assembly {\n      // equivalent to `require(b == 0 || a <= (type(uint256).max - HALF_BIP) / b)`\n      if iszero(or(iszero(b), iszero(gt(a, div(sub(not(0), HALF_BIP), b))))) {\n        // Store the Panic error signature.\n        mstore(0, Panic_ErrorSelector)\n        // Store the arithmetic (0x11) panic code.\n        mstore(Panic_ErrorCodePointer, Panic_Arithmetic)\n        // revert(abi.encodeWithSignature(\"Panic(uint256)\", 0x11))\n        revert(Error_SelectorPointer, Panic_ErrorLength)\n      }\n\n      c := div(add(mul(a, b), HALF_BIP), BIP)\n    }\n  }\n\n  /**\n   * @dev Divides two bip, rounding half up to the nearest bip\n   *      see https://twitter.com/transmissions11/status/1451131036377571328\n   */\n  function bipDiv(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    assembly {\n      // equivalent to `require(b != 0 && a <= (type(uint256).max - b/2) / BIP)`\n      if or(iszero(b), gt(a, div(sub(not(0), div(b, 2)), BIP))) {\n        mstore(0, Panic_ErrorSelector)\n        mstore(Panic_ErrorCodePointer, Panic_Arithmetic)\n        revert(Error_SelectorPointer, Panic_ErrorLength)\n      }\n\n      c := div(add(mul(a, BIP), div(b, 2)), b)\n    }\n  }\n\n  /**\n   * @dev Converts bip up to ray\n   */\n  function bipToRay(uint256 a) internal pure returns (uint256 b) {\n    // to avoid overflow, b/BIP_RAY_RATIO == a\n    assembly {\n      b := mul(a, BIP_RAY_RATIO)\n      // equivalent to `require((b = a * BIP_RAY_RATIO) / BIP_RAY_RATIO == a )\n      if iszero(eq(div(b, BIP_RAY_RATIO), a)) {\n        mstore(0, Panic_ErrorSelector)\n        mstore(Panic_ErrorCodePointer, Panic_Arithmetic)\n        revert(Error_SelectorPointer, Panic_ErrorLength)\n      }\n    }\n  }\n\n  /**\n   * @dev Multiplies two ray, rounding half up to the nearest ray\n   *      see https://twitter.com/transmissions11/status/1451131036377571328\n   */\n  function rayMul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    assembly {\n      // equivalent to `require(b == 0 || a <= (type(uint256).max - HALF_RAY) / b)`\n      if iszero(or(iszero(b), iszero(gt(a, div(sub(not(0), HALF_RAY), b))))) {\n        mstore(0, Panic_ErrorSelector)\n        mstore(Panic_ErrorCodePointer, Panic_Arithmetic)\n        revert(Error_SelectorPointer, Panic_ErrorLength)\n      }\n\n      c := div(add(mul(a, b), HALF_RAY), RAY)\n    }\n  }\n\n  /**\n   * @dev Divide two ray, rounding half up to the nearest ray\n   *      see https://twitter.com/transmissions11/status/1451131036377571328\n   */\n  function rayDiv(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    assembly {\n      // equivalent to `require(b != 0 && a <= (type(uint256).max - halfB) / RAY)`\n      if or(iszero(b), gt(a, div(sub(not(0), div(b, 2)), RAY))) {\n        mstore(0, Panic_ErrorSelector)\n        mstore(Panic_ErrorCodePointer, Panic_Arithmetic)\n        revert(Error_SelectorPointer, Panic_ErrorLength)\n      }\n\n      c := div(add(mul(a, RAY), div(b, 2)), b)\n    }\n  }\n\n  /**\n   * @dev Returns `floor(x * y / d)`.\n   *      Reverts if `x * y` overflows, or `d` is zero.\n   * @custom:author solady/src/utils/FixedPointMathLib.sol\n   */\n  function mulDiv(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\n    assembly {\n      // Equivalent to require(d != 0 && (y == 0 || x <= type(uint256).max / y))\n      if iszero(mul(d, iszero(mul(y, gt(x, div(not(0), y)))))) {\n        // Store the function selector of `MulDivFailed()`.\n        mstore(0x00, 0xad251c27)\n        // Revert with (offset, size).\n        revert(0x1c, 0x04)\n      }\n      z := div(mul(x, y), d)\n    }\n  }\n\n  /**\n   * @dev Returns `ceil(x * y / d)`.\n   *      Reverts if `x * y` overflows, or `d` is zero.\n   * @custom:author solady/src/utils/FixedPointMathLib.sol\n   */\n  function mulDivUp(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\n    assembly {\n      // Equivalent to require(d != 0 && (y == 0 || x <= type(uint256).max / y))\n      if iszero(mul(d, iszero(mul(y, gt(x, div(not(0), y)))))) {\n        // Store the function selector of `MulDivFailed()`.\n        mstore(0x00, 0xad251c27)\n        // Revert with (offset, size).\n        revert(0x1c, 0x04)\n      }\n      z := add(iszero(iszero(mod(mul(x, y), d))), div(mul(x, y), d))\n    }\n  }\n}\n"},"src/interfaces/ISphereXProtectedRegisteredBase.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.20;\n\ninterface ISphereXProtectedRegisteredBase {\n  error SphereXOperatorRequired();\n\n  event ChangedSpherexOperator(address oldSphereXAdmin, address newSphereXAdmin);\n\n  event ChangedSpherexEngineAddress(address oldEngineAddress, address newEngineAddress);\n\n  function sphereXOperator() external view returns (address);\n\n  function sphereXEngine() external view returns (address);\n\n  function changeSphereXEngine(address newSphereXEngine) external;\n}\n"},"src/market/WildcatMarketBase.sol":{"content":"// SPDX-License-Identifier: Apache-2.0 WITH LicenseRef-Commons-Clause-1.0\npragma solidity >=0.8.20;\n\nimport '../ReentrancyGuard.sol';\nimport '../spherex/SphereXProtectedRegisteredBase.sol';\nimport '../interfaces/IMarketEventsAndErrors.sol';\nimport '../interfaces/IERC20.sol';\nimport '../IHooksFactory.sol';\nimport '../libraries/FeeMath.sol';\nimport '../libraries/MarketErrors.sol';\nimport '../libraries/MarketEvents.sol';\nimport '../libraries/Withdrawal.sol';\nimport '../libraries/FunctionTypeCasts.sol';\nimport '../libraries/LibERC20.sol';\nimport '../types/HooksConfig.sol';\n\ncontract WildcatMarketBase is\n  SphereXProtectedRegisteredBase,\n  ReentrancyGuard,\n  IMarketEventsAndErrors\n{\n  using SafeCastLib for uint256;\n  using MathUtils for uint256;\n  using FunctionTypeCasts for *;\n  using LibERC20 for address;\n\n  // ==================================================================== //\n  //                       Market Config (immutable)                       //\n  // ==================================================================== //\n\n  /**\n   * @dev Return the contract version string \"2\".\n   */\n  function version() external pure returns (string memory) {\n    assembly {\n      mstore(0x40, 0)\n      mstore(0x41, 0x0132)\n      mstore(0x20, 0x20)\n      return(0x20, 0x60)\n    }\n  }\n\n  HooksConfig public immutable hooks;\n\n  /// @dev Account with blacklist control, used for blocking sanctioned addresses.\n  address public immutable sentinel;\n\n  /// @dev Account with authority to borrow assets from the market.\n  address public immutable borrower;\n\n  /// @dev Factory that deployed the market. Has the ability to update the protocol fee.\n  address public immutable factory;\n\n  /// @dev Account that receives protocol fees.\n  address public immutable feeRecipient;\n\n  /// @dev Penalty fee added to interest earned by lenders, does not affect protocol fee.\n  uint public immutable delinquencyFeeBips;\n\n  /// @dev Time after which delinquency incurs penalty fee.\n  uint public immutable delinquencyGracePeriod;\n\n  /// @dev Time before withdrawal batches are processed.\n  uint public immutable withdrawalBatchDuration;\n\n  /// @dev Token decimals (same as underlying asset).\n  uint8 public immutable decimals;\n\n  /// @dev Address of the underlying asset.\n  address public immutable asset;\n\n  bytes32 internal immutable PACKED_NAME_WORD_0;\n  bytes32 internal immutable PACKED_NAME_WORD_1;\n  bytes32 internal immutable PACKED_SYMBOL_WORD_0;\n  bytes32 internal immutable PACKED_SYMBOL_WORD_1;\n\n  function symbol() external view returns (string memory) {\n    bytes32 symbolWord0 = PACKED_SYMBOL_WORD_0;\n    bytes32 symbolWord1 = PACKED_SYMBOL_WORD_1;\n\n    assembly {\n      // The layout here is:\n      // 0x00: Offset to the string\n      // 0x20: Length of the string\n      // 0x40: First word of the string\n      // 0x60: Second word of the string\n      // The first word of the string that is kept in immutable storage also contains the\n      // length byte, meaning the total size limit of the string is 63 bytes.\n      mstore(0, 0x20)\n      mstore(0x20, 0)\n      mstore(0x3f, symbolWord0)\n      mstore(0x5f, symbolWord1)\n      return(0, 0x80)\n    }\n  }\n\n  function name() external view returns (string memory) {\n    bytes32 nameWord0 = PACKED_NAME_WORD_0;\n    bytes32 nameWord1 = PACKED_NAME_WORD_1;\n\n    assembly {\n      // The layout here is:\n      // 0x00: Offset to the string\n      // 0x20: Length of the string\n      // 0x40: First word of the string\n      // 0x60: Second word of the string\n      // The first word of the string that is kept in immutable storage also contains the\n      // length byte, meaning the total size limit of the string is 63 bytes.\n      mstore(0, 0x20)\n      mstore(0x20, 0)\n      mstore(0x3f, nameWord0)\n      mstore(0x5f, nameWord1)\n      return(0, 0x80)\n    }\n  }\n\n  /// @dev Returns immutable arch-controller address.\n  function archController() external view returns (address) {\n    return _archController;\n  }\n\n  // ===================================================================== //\n  //                             Market State                               //\n  // ===================================================================== //\n\n  MarketState internal _state;\n\n  mapping(address => Account) internal _accounts;\n\n  WithdrawalData internal _withdrawalData;\n\n  // ===================================================================== //\n  //                             Constructor                               //\n  // ===================================================================== //\n\n  function _getMarketParameters() internal view returns (uint256 marketParametersPointer) {\n    assembly {\n      marketParametersPointer := mload(0x40)\n      mstore(0x40, add(marketParametersPointer, 0x260))\n      // Write the selector for IHooksFactory.getMarketParameters\n      mstore(0x00, 0x04032dbb)\n      // Call `getMarketParameters` and copy the returned struct to the allocated memory\n      // buffer, reverting if the call fails or does not return the correct amount of bytes.\n      // This overrides all the ABI decoding safety checks, as the call is always made to\n      // the factory contract which will only ever return the prepared market parameters.\n      if iszero(\n        and(\n          eq(returndatasize(), 0x260),\n          staticcall(gas(), caller(), 0x1c, 0x04, marketParametersPointer, 0x260)\n        )\n      ) {\n        revert(0, 0)\n      }\n    }\n  }\n\n  constructor() {\n    factory = msg.sender;\n    // Cast the function signature of `_getMarketParameters` to get a valid reference to\n    // a `MarketParameters` object without creating a duplicate allocation or unnecessarily\n    // zeroing out the memory buffer.\n    MarketParameters memory parameters = _getMarketParameters.asReturnsMarketParameters()();\n\n    // Set asset metadata\n    asset = parameters.asset;\n    decimals = parameters.decimals;\n\n    PACKED_NAME_WORD_0 = parameters.packedNameWord0;\n    PACKED_NAME_WORD_1 = parameters.packedNameWord1;\n    PACKED_SYMBOL_WORD_0 = parameters.packedSymbolWord0;\n    PACKED_SYMBOL_WORD_1 = parameters.packedSymbolWord1;\n\n    {\n      // Initialize the market state - all values in slots 1 and 2 of the struct are\n      // initialized to zero, so they are skipped.\n\n      uint maxTotalSupply = parameters.maxTotalSupply;\n      uint reserveRatioBips = parameters.reserveRatioBips;\n      uint annualInterestBips = parameters.annualInterestBips;\n      uint protocolFeeBips = parameters.protocolFeeBips;\n\n      assembly {\n        // MarketState Slot 0 Storage Layout:\n        // [15:31] | state.maxTotalSupply\n        // [31:32] | state.isClosed = false\n\n        let slot0 := shl(8, maxTotalSupply)\n        sstore(_state.slot, slot0)\n\n        // MarketState Slot 3 Storage Layout:\n        // [4:8] | lastInterestAccruedTimestamp\n        // [8:22] | scaleFactor = 1e27\n        // [22:24] | reserveRatioBips\n        // [24:26] | annualInterestBips\n        // [26:28] | protocolFeeBips\n        // [28:32] | timeDelinquent = 0\n\n        let slot3 := or(\n          or(or(shl(0xc0, timestamp()), shl(0x50, RAY)), shl(0x40, reserveRatioBips)),\n          or(shl(0x30, annualInterestBips), shl(0x20, protocolFeeBips))\n        )\n\n        sstore(add(_state.slot, 3), slot3)\n      }\n    }\n\n    hooks = parameters.hooks;\n    sentinel = parameters.sentinel;\n    borrower = parameters.borrower;\n    feeRecipient = parameters.feeRecipient;\n    delinquencyFeeBips = parameters.delinquencyFeeBips;\n    delinquencyGracePeriod = parameters.delinquencyGracePeriod;\n    withdrawalBatchDuration = parameters.withdrawalBatchDuration;\n    _archController = parameters.archController;\n    __SphereXProtectedRegisteredBase_init(parameters.sphereXEngine);\n  }\n\n  // ===================================================================== //\n  //                              Modifiers                                //\n  // ===================================================================== //\n\n  modifier onlyBorrower() {\n    address _borrower = borrower;\n    assembly {\n      // Equivalent to\n      // if (msg.sender != borrower) revert NotApprovedBorrower();\n      if xor(caller(), _borrower) {\n        mstore(0, 0x02171e6a)\n        revert(0x1c, 0x04)\n      }\n    }\n    _;\n  }\n\n  // ===================================================================== //\n  //                       Internal State Getters                          //\n  // ===================================================================== //\n\n  /**\n   * @dev Retrieve an account from storage.\n   *\n   *      Reverts if account is sanctioned.\n   */\n  function _getAccount(address accountAddress) internal view returns (Account memory account) {\n    account = _accounts[accountAddress];\n    if (_isSanctioned(accountAddress)) revert_AccountBlocked();\n  }\n\n  /**\n   * @dev Checks if `account` is flagged as a sanctioned entity by Chainalysis.\n   *      If an account is flagged mistakenly, the borrower can override their\n   *      status on the sentinel and allow them to interact with the market.\n   */\n  function _isSanctioned(address account) internal view returns (bool result) {\n    address _borrower = borrower;\n    address _sentinel = address(sentinel);\n    assembly {\n      let freeMemoryPointer := mload(0x40)\n      mstore(0, 0x06e74444)\n      mstore(0x20, _borrower)\n      mstore(0x40, account)\n      // Call `sentinel.isSanctioned(borrower, account)` and revert if the call fails\n      // or does not return 32 bytes.\n      if iszero(\n        and(eq(returndatasize(), 0x20), staticcall(gas(), _sentinel, 0x1c, 0x44, 0, 0x20))\n      ) {\n        returndatacopy(0, 0, returndatasize())\n        revert(0, returndatasize())\n      }\n      result := mload(0)\n      mstore(0x40, freeMemoryPointer)\n    }\n  }\n\n  // ===================================================================== //\n  //                       External State Getters                          //\n  // ===================================================================== //\n\n  /**\n   * @dev Returns the amount of underlying assets the borrower is obligated\n   *      to maintain in the market to avoid delinquency.\n   */\n  function coverageLiquidity() external view nonReentrantView returns (uint256) {\n    return _calculateCurrentStatePointers.asReturnsMarketState()().liquidityRequired();\n  }\n\n  /**\n   * @dev Returns the scale factor (in ray) used to convert scaled balances\n   *      to normalized balances.\n   */\n  function scaleFactor() external view nonReentrantView returns (uint256) {\n    return _calculateCurrentStatePointers.asReturnsMarketState()().scaleFactor;\n  }\n\n  /**\n   * @dev Total balance in underlying asset.\n   */\n  function totalAssets() public view returns (uint256) {\n    return asset.balanceOf(address(this));\n  }\n\n  /**\n   * @dev Returns the amount of underlying assets the borrower is allowed\n   *      to borrow.\n   *\n   *      This is the balance of underlying assets minus:\n   *      - pending (unpaid) withdrawals\n   *      - paid withdrawals\n   *      - reserve ratio times the portion of the supply not pending withdrawal\n   *      - protocol fees\n   */\n  function borrowableAssets() external view nonReentrantView returns (uint256) {\n    return _calculateCurrentStatePointers.asReturnsMarketState()().borrowableAssets(totalAssets());\n  }\n\n  /**\n   * @dev Returns the amount of protocol fees (in underlying asset amount)\n   *      that have accrued and are pending withdrawal.\n   */\n  function accruedProtocolFees() external view nonReentrantView returns (uint256) {\n    return _calculateCurrentStatePointers.asReturnsMarketState()().accruedProtocolFees;\n  }\n\n  function totalDebts() external view nonReentrantView returns (uint256) {\n    return _calculateCurrentStatePointers.asReturnsMarketState()().totalDebts();\n  }\n\n  /**\n   * @dev Returns the state of the market as of the last update.\n   */\n  function previousState() external view returns (MarketState memory) {\n    MarketState memory state = _state;\n\n    assembly {\n      return(state, 0x1c0)\n    }\n  }\n\n  /**\n   * @dev Return the state the market would have at the current block after applying\n   *      interest and fees accrued since the last update and processing the pending\n   *      withdrawal batch if it is expired.\n   */\n  function currentState() external view nonReentrantView returns (MarketState memory state) {\n    state = _calculateCurrentStatePointers.asReturnsMarketState()();\n    assembly {\n      return(state, 0x1c0)\n    }\n  }\n\n  /**\n   * @dev Call `_calculateCurrentState()` and return only the `state` parameter.\n   *\n   *      Casting the function type prevents a duplicate declaration of the MarketState\n   *      return parameter, which would cause unnecessary zeroing and allocation of memory.\n   *      With `viaIR` enabled, the cast is a noop.\n   */\n  function _calculateCurrentStatePointers() internal view returns (uint256 state) {\n    (state, , ) = _calculateCurrentState.asReturnsPointers()();\n  }\n\n  /**\n   * @dev Returns the scaled total supply the vaut would have at the current block\n   *      after applying interest and fees accrued since the last update and burning\n   *      market tokens for the pending withdrawal batch if it is expired.\n   */\n  function scaledTotalSupply() external view nonReentrantView returns (uint256) {\n    return _calculateCurrentStatePointers.asReturnsMarketState()().scaledTotalSupply;\n  }\n\n  /**\n   * @dev Returns the scaled balance of `account`\n   */\n  function scaledBalanceOf(address account) external view nonReentrantView returns (uint256) {\n    return _accounts[account].scaledBalance;\n  }\n\n  /**\n   * @dev Returns the amount of protocol fees that are currently\n   *      withdrawable by the fee recipient.\n   */\n  function withdrawableProtocolFees() external view returns (uint128) {\n    return\n      _calculateCurrentStatePointers.asReturnsMarketState()().withdrawableProtocolFees(\n        totalAssets()\n      );\n  }\n\n  // /*//////////////////////////////////////////////////////////////\n  //                     Internal State Handlers\n  // //////////////////////////////////////////////////////////////*/\n\n  function _blockAccount(MarketState memory state, address accountAddress) internal virtual {}\n\n  /**\n   * @dev Returns cached MarketState after accruing interest and delinquency / protocol fees\n   *      and processing expired withdrawal batch, if any.\n   *\n   *      Used by functions that make additional changes to `state`.\n   *\n   *      NOTE: Returned `state` does not match `_state` if interest is accrued\n   *            Calling function must update `_state` or revert.\n   *\n   * @return state Market state after interest is accrued.\n   */\n  function _getUpdatedState() internal returns (MarketState memory state) {\n    state = _state;\n    // Handle expired withdrawal batch\n    if (state.hasPendingExpiredBatch()) {\n      uint256 expiry = state.pendingWithdrawalExpiry;\n      // Only accrue interest if time has passed since last update.\n      // This will only be false if withdrawalBatchDuration is 0.\n      uint32 lastInterestAccruedTimestamp = state.lastInterestAccruedTimestamp;\n      if (expiry != lastInterestAccruedTimestamp) {\n        (uint256 baseInterestRay, uint256 delinquencyFeeRay, uint256 protocolFee) = state\n          .updateScaleFactorAndFees(delinquencyFeeBips, delinquencyGracePeriod, expiry);\n        emit_InterestAndFeesAccrued(\n          lastInterestAccruedTimestamp,\n          expiry,\n          state.scaleFactor,\n          baseInterestRay,\n          delinquencyFeeRay,\n          protocolFee\n        );\n      }\n      _processExpiredWithdrawalBatch(state);\n    }\n    uint32 lastInterestAccruedTimestamp = state.lastInterestAccruedTimestamp;\n    // Apply interest and fees accrued since last update (expiry or previous tx)\n    if (block.timestamp != lastInterestAccruedTimestamp) {\n      (uint256 baseInterestRay, uint256 delinquencyFeeRay, uint256 protocolFee) = state\n        .updateScaleFactorAndFees(delinquencyFeeBips, delinquencyGracePeriod, block.timestamp);\n      emit_InterestAndFeesAccrued(\n        lastInterestAccruedTimestamp,\n        block.timestamp,\n        state.scaleFactor,\n        baseInterestRay,\n        delinquencyFeeRay,\n        protocolFee\n      );\n    }\n\n    // If there is a pending withdrawal batch which is not fully paid off, set aside\n    // up to the available liquidity for that batch.\n    if (state.pendingWithdrawalExpiry != 0) {\n      uint32 expiry = state.pendingWithdrawalExpiry;\n      WithdrawalBatch memory batch = _withdrawalData.batches[expiry];\n      if (batch.scaledAmountBurned < batch.scaledTotalAmount) {\n        // Burn as much of the withdrawal batch as possible with available liquidity.\n        uint256 availableLiquidity = batch.availableLiquidityForPendingBatch(state, totalAssets());\n        if (availableLiquidity > 0) {\n          _applyWithdrawalBatchPayment(batch, state, expiry, availableLiquidity);\n          _withdrawalData.batches[expiry] = batch;\n        }\n      }\n    }\n  }\n\n  /**\n   * @dev Calculate the current state, applying fees and interest accrued since\n   *      the last state update as well as the effects of withdrawal batch expiry\n   *      on the market state.\n   *      Identical to _getUpdatedState() except it does not modify storage or\n   *      or emit events.\n   *      Returns expired batch data, if any, so queries against batches have\n   *      access to the most recent data.\n   */\n  function _calculateCurrentState()\n    internal\n    view\n    returns (\n      MarketState memory state,\n      uint32 pendingBatchExpiry,\n      WithdrawalBatch memory pendingBatch\n    )\n  {\n    state = _state;\n    // Handle expired withdrawal batch\n    if (state.hasPendingExpiredBatch()) {\n      pendingBatchExpiry = state.pendingWithdrawalExpiry;\n      // Only accrue interest if time has passed since last update.\n      // This will only be false if withdrawalBatchDuration is 0.\n      if (pendingBatchExpiry != state.lastInterestAccruedTimestamp) {\n        state.updateScaleFactorAndFees(\n          delinquencyFeeBips,\n          delinquencyGracePeriod,\n          pendingBatchExpiry\n        );\n      }\n\n      pendingBatch = _withdrawalData.batches[pendingBatchExpiry];\n      uint256 availableLiquidity = pendingBatch.availableLiquidityForPendingBatch(\n        state,\n        totalAssets()\n      );\n      if (availableLiquidity > 0) {\n        _applyWithdrawalBatchPaymentView(pendingBatch, state, availableLiquidity);\n      }\n      state.pendingWithdrawalExpiry = 0;\n    }\n\n    if (state.lastInterestAccruedTimestamp != block.timestamp) {\n      state.updateScaleFactorAndFees(delinquencyFeeBips, delinquencyGracePeriod, block.timestamp);\n    }\n\n    // If there is a pending withdrawal batch which is not fully paid off, set aside\n    // up to the available liquidity for that batch.\n    if (state.pendingWithdrawalExpiry != 0) {\n      pendingBatchExpiry = state.pendingWithdrawalExpiry;\n      pendingBatch = _withdrawalData.batches[pendingBatchExpiry];\n      if (pendingBatch.scaledAmountBurned < pendingBatch.scaledTotalAmount) {\n        // Burn as much of the withdrawal batch as possible with available liquidity.\n        uint256 availableLiquidity = pendingBatch.availableLiquidityForPendingBatch(\n          state,\n          totalAssets()\n        );\n        if (availableLiquidity > 0) {\n          _applyWithdrawalBatchPaymentView(pendingBatch, state, availableLiquidity);\n        }\n      }\n    }\n  }\n\n  /**\n   * @dev Writes the cached MarketState to storage and emits an event.\n   *      Used at the end of all functions which modify `state`.\n   */\n  function _writeState(MarketState memory state) internal {\n    bool isDelinquent = state.liquidityRequired() > totalAssets();\n    state.isDelinquent = isDelinquent;\n\n    {\n      bool isClosed = state.isClosed;\n      uint maxTotalSupply = state.maxTotalSupply;\n      assembly {\n        // Slot 0 Storage Layout:\n        // [15:31] | state.maxTotalSupply\n        // [31:32] | state.isClosed\n        let slot0 := or(isClosed, shl(0x08, maxTotalSupply))\n        sstore(_state.slot, slot0)\n      }\n    }\n    {\n      uint accruedProtocolFees = state.accruedProtocolFees;\n      uint normalizedUnclaimedWithdrawals = state.normalizedUnclaimedWithdrawals;\n      assembly {\n        // Slot 1 Storage Layout:\n        // [0:16] | state.normalizedUnclaimedWithdrawals\n        // [16:32] | state.accruedProtocolFees\n        let slot1 := or(accruedProtocolFees, shl(0x80, normalizedUnclaimedWithdrawals))\n        sstore(add(_state.slot, 1), slot1)\n      }\n    }\n    {\n      uint scaledTotalSupply = state.scaledTotalSupply;\n      uint scaledPendingWithdrawals = state.scaledPendingWithdrawals;\n      uint pendingWithdrawalExpiry = state.pendingWithdrawalExpiry;\n      assembly {\n        // Slot 2 Storage Layout:\n        // [1:2] | state.isDelinquent\n        // [2:6] | state.pendingWithdrawalExpiry\n        // [6:19] | state.scaledPendingWithdrawals\n        // [19:32] | state.scaledTotalSupply\n        let slot2 := or(\n          or(\n            or(shl(0xf0, isDelinquent), shl(0xd0, pendingWithdrawalExpiry)),\n            shl(0x68, scaledPendingWithdrawals)\n          ),\n          scaledTotalSupply\n        )\n        sstore(add(_state.slot, 2), slot2)\n      }\n    }\n    {\n      uint timeDelinquent = state.timeDelinquent;\n      uint protocolFeeBips = state.protocolFeeBips;\n      uint annualInterestBips = state.annualInterestBips;\n      uint reserveRatioBips = state.reserveRatioBips;\n      uint scaleFactor = state.scaleFactor;\n      uint lastInterestAccruedTimestamp = state.lastInterestAccruedTimestamp;\n      assembly {\n        // Slot 3 Storage Layout:\n        // [4:8] | state.lastInterestAccruedTimestamp\n        // [8:22] | state.scaleFactor\n        // [22:24] | state.reserveRatioBips\n        // [24:26] | state.annualInterestBips\n        // [26:28] | protocolFeeBips\n        // [28:32] | state.timeDelinquent\n        let slot3 := or(\n          or(\n            or(\n              or(shl(0xc0, lastInterestAccruedTimestamp), shl(0x50, scaleFactor)),\n              shl(0x40, reserveRatioBips)\n            ),\n            or(shl(0x30, annualInterestBips), shl(0x20, protocolFeeBips))\n          ),\n          timeDelinquent\n        )\n        sstore(add(_state.slot, 3), slot3)\n      }\n    }\n    emit_StateUpdated(state.scaleFactor, isDelinquent);\n  }\n\n  /**\n   * @dev Handles an expired withdrawal batch:\n   *      - Retrieves the amount of underlying assets that can be used to pay for the batch.\n   *      - If the amount is sufficient to pay the full amount owed to the batch, the batch\n   *        is closed and the total withdrawal amount is reserved.\n   *      - If the amount is insufficient to pay the full amount owed to the batch, the batch\n   *        is recorded as an unpaid batch and the available assets are reserved.\n   *      - The assets reserved for the batch are scaled by the current scale factor and that\n   *        amount of scaled tokens is burned, ensuring borrowers do not continue paying interest\n   *        on withdrawn assets.\n   */\n  function _processExpiredWithdrawalBatch(MarketState memory state) internal {\n    uint32 expiry = state.pendingWithdrawalExpiry;\n    WithdrawalBatch memory batch = _withdrawalData.batches[expiry];\n\n    if (batch.scaledAmountBurned < batch.scaledTotalAmount) {\n      // Burn as much of the withdrawal batch as possible with available liquidity.\n      uint256 availableLiquidity = batch.availableLiquidityForPendingBatch(state, totalAssets());\n      if (availableLiquidity > 0) {\n        _applyWithdrawalBatchPayment(batch, state, expiry, availableLiquidity);\n      }\n    }\n\n    emit_WithdrawalBatchExpired(\n      expiry,\n      batch.scaledTotalAmount,\n      batch.scaledAmountBurned,\n      batch.normalizedAmountPaid\n    );\n\n    if (batch.scaledAmountBurned < batch.scaledTotalAmount) {\n      _withdrawalData.unpaidBatches.push(expiry);\n    } else {\n      emit_WithdrawalBatchClosed(expiry);\n    }\n\n    state.pendingWithdrawalExpiry = 0;\n\n    _withdrawalData.batches[expiry] = batch;\n  }\n\n  /**\n   * @dev Process withdrawal payment, burning market tokens and reserving\n   *      underlying assets so they are only available for withdrawals.\n   */\n  function _applyWithdrawalBatchPayment(\n    WithdrawalBatch memory batch,\n    MarketState memory state,\n    uint32 expiry,\n    uint256 availableLiquidity\n  ) internal returns (uint104 scaledAmountBurned, uint128 normalizedAmountPaid) {\n    uint104 scaledAmountOwed = batch.scaledTotalAmount - batch.scaledAmountBurned;\n\n    // Do nothing if batch is already paid\n    if (scaledAmountOwed == 0) return (0, 0);\n\n    uint256 scaledAvailableLiquidity = state.scaleAmount(availableLiquidity);\n    scaledAmountBurned = MathUtils.min(scaledAvailableLiquidity, scaledAmountOwed).toUint104();\n    // Use mulDiv instead of normalizeAmount to round `normalizedAmountPaid` down, ensuring\n    // it is always possible to finish withdrawal batches on closed markets.\n    normalizedAmountPaid = MathUtils.mulDiv(scaledAmountBurned, state.scaleFactor, RAY).toUint128();\n\n    batch.scaledAmountBurned += scaledAmountBurned;\n    batch.normalizedAmountPaid += normalizedAmountPaid;\n    state.scaledPendingWithdrawals -= scaledAmountBurned;\n\n    // Update normalizedUnclaimedWithdrawals so the tokens are only accessible for withdrawals.\n    state.normalizedUnclaimedWithdrawals += normalizedAmountPaid;\n\n    // Burn market tokens to stop interest accrual upon withdrawal payment.\n    state.scaledTotalSupply -= scaledAmountBurned;\n\n    // Emit transfer for external trackers to indicate burn.\n    emit_Transfer(address(this), _runtimeConstant(address(0)), normalizedAmountPaid);\n    emit_WithdrawalBatchPayment(expiry, scaledAmountBurned, normalizedAmountPaid);\n  }\n\n  function _applyWithdrawalBatchPaymentView(\n    WithdrawalBatch memory batch,\n    MarketState memory state,\n    uint256 availableLiquidity\n  ) internal pure {\n    uint104 scaledAmountOwed = batch.scaledTotalAmount - batch.scaledAmountBurned;\n    // Do nothing if batch is already paid\n    if (scaledAmountOwed == 0) return;\n\n    uint256 scaledAvailableLiquidity = state.scaleAmount(availableLiquidity);\n    uint104 scaledAmountBurned = MathUtils\n      .min(scaledAvailableLiquidity, scaledAmountOwed)\n      .toUint104();\n    // Use mulDiv instead of normalizeAmount to round `normalizedAmountPaid` down, ensuring\n    // it is always possible to finish withdrawal batches on closed markets.\n    uint128 normalizedAmountPaid = MathUtils\n      .mulDiv(scaledAmountBurned, state.scaleFactor, RAY)\n      .toUint128();\n\n    batch.scaledAmountBurned += scaledAmountBurned;\n    batch.normalizedAmountPaid += normalizedAmountPaid;\n    state.scaledPendingWithdrawals -= scaledAmountBurned;\n\n    // Update normalizedUnclaimedWithdrawals so the tokens are only accessible for withdrawals.\n    state.normalizedUnclaimedWithdrawals += normalizedAmountPaid;\n\n    // Burn market tokens to stop interest accrual upon withdrawal payment.\n    state.scaledTotalSupply -= scaledAmountBurned;\n  }\n\n  /**\n   * @dev Function to obfuscate the fact that a value is constant from solc's optimizer.\n   *      This prevents function specialization for calls with a constant input parameter,\n   *      which usually has very little benefit in terms of gas savings but can\n   *      drastically increase contract size.\n   *\n   *      The value returned will always match the input value outside of the constructor,\n   *      fallback and receive functions.\n   */\n  function _runtimeConstant(\n    uint256 actualConstant\n  ) internal pure returns (uint256 runtimeConstant) {\n    assembly {\n      mstore(0, actualConstant)\n      runtimeConstant := mload(iszero(calldatasize()))\n    }\n  }\n\n  function _runtimeConstant(\n    address actualConstant\n  ) internal pure returns (address runtimeConstant) {\n    assembly {\n      mstore(0, actualConstant)\n      runtimeConstant := mload(iszero(calldatasize()))\n    }\n  }\n\n  function _isFlaggedByChainalysis(address account) internal view returns (bool isFlagged) {\n    address sentinelAddress = address(sentinel);\n    assembly {\n      mstore(0, 0x95c09839)\n      mstore(0x20, account)\n      if iszero(\n        and(eq(returndatasize(), 0x20), staticcall(gas(), sentinelAddress, 0x1c, 0x24, 0, 0x20))\n      ) {\n        returndatacopy(0, 0, returndatasize())\n        revert(0, returndatasize())\n      }\n      isFlagged := mload(0)\n    }\n  }\n\n  function _createEscrowForUnderlyingAsset(\n    address accountAddress\n  ) internal returns (address escrow) {\n    address tokenAddress = address(asset);\n    address borrowerAddress = borrower;\n    address sentinelAddress = address(sentinel);\n\n    assembly {\n      let freeMemoryPointer := mload(0x40)\n      mstore(0, 0xa1054f6b)\n      mstore(0x20, borrowerAddress)\n      mstore(0x40, accountAddress)\n      mstore(0x60, tokenAddress)\n      if iszero(\n        and(eq(returndatasize(), 0x20), call(gas(), sentinelAddress, 0, 0x1c, 0x64, 0, 0x20))\n      ) {\n        returndatacopy(0, 0, returndatasize())\n        revert(0, returndatasize())\n      }\n      escrow := mload(0)\n      mstore(0x40, freeMemoryPointer)\n      mstore(0x60, 0)\n    }\n  }\n}\n"},"src/market/WildcatMarketConfig.sol":{"content":"// SPDX-License-Identifier: Apache-2.0 WITH LicenseRef-Commons-Clause-1.0\npragma solidity >=0.8.20;\n\nimport './WildcatMarketBase.sol';\nimport '../libraries/FeeMath.sol';\nimport '../libraries/SafeCastLib.sol';\n\ncontract WildcatMarketConfig is WildcatMarketBase {\n  using SafeCastLib for uint256;\n  using FunctionTypeCasts for *;\n\n  // ===================================================================== //\n  //                      External Config Getters                          //\n  // ===================================================================== //\n\n  /**\n   * @dev Returns whether or not a market has been closed.\n   */\n  function isClosed() external view returns (bool) {\n    // Use stored state because the state update can not affect whether\n    // the market is closed.\n    return _state.isClosed;\n  }\n\n  /**\n   * @dev Returns the maximum amount of underlying asset that can\n   *      currently be deposited to the market.\n   */\n  function maximumDeposit() external view returns (uint256) {\n    MarketState memory state = _calculateCurrentStatePointers.asReturnsMarketState()();\n    return state.maximumDeposit();\n  }\n\n  /**\n   * @dev Returns the maximum supply the market can reach via\n   *      deposits (does not apply to interest accrual).\n   */\n  function maxTotalSupply() external view returns (uint256) {\n    return _state.maxTotalSupply;\n  }\n\n  /**\n   * @dev Returns the annual interest rate earned by lenders\n   *      in bips.\n   */\n  function annualInterestBips() external view returns (uint256) {\n    return _state.annualInterestBips;\n  }\n\n  function reserveRatioBips() external view returns (uint256) {\n    return _state.reserveRatioBips;\n  }\n\n  // ========================================================================== //\n  //                                  Sanctions                                 //\n  // ========================================================================== //\n\n  /// @dev Block a sanctioned account from interacting with the market\n  ///      and transfer its balance to an escrow contract.\n  // ******************************************************************\n  //          *  |\\**/|  *          *                                *\n  //          *  \\ == /  *          *                                *\n  //          *   | b|   *          *                                *\n  //          *   | y|   *          *                                *\n  //          *   \\ e/   *          *                                *\n  //          *    \\/    *          *                                *\n  //          *          *          *                                *\n  //          *          *          *                                *\n  //          *          *  |\\**/|  *                                *\n  //          *          *  \\ == /  *         _.-^^---....,,--       *\n  //          *          *   | b|   *    _--                  --_    *\n  //          *          *   | y|   *   <                        >)  *\n  //          *          *   \\ e/   *   |         O-FAC!          |  *\n  //          *          *    \\/    *    \\._                   _./   *\n  //          *          *          *       ```--. . , ; .--'''      *\n  //          *          *          *   💸        | |   |            *\n  //          *          *          *          .-=||  | |=-.    💸   *\n  //  💰🤑💰  *    😅    *    😐    *    💸    `-=#$%&%$#=-'         *\n  //   \\|/    *   /|\\    *   /|\\    *  🌪         | ;  :|    🌪      *\n  //   /\\     * 💰/\\ 💰  * 💰/\\ 💰  *    _____.,-#%&$@%#&#~,._____   *\n  // ******************************************************************\n  function nukeFromOrbit(address accountAddress) external nonReentrant sphereXGuardExternal {\n    if (!_isSanctioned(accountAddress)) revert_BadLaunchCode();\n    MarketState memory state = _getUpdatedState();\n    hooks.onNukeFromOrbit(accountAddress, state);\n    _blockAccount(state, accountAddress);\n    _writeState(state);\n  }\n\n  // ========================================================================== //\n  //                           External Config Setters                          //\n  // ========================================================================== //\n\n  /**\n   * @dev Sets the maximum total supply - this only limits deposits and\n   *      does not affect interest accrual.\n   *\n   *      The hooks contract may block the change but can not modify the\n   *      value being set.\n   */\n  function setMaxTotalSupply(\n    uint256 _maxTotalSupply\n  ) external onlyBorrower nonReentrant sphereXGuardExternal {\n    MarketState memory state = _getUpdatedState();\n    if (state.isClosed) revert_CapacityChangeOnClosedMarket();\n\n    hooks.onSetMaxTotalSupply(_maxTotalSupply, state);\n    state.maxTotalSupply = _maxTotalSupply.toUint128();\n    _writeState(state);\n    emit_MaxTotalSupplyUpdated(_maxTotalSupply);\n  }\n\n  /**\n   * @dev Sets the annual interest rate earned by lenders in bips.\n   *\n   *      If the new reserve ratio is lower than the old ratio,\n   *      asserts that the market is not currently delinquent.\n   *\n   *      If the new reserve ratio is higher than the old ratio,\n   *      asserts that the market will not become delinquent\n   *      because of the change.\n   */\n  function setAnnualInterestAndReserveRatioBips(\n    uint16 _annualInterestBips,\n    uint16 _reserveRatioBips\n  ) external onlyBorrower nonReentrant sphereXGuardExternal {\n    MarketState memory state = _getUpdatedState();\n    if (state.isClosed) revert_AprChangeOnClosedMarket();\n\n    uint256 initialReserveRatioBips = state.reserveRatioBips;\n\n    (_annualInterestBips, _reserveRatioBips) = hooks.onSetAnnualInterestAndReserveRatioBips(\n      _annualInterestBips,\n      _reserveRatioBips,\n      state\n    );\n\n    if (_annualInterestBips > BIP) {\n      revert_AnnualInterestBipsTooHigh();\n    }\n\n    if (_reserveRatioBips > BIP) {\n      revert_ReserveRatioBipsTooHigh();\n    }\n\n    if (_reserveRatioBips <= initialReserveRatioBips) {\n      if (state.liquidityRequired() > totalAssets()) {\n        revert_InsufficientReservesForOldLiquidityRatio();\n      }\n    }\n    state.reserveRatioBips = _reserveRatioBips;\n    state.annualInterestBips = _annualInterestBips;\n    if (_reserveRatioBips > initialReserveRatioBips) {\n      if (state.liquidityRequired() > totalAssets()) {\n        revert_InsufficientReservesForNewLiquidityRatio();\n      }\n    }\n\n    _writeState(state);\n    emit_AnnualInterestBipsUpdated(_annualInterestBips);\n    emit_ReserveRatioBipsUpdated(_reserveRatioBips);\n  }\n\n  function setProtocolFeeBips(uint16 _protocolFeeBips) external nonReentrant sphereXGuardExternal {\n    if (msg.sender != factory) revert_NotFactory();\n    if (_protocolFeeBips > 1_000) revert_ProtocolFeeTooHigh();\n    MarketState memory state = _getUpdatedState();\n    if (state.isClosed) revert_ProtocolFeeChangeOnClosedMarket();\n    if (_protocolFeeBips != state.protocolFeeBips) {\n      hooks.onSetProtocolFeeBips(_protocolFeeBips, state);\n      state.protocolFeeBips = _protocolFeeBips;\n      emit ProtocolFeeBipsUpdated(_protocolFeeBips);\n    }\n    _writeState(state);\n  }\n}\n"},"src/market/WildcatMarketToken.sol":{"content":"// SPDX-License-Identifier: Apache-2.0 WITH LicenseRef-Commons-Clause-1.0\npragma solidity >=0.8.20;\n\nimport './WildcatMarketBase.sol';\n\ncontract WildcatMarketToken is WildcatMarketBase {\n  using SafeCastLib for uint256;\n  using FunctionTypeCasts for *;\n\n  // ========================================================================== //\n  //                                ERC20 Queries                               //\n  // ========================================================================== //\n\n  mapping(address => mapping(address => uint256)) public allowance;\n\n  /// @notice Returns the normalized balance of `account` with interest.\n  function balanceOf(address account) public view virtual nonReentrantView returns (uint256) {\n    return\n      _calculateCurrentStatePointers.asReturnsMarketState()().normalizeAmount(\n        _accounts[account].scaledBalance\n      );\n  }\n\n  /// @notice Returns the normalized total supply with interest.\n  function totalSupply() external view virtual nonReentrantView returns (uint256) {\n    return _calculateCurrentStatePointers.asReturnsMarketState()().totalSupply();\n  }\n\n  // ========================================================================== //\n  //                                ERC20 Actions                               //\n  // ========================================================================== //\n\n  function approve(\n    address spender,\n    uint256 amount\n  ) external virtual nonReentrant sphereXGuardExternal returns (bool) {\n    _approve(msg.sender, spender, amount);\n    return true;\n  }\n\n  function transfer(\n    address to,\n    uint256 amount\n  ) external virtual nonReentrant sphereXGuardExternal returns (bool) {\n    _transfer(msg.sender, to, amount, 0x44);\n    return true;\n  }\n\n  function transferFrom(\n    address from,\n    address to,\n    uint256 amount\n  ) external virtual nonReentrant sphereXGuardExternal returns (bool) {\n    uint256 allowed = allowance[from][msg.sender];\n\n    // Saves gas for unlimited approvals.\n    if (allowed != type(uint256).max) {\n      uint256 newAllowance = allowed - amount;\n      _approve(from, msg.sender, newAllowance);\n    }\n\n    _transfer(from, to, amount, 0x64);\n\n    return true;\n  }\n\n  function _approve(address approver, address spender, uint256 amount) internal virtual {\n    allowance[approver][spender] = amount;\n    emit_Approval(approver, spender, amount);\n  }\n\n  function _transfer(\n    address from,\n    address to,\n    uint256 amount,\n    uint baseCalldataSize\n  ) internal virtual {\n    MarketState memory state = _getUpdatedState();\n    uint104 scaledAmount = state.scaleAmount(amount).toUint104();\n\n    if (scaledAmount == 0) revert_NullTransferAmount();\n\n    hooks.onTransfer(from, to, scaledAmount, state, baseCalldataSize);\n\n    Account memory fromAccount = _getAccount(from);\n    fromAccount.scaledBalance -= scaledAmount;\n    _accounts[from] = fromAccount;\n\n    Account memory toAccount = _getAccount(to);\n    toAccount.scaledBalance += scaledAmount;\n    _accounts[to] = toAccount;\n\n    _writeState(state);\n    emit_Transfer(from, to, amount);\n  }\n}\n"},"src/market/WildcatMarketWithdrawals.sol":{"content":"// SPDX-License-Identifier: Apache-2.0 WITH LicenseRef-Commons-Clause-1.0\npragma solidity >=0.8.20;\n\nimport './WildcatMarketBase.sol';\nimport '../libraries/LibERC20.sol';\nimport '../libraries/BoolUtils.sol';\n\ncontract WildcatMarketWithdrawals is WildcatMarketBase {\n  using LibERC20 for address;\n  using MathUtils for uint256;\n  using MathUtils for bool;\n  using SafeCastLib for uint256;\n  using BoolUtils for bool;\n\n  // ========================================================================== //\n  //                             Withdrawal Queries                             //\n  // ========================================================================== //\n\n  /**\n   * @dev Returns the expiry timestamp of every unpaid withdrawal batch.\n   */\n  function getUnpaidBatchExpiries() external view nonReentrantView returns (uint32[] memory) {\n    return _withdrawalData.unpaidBatches.values();\n  }\n\n  function getWithdrawalBatch(\n    uint32 expiry\n  ) external view nonReentrantView returns (WithdrawalBatch memory batch) {\n    (, uint32 pendingBatchExpiry, WithdrawalBatch memory pendingBatch) = _calculateCurrentState();\n    if ((expiry == pendingBatchExpiry).and(expiry > 0)) {\n      return pendingBatch;\n    }\n\n    WithdrawalBatch storage _batch = _withdrawalData.batches[expiry];\n    batch.scaledTotalAmount = _batch.scaledTotalAmount;\n    batch.scaledAmountBurned = _batch.scaledAmountBurned;\n    batch.normalizedAmountPaid = _batch.normalizedAmountPaid;\n  }\n\n  function getAccountWithdrawalStatus(\n    address accountAddress,\n    uint32 expiry\n  ) external view nonReentrantView returns (AccountWithdrawalStatus memory status) {\n    AccountWithdrawalStatus storage _status = _withdrawalData.accountStatuses[expiry][\n      accountAddress\n    ];\n    status.scaledAmount = _status.scaledAmount;\n    status.normalizedAmountWithdrawn = _status.normalizedAmountWithdrawn;\n  }\n\n  function getAvailableWithdrawalAmount(\n    address accountAddress,\n    uint32 expiry\n  ) external view nonReentrantView returns (uint256) {\n    if (expiry >= block.timestamp) {\n      revert_WithdrawalBatchNotExpired();\n    }\n    (, uint32 pendingBatchExpiry, WithdrawalBatch memory pendingBatch) = _calculateCurrentState();\n    WithdrawalBatch memory batch;\n    if (expiry == pendingBatchExpiry) {\n      batch = pendingBatch;\n    } else {\n      batch = _withdrawalData.batches[expiry];\n    }\n    AccountWithdrawalStatus memory status = _withdrawalData.accountStatuses[expiry][accountAddress];\n    // Rounding errors will lead to some dust accumulating in the batch, but the cost of\n    // executing a withdrawal will be lower for users.\n    uint256 previousTotalWithdrawn = status.normalizedAmountWithdrawn;\n    uint256 newTotalWithdrawn = uint256(batch.normalizedAmountPaid).mulDiv(\n      status.scaledAmount,\n      batch.scaledTotalAmount\n    );\n    return newTotalWithdrawn - previousTotalWithdrawn;\n  }\n\n  // ========================================================================== //\n  //                             Withdrawal Actions                             //\n  // ========================================================================== //\n\n  function _queueWithdrawal(\n    MarketState memory state,\n    Account memory account,\n    address accountAddress,\n    uint104 scaledAmount,\n    uint normalizedAmount,\n    uint baseCalldataSize\n  ) internal returns (uint32 expiry) {\n    // Cache batch expiry on the stack for gas savings\n    expiry = state.pendingWithdrawalExpiry;\n\n    // If there is no pending withdrawal batch, create a new one.\n    if (state.pendingWithdrawalExpiry == 0) {\n      // If the market is closed, use zero for withdrawal batch duration.\n      uint duration = state.isClosed.ternary(0, withdrawalBatchDuration);\n      expiry = uint32(block.timestamp + duration);\n      emit_WithdrawalBatchCreated(expiry);\n      state.pendingWithdrawalExpiry = expiry;\n    }\n\n    // Execute queueWithdrawal hook if enabled\n    hooks.onQueueWithdrawal(accountAddress, expiry, scaledAmount, state, baseCalldataSize);\n\n    // Reduce account's balance and emit transfer event\n    account.scaledBalance -= scaledAmount;\n    _accounts[accountAddress] = account;\n\n    emit_Transfer(accountAddress, address(this), normalizedAmount);\n\n    WithdrawalBatch memory batch = _withdrawalData.batches[expiry];\n\n    // Add scaled withdrawal amount to account withdrawal status, withdrawal batch and market state.\n    _withdrawalData.accountStatuses[expiry][accountAddress].scaledAmount += scaledAmount;\n    batch.scaledTotalAmount += scaledAmount;\n    state.scaledPendingWithdrawals += scaledAmount;\n\n    emit_WithdrawalQueued(expiry, accountAddress, scaledAmount, normalizedAmount);\n\n    // Burn as much of the withdrawal batch as possible with available liquidity.\n    uint256 availableLiquidity = batch.availableLiquidityForPendingBatch(state, totalAssets());\n    if (availableLiquidity > 0) {\n      _applyWithdrawalBatchPayment(batch, state, expiry, availableLiquidity);\n    }\n\n    // Update stored batch data\n    _withdrawalData.batches[expiry] = batch;\n\n    // Update stored state\n    _writeState(state);\n  }\n\n  /**\n   * @dev Create a withdrawal request for a lender.\n   */\n  function queueWithdrawal(\n    uint256 amount\n  ) external nonReentrant sphereXGuardExternal returns (uint32 expiry) {\n    MarketState memory state = _getUpdatedState();\n\n    uint104 scaledAmount = state.scaleAmount(amount).toUint104();\n    if (scaledAmount == 0) revert_NullBurnAmount();\n\n    // Cache account data\n    Account memory account = _getAccount(msg.sender);\n\n    return\n      _queueWithdrawal(state, account, msg.sender, scaledAmount, amount, _runtimeConstant(0x24));\n  }\n\n  /**\n   * @dev Queue a withdrawal for all of the caller's balance.\n   */\n  function queueFullWithdrawal()\n    external\n    nonReentrant\n    sphereXGuardExternal\n    returns (uint32 expiry)\n  {\n    MarketState memory state = _getUpdatedState();\n\n    // Cache account data\n    Account memory account = _getAccount(msg.sender);\n\n    uint104 scaledAmount = account.scaledBalance;\n    if (scaledAmount == 0) revert_NullBurnAmount();\n\n    uint256 normalizedAmount = state.normalizeAmount(scaledAmount);\n\n    return\n      _queueWithdrawal(\n        state,\n        account,\n        msg.sender,\n        scaledAmount,\n        normalizedAmount,\n        _runtimeConstant(0x04)\n      );\n  }\n\n  /**\n   * @dev Execute a pending withdrawal request for a batch that has expired.\n   *\n   *      Withdraws the proportional amount of the paid batch owed to\n   *      `accountAddress` which has not already been withdrawn.\n   *\n   *      If `accountAddress` is sanctioned, transfers the owed amount to\n   *      an escrow contract specific to the account and blocks the account.\n   *\n   *      Reverts if:\n   *      - `expiry >= block.timestamp`\n   *      -  `expiry` does not correspond to an existing withdrawal batch\n   *      - `accountAddress` has already withdrawn the full amount owed\n   */\n  function executeWithdrawal(\n    address accountAddress,\n    uint32 expiry\n  ) public nonReentrant sphereXGuardExternal returns (uint256) {\n    MarketState memory state = _getUpdatedState();\n    // Use an obfuscated constant for the base calldata size to prevent solc\n    // function specialization.\n    uint256 normalizedAmountWithdrawn = _executeWithdrawal(\n      state,\n      accountAddress,\n      expiry,\n      _runtimeConstant(0x44)\n    );\n    // Update stored state\n    _writeState(state);\n    return normalizedAmountWithdrawn;\n  }\n\n  function executeWithdrawals(\n    address[] calldata accountAddresses,\n    uint32[] calldata expiries\n  ) external nonReentrant sphereXGuardExternal returns (uint256[] memory amounts) {\n    if (accountAddresses.length != expiries.length) revert_InvalidArrayLength();\n\n    amounts = new uint256[](accountAddresses.length);\n\n    MarketState memory state = _getUpdatedState();\n\n    for (uint256 i = 0; i < accountAddresses.length; i++) {\n      // Use calldatasize() for baseCalldataSize to indicate no data should be passed as `extraData`\n      amounts[i] = _executeWithdrawal(state, accountAddresses[i], expiries[i], msg.data.length);\n    }\n    // Update stored state\n    _writeState(state);\n    return amounts;\n  }\n\n  function _executeWithdrawal(\n    MarketState memory state,\n    address accountAddress,\n    uint32 expiry,\n    uint baseCalldataSize\n  ) internal returns (uint256) {\n    WithdrawalBatch memory batch = _withdrawalData.batches[expiry];\n    if (expiry == state.pendingWithdrawalExpiry) revert_WithdrawalBatchNotExpired();\n\n    AccountWithdrawalStatus storage status = _withdrawalData.accountStatuses[expiry][\n      accountAddress\n    ];\n\n    uint128 newTotalWithdrawn = uint128(\n      MathUtils.mulDiv(batch.normalizedAmountPaid, status.scaledAmount, batch.scaledTotalAmount)\n    );\n\n    uint128 normalizedAmountWithdrawn = newTotalWithdrawn - status.normalizedAmountWithdrawn;\n\n    if (normalizedAmountWithdrawn == 0) revert_NullWithdrawalAmount();\n\n    hooks.onExecuteWithdrawal(accountAddress, normalizedAmountWithdrawn, state, baseCalldataSize);\n\n    status.normalizedAmountWithdrawn = newTotalWithdrawn;\n    state.normalizedUnclaimedWithdrawals -= normalizedAmountWithdrawn;\n\n    if (_isSanctioned(accountAddress)) {\n      // Get or create an escrow contract for the lender and transfer the owed amount to it.\n      // They will be unable to withdraw from the escrow until their sanctioned\n      // status is lifted on Chainalysis, or until the borrower overrides it.\n      address escrow = _createEscrowForUnderlyingAsset(accountAddress);\n      asset.safeTransfer(escrow, normalizedAmountWithdrawn);\n\n      // Emit `SanctionedAccountWithdrawalSentToEscrow` event using a custom emitter.\n      emit_SanctionedAccountWithdrawalSentToEscrow(\n        accountAddress,\n        escrow,\n        expiry,\n        normalizedAmountWithdrawn\n      );\n    } else {\n      asset.safeTransfer(accountAddress, normalizedAmountWithdrawn);\n    }\n\n    emit_WithdrawalExecuted(expiry, accountAddress, normalizedAmountWithdrawn);\n\n    return normalizedAmountWithdrawn;\n  }\n\n  function repayAndProcessUnpaidWithdrawalBatches(\n    uint256 repayAmount,\n    uint256 maxBatches\n  ) public nonReentrant sphereXGuardExternal {\n    // Repay before updating state to ensure the paid amount is counted towards\n    // any pending or unpaid withdrawals.\n    if (repayAmount > 0) {\n      asset.safeTransferFrom(msg.sender, address(this), repayAmount);\n      emit_DebtRepaid(msg.sender, repayAmount);\n    }\n\n    MarketState memory state = _getUpdatedState();\n    if (state.isClosed) revert_RepayToClosedMarket();\n\n    // Use an obfuscated constant for the base calldata size to prevent solc\n    // function specialization.\n    if (repayAmount > 0) hooks.onRepay(repayAmount, state, _runtimeConstant(0x44));\n\n    // Calculate assets available to process the first batch - will be updated after each batch\n    uint256 availableLiquidity = totalAssets() -\n      (state.normalizedUnclaimedWithdrawals + state.accruedProtocolFees);\n\n    // Get the maximum number of batches to process\n    uint256 numBatches = MathUtils.min(maxBatches, _withdrawalData.unpaidBatches.length());\n\n    uint256 i;\n    // Process up to `maxBatches` unpaid batches while there is available liquidity\n    while (i++ < numBatches && availableLiquidity > 0) {\n      // Process the next unpaid batch using available liquidity\n      uint256 normalizedAmountPaid = _processUnpaidWithdrawalBatch(state, availableLiquidity);\n      // Reduce liquidity available to next batch\n      availableLiquidity = availableLiquidity.satSub(normalizedAmountPaid);\n    }\n    _writeState(state);\n  }\n\n  function _processUnpaidWithdrawalBatch(\n    MarketState memory state,\n    uint256 availableLiquidity\n  ) internal returns (uint256 normalizedAmountPaid) {\n    // Get the next unpaid batch timestamp from storage (reverts if none)\n    uint32 expiry = _withdrawalData.unpaidBatches.first();\n\n    // Cache batch data in memory\n    WithdrawalBatch memory batch = _withdrawalData.batches[expiry];\n\n    // Pay up to the available liquidity to the batch\n    (, normalizedAmountPaid) = _applyWithdrawalBatchPayment(\n      batch,\n      state,\n      expiry,\n      availableLiquidity\n    );\n\n    // Update stored batch\n    _withdrawalData.batches[expiry] = batch;\n\n    // Remove batch from unpaid set if fully paid\n    if (batch.scaledTotalAmount == batch.scaledAmountBurned) {\n      _withdrawalData.unpaidBatches.shift();\n      emit_WithdrawalBatchClosed(expiry);\n    }\n  }\n}\n"},"src/WildcatSanctionsSentinel.sol":{"content":"// SPDX-License-Identifier: Apache-2.0 WITH LicenseRef-Commons-Clause-1.0\npragma solidity >=0.8.20;\n\nimport { IChainalysisSanctionsList } from './interfaces/IChainalysisSanctionsList.sol';\nimport { IWildcatSanctionsSentinel } from './interfaces/IWildcatSanctionsSentinel.sol';\nimport { WildcatSanctionsEscrow } from './WildcatSanctionsEscrow.sol';\n\ncontract WildcatSanctionsSentinel is IWildcatSanctionsSentinel {\n  // ========================================================================== //\n  //                                  Constants                                 //\n  // ========================================================================== //\n\n  bytes32 public constant override WildcatSanctionsEscrowInitcodeHash =\n    keccak256(type(WildcatSanctionsEscrow).creationCode);\n\n  address public immutable override chainalysisSanctionsList;\n\n  address public immutable override archController;\n\n  // ========================================================================== //\n  //                                   Storage                                  //\n  // ========================================================================== //\n\n  TmpEscrowParams public override tmpEscrowParams;\n\n  mapping(address borrower => mapping(address account => bool sanctionOverride))\n    public\n    override sanctionOverrides;\n\n  // ========================================================================== //\n  //                                 Constructor                                //\n  // ========================================================================== //\n\n  constructor(address _archController, address _chainalysisSanctionsList) {\n    archController = _archController;\n    chainalysisSanctionsList = _chainalysisSanctionsList;\n    _resetTmpEscrowParams();\n  }\n\n  // ========================================================================== //\n  //                              Internal Helpers                              //\n  // ========================================================================== //\n\n  function _resetTmpEscrowParams() internal {\n    tmpEscrowParams = TmpEscrowParams(address(1), address(1), address(1));\n  }\n\n  /**\n   * @dev Derive create2 salt for an escrow given the borrower, account and asset.\n   *      name prefix and symbol prefix.\n   */\n  function _deriveSalt(\n    address borrower,\n    address account,\n    address asset\n  ) internal pure returns (bytes32 salt) {\n    assembly {\n      // Cache free memory pointer\n      let freeMemoryPointer := mload(0x40)\n      // `keccak256(abi.encode(borrower, account, asset))`\n      mstore(0x00, borrower)\n      mstore(0x20, account)\n      mstore(0x40, asset)\n      salt := keccak256(0, 0x60)\n      // Restore free memory pointer\n      mstore(0x40, freeMemoryPointer)\n    }\n  }\n\n  // ========================================================================== //\n  //                              Sanction Queries                              //\n  // ========================================================================== //\n\n  /**\n   * @dev Returns boolean indicating whether `account` is sanctioned on Chainalysis.\n   */\n  function isFlaggedByChainalysis(address account) public view override returns (bool) {\n    return IChainalysisSanctionsList(chainalysisSanctionsList).isSanctioned(account);\n  }\n\n  /**\n   * @dev Returns boolean indicating whether `account` is sanctioned on Chainalysis\n   *      and that status has not been overridden by `borrower`.\n   */\n  function isSanctioned(address borrower, address account) public view override returns (bool) {\n    return !sanctionOverrides[borrower][account] && isFlaggedByChainalysis(account);\n  }\n\n  // ========================================================================== //\n  //                             Sanction Overrides                             //\n  // ========================================================================== //\n\n  /**\n   * @dev Overrides the sanction status of `account` for `borrower`.\n   */\n  function overrideSanction(address account) public override {\n    sanctionOverrides[msg.sender][account] = true;\n    emit SanctionOverride(msg.sender, account);\n  }\n\n  /**\n   * @dev Removes the sanction override of `account` for `borrower`.\n   */\n  function removeSanctionOverride(address account) public override {\n    sanctionOverrides[msg.sender][account] = false;\n    emit SanctionOverrideRemoved(msg.sender, account);\n  }\n\n  // ========================================================================== //\n  //                              Escrow Deployment                             //\n  // ========================================================================== //\n\n  /**\n   * @dev Creates a new WildcatSanctionsEscrow contract for `borrower`,\n   *      `account`, and `asset` or returns the existing escrow contract\n   *      if one already exists.\n   *\n   *      The escrow contract is added to the set of sanction override\n   *      addresses for `borrower` so that it can not be blocked.\n   */\n  function createEscrow(\n    address borrower,\n    address account,\n    address asset\n  ) public override returns (address escrowContract) {\n    escrowContract = getEscrowAddress(borrower, account, asset);\n\n    // Skip creation if the address code size is non-zero\n    if (escrowContract.code.length != 0) return escrowContract;\n\n    tmpEscrowParams = TmpEscrowParams(borrower, account, asset);\n\n    new WildcatSanctionsEscrow{ salt: _deriveSalt(borrower, account, asset) }();\n\n    emit NewSanctionsEscrow(borrower, account, asset);\n\n    sanctionOverrides[borrower][escrowContract] = true;\n\n    emit SanctionOverride(borrower, escrowContract);\n\n    _resetTmpEscrowParams();\n  }\n\n  /**\n   * @dev Calculate the create2 escrow address for the combination\n   *      of `borrower`, `account`, and `asset`.\n   */\n  function getEscrowAddress(\n    address borrower,\n    address account,\n    address asset\n  ) public view override returns (address escrowAddress) {\n    bytes32 salt = _deriveSalt(borrower, account, asset);\n    bytes32 initCodeHash = WildcatSanctionsEscrowInitcodeHash;\n    assembly {\n      // Cache the free memory pointer so it can be restored at the end\n      let freeMemoryPointer := mload(0x40)\n\n      // Write 0xff + address(this) to bytes 11:32\n      mstore(0x00, or(0xff0000000000000000000000000000000000000000, address()))\n\n      // Write salt to bytes 32:64\n      mstore(0x20, salt)\n\n      // Write initcode hash to bytes 64:96\n      mstore(0x40, initCodeHash)\n\n      // Calculate create2 hash\n      escrowAddress := and(keccak256(0x0b, 0x55), 0xffffffffffffffffffffffffffffffffffffffff)\n\n      // Restore the free memory pointer\n      mstore(0x40, freeMemoryPointer)\n    }\n  }\n}\n"},"src/libraries/MarketState.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.20;\n\nimport './MathUtils.sol';\nimport './SafeCastLib.sol';\nimport './FeeMath.sol';\n\nusing MarketStateLib for MarketState global;\nusing MarketStateLib for Account global;\nusing FeeMath for MarketState global;\n\nstruct MarketState {\n  bool isClosed;\n  uint128 maxTotalSupply;\n  uint128 accruedProtocolFees;\n  // Underlying assets reserved for withdrawals which have been paid\n  // by the borrower but not yet executed.\n  uint128 normalizedUnclaimedWithdrawals;\n  // Scaled token supply (divided by scaleFactor)\n  uint104 scaledTotalSupply;\n  // Scaled token amount in withdrawal batches that have not been\n  // paid by borrower yet.\n  uint104 scaledPendingWithdrawals;\n  uint32 pendingWithdrawalExpiry;\n  // Whether market is currently delinquent (liquidity under requirement)\n  bool isDelinquent;\n  // Seconds borrower has been delinquent\n  uint32 timeDelinquent;\n  // Fee charged to borrowers as a fraction of the annual interest rate\n  uint16 protocolFeeBips;\n  // Annual interest rate accrued to lenders, in basis points\n  uint16 annualInterestBips;\n  // Percentage of outstanding balance that must be held in liquid reserves\n  uint16 reserveRatioBips;\n  // Ratio between internal balances and underlying token amounts\n  uint112 scaleFactor;\n  uint32 lastInterestAccruedTimestamp;\n}\n\nstruct Account {\n  uint104 scaledBalance;\n}\n\nlibrary MarketStateLib {\n  using MathUtils for uint256;\n  using SafeCastLib for uint256;\n\n  /**\n   * @dev Returns the normalized total supply of the market.\n   */\n  function totalSupply(MarketState memory state) internal pure returns (uint256) {\n    return state.normalizeAmount(state.scaledTotalSupply);\n  }\n\n  /**\n   * @dev Returns the maximum amount of tokens that can be deposited without\n   *      reaching the maximum total supply.\n   */\n  function maximumDeposit(MarketState memory state) internal pure returns (uint256) {\n    return uint256(state.maxTotalSupply).satSub(state.totalSupply());\n  }\n\n  /**\n   * @dev Normalize an amount of scaled tokens using the current scale factor.\n   */\n  function normalizeAmount(\n    MarketState memory state,\n    uint256 amount\n  ) internal pure returns (uint256) {\n    return amount.rayMul(state.scaleFactor);\n  }\n\n  /**\n   * @dev Scale an amount of normalized tokens using the current scale factor.\n   */\n  function scaleAmount(MarketState memory state, uint256 amount) internal pure returns (uint256) {\n    return amount.rayDiv(state.scaleFactor);\n  }\n\n  /**\n   * @dev Collateralization requirement is:\n   *      - 100% of all pending (unpaid) withdrawals\n   *      - 100% of all unclaimed (paid) withdrawals\n   *      - reserve ratio times the outstanding debt (supply - pending withdrawals)\n   *      - accrued protocol fees\n   */\n  function liquidityRequired(\n    MarketState memory state\n  ) internal pure returns (uint256 _liquidityRequired) {\n    uint256 scaledWithdrawals = state.scaledPendingWithdrawals;\n    uint256 scaledRequiredReserves = (state.scaledTotalSupply - scaledWithdrawals).bipMul(\n      state.reserveRatioBips\n    ) + scaledWithdrawals;\n    return\n      state.normalizeAmount(scaledRequiredReserves) +\n      state.accruedProtocolFees +\n      state.normalizedUnclaimedWithdrawals;\n  }\n\n  /**\n   * @dev Returns the amount of underlying assets that can be withdrawn\n   *      for protocol fees. The only debts with higher priority are\n   *      processed withdrawals that have not been executed.\n   */\n  function withdrawableProtocolFees(\n    MarketState memory state,\n    uint256 totalAssets\n  ) internal pure returns (uint128) {\n    uint256 totalAvailableAssets = totalAssets - state.normalizedUnclaimedWithdrawals;\n    return uint128(MathUtils.min(totalAvailableAssets, state.accruedProtocolFees));\n  }\n\n  /**\n   * @dev Returns the amount of underlying assets that can be borrowed.\n   *\n   *      The borrower must maintain sufficient assets in the market to\n   *      cover 100% of pending withdrawals, 100% of previously processed\n   *      withdrawals (before they are executed), and the reserve ratio\n   *      times the outstanding debt (deposits not pending withdrawal).\n   *\n   *      Any underlying assets in the market above this amount can be borrowed.\n   */\n  function borrowableAssets(\n    MarketState memory state,\n    uint256 totalAssets\n  ) internal pure returns (uint256) {\n    return totalAssets.satSub(state.liquidityRequired());\n  }\n\n  function hasPendingExpiredBatch(MarketState memory state) internal view returns (bool result) {\n    uint256 expiry = state.pendingWithdrawalExpiry;\n    assembly {\n      // Equivalent to expiry > 0 && expiry < block.timestamp\n      result := and(gt(expiry, 0), gt(timestamp(), expiry))\n    }\n  }\n\n  function totalDebts(MarketState memory state) internal pure returns (uint256) {\n    return\n      state.normalizeAmount(state.scaledTotalSupply) +\n      state.normalizedUnclaimedWithdrawals +\n      state.accruedProtocolFees;\n  }\n}\n"},"src/libraries/BoolUtils.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.20;\n\nlibrary BoolUtils {\n  function and(bool a, bool b) internal pure returns (bool c) {\n    assembly {\n      c := and(a, b)\n    }\n  }\n\n  function or(bool a, bool b) internal pure returns (bool c) {\n    assembly {\n      c := or(a, b)\n    }\n  }\n\n  function xor(bool a, bool b) internal pure returns (bool c) {\n    assembly {\n      c := xor(a, b)\n    }\n  }\n}\n"},"src/types/LenderStatus.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.20;\nimport './RoleProvider.sol';\n\n/**\n * @param isBlockedFromDeposits   Whether the lender is blocked from depositing\n * @param lastProvider            The address of the last provider to grant the lender a credential\n * @param canRefresh              Whether the last provider can refresh the lender's credential\n * @param lastApprovalTimestamp   The timestamp at which the lender's credential was granted\n */\nstruct LenderStatus {\n  bool isBlockedFromDeposits;\n  address lastProvider;\n  bool canRefresh;\n  uint32 lastApprovalTimestamp;\n}\n\nusing LibLenderStatus for LenderStatus global;\n\nlibrary LibLenderStatus {\n  /**\n   * @dev Returns whether the lender's credential has expired.\n   *\n   *      Note: Does not check if the lender has a credential - if the\n   *      provider's TTL is greater than the current block timestamp,\n   *      this function will always return false. Should always be used\n   *      in conjunction with `hasCredential`.\n   */\n  function credentialExpired(\n    LenderStatus memory status,\n    RoleProvider provider\n  ) internal view returns (bool) {\n    return provider.calculateExpiry(status.lastApprovalTimestamp) < block.timestamp;\n  }\n\n  function hasCredential(LenderStatus memory status) internal pure returns (bool) {\n    return status.lastApprovalTimestamp > 0;\n  }\n\n  /**\n   * @dev Returns whether the lender's credential has not expired.\n   *\n   *      Note: Does not check if the lender has a credential - if the\n   *      provider's TTL is greater than the current block timestamp,\n   *      this function will always return true. Should always be used\n   *      in conjunction with `hasCredential`.\n   */\n  function credentialNotExpired(\n    LenderStatus memory status,\n    RoleProvider provider\n  ) internal view returns (bool) {\n    return provider.calculateExpiry(status.lastApprovalTimestamp) >= block.timestamp;\n  }\n\n  function setCredential(\n    LenderStatus memory status,\n    RoleProvider provider,\n    uint256 timestamp\n  ) internal pure {\n    // User is approved, update status with new expiry and last provider\n    status.lastApprovalTimestamp = uint32(timestamp);\n    status.lastProvider = provider.providerAddress();\n    status.canRefresh = provider.isPullProvider();\n  }\n\n  function unsetCredential(LenderStatus memory status) internal pure {\n    status.canRefresh = false;\n    status.lastApprovalTimestamp = 0;\n    status.lastProvider = address(0);\n  }\n}\n"},"src/libraries/SafeCastLib.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.20;\n\nimport './Errors.sol';\n\nlibrary SafeCastLib {\n  function _assertNonOverflow(bool didNotOverflow) private pure {\n    assembly {\n      if iszero(didNotOverflow) {\n        mstore(0, Panic_ErrorSelector)\n        mstore(Panic_ErrorCodePointer, Panic_Arithmetic)\n        revert(Error_SelectorPointer, Panic_ErrorLength)\n      }\n    }\n  }\n\n  function toUint8(uint256 x) internal pure returns (uint8 y) {\n    _assertNonOverflow(x == (y = uint8(x)));\n  }\n\n  function toUint16(uint256 x) internal pure returns (uint16 y) {\n    _assertNonOverflow(x == (y = uint16(x)));\n  }\n\n  function toUint24(uint256 x) internal pure returns (uint24 y) {\n    _assertNonOverflow(x == (y = uint24(x)));\n  }\n\n  function toUint32(uint256 x) internal pure returns (uint32 y) {\n    _assertNonOverflow(x == (y = uint32(x)));\n  }\n\n  function toUint40(uint256 x) internal pure returns (uint40 y) {\n    _assertNonOverflow(x == (y = uint40(x)));\n  }\n\n  function toUint48(uint256 x) internal pure returns (uint48 y) {\n    _assertNonOverflow(x == (y = uint48(x)));\n  }\n\n  function toUint56(uint256 x) internal pure returns (uint56 y) {\n    _assertNonOverflow(x == (y = uint56(x)));\n  }\n\n  function toUint64(uint256 x) internal pure returns (uint64 y) {\n    _assertNonOverflow(x == (y = uint64(x)));\n  }\n\n  function toUint72(uint256 x) internal pure returns (uint72 y) {\n    _assertNonOverflow(x == (y = uint72(x)));\n  }\n\n  function toUint80(uint256 x) internal pure returns (uint80 y) {\n    _assertNonOverflow(x == (y = uint80(x)));\n  }\n\n  function toUint88(uint256 x) internal pure returns (uint88 y) {\n    _assertNonOverflow(x == (y = uint88(x)));\n  }\n\n  function toUint96(uint256 x) internal pure returns (uint96 y) {\n    _assertNonOverflow(x == (y = uint96(x)));\n  }\n\n  function toUint104(uint256 x) internal pure returns (uint104 y) {\n    _assertNonOverflow(x == (y = uint104(x)));\n  }\n\n  function toUint112(uint256 x) internal pure returns (uint112 y) {\n    _assertNonOverflow(x == (y = uint112(x)));\n  }\n\n  function toUint120(uint256 x) internal pure returns (uint120 y) {\n    _assertNonOverflow(x == (y = uint120(x)));\n  }\n\n  function toUint128(uint256 x) internal pure returns (uint128 y) {\n    _assertNonOverflow(x == (y = uint128(x)));\n  }\n\n  function toUint136(uint256 x) internal pure returns (uint136 y) {\n    _assertNonOverflow(x == (y = uint136(x)));\n  }\n\n  function toUint144(uint256 x) internal pure returns (uint144 y) {\n    _assertNonOverflow(x == (y = uint144(x)));\n  }\n\n  function toUint152(uint256 x) internal pure returns (uint152 y) {\n    _assertNonOverflow(x == (y = uint152(x)));\n  }\n\n  function toUint160(uint256 x) internal pure returns (uint160 y) {\n    _assertNonOverflow(x == (y = uint160(x)));\n  }\n\n  function toUint168(uint256 x) internal pure returns (uint168 y) {\n    _assertNonOverflow(x == (y = uint168(x)));\n  }\n\n  function toUint176(uint256 x) internal pure returns (uint176 y) {\n    _assertNonOverflow(x == (y = uint176(x)));\n  }\n\n  function toUint184(uint256 x) internal pure returns (uint184 y) {\n    _assertNonOverflow(x == (y = uint184(x)));\n  }\n\n  function toUint192(uint256 x) internal pure returns (uint192 y) {\n    _assertNonOverflow(x == (y = uint192(x)));\n  }\n\n  function toUint200(uint256 x) internal pure returns (uint200 y) {\n    _assertNonOverflow(x == (y = uint200(x)));\n  }\n\n  function toUint208(uint256 x) internal pure returns (uint208 y) {\n    _assertNonOverflow(x == (y = uint208(x)));\n  }\n\n  function toUint216(uint256 x) internal pure returns (uint216 y) {\n    _assertNonOverflow(x == (y = uint216(x)));\n  }\n\n  function toUint224(uint256 x) internal pure returns (uint224 y) {\n    _assertNonOverflow(x == (y = uint224(x)));\n  }\n\n  function toUint232(uint256 x) internal pure returns (uint232 y) {\n    _assertNonOverflow(x == (y = uint232(x)));\n  }\n\n  function toUint240(uint256 x) internal pure returns (uint240 y) {\n    _assertNonOverflow(x == (y = uint240(x)));\n  }\n\n  function toUint248(uint256 x) internal pure returns (uint248 y) {\n    _assertNonOverflow(x == (y = uint248(x)));\n  }\n}\n"},"src/access/BaseAccessControls.sol":{"content":"// SPDX-License-Identifier: Apache-2.0 WITH LicenseRef-Commons-Clause-1.0\npragma solidity ^0.8.20;\n\nimport '../libraries/BoolUtils.sol';\nimport '../libraries/MathUtils.sol';\nimport '../types/RoleProvider.sol';\nimport '../types/LenderStatus.sol';\nimport './IRoleProvider.sol';\nimport '../libraries/SafeCastLib.sol';\nimport './ProviderStructs.sol';\nimport './IRoleProviderFactory.sol';\n\nusing BoolUtils for bool;\nusing MathUtils for uint256;\nusing SafeCastLib for uint256;\n\ncontract BaseAccessControls {\n  // ========================================================================== //\n  //                                   Events                                   //\n  // ========================================================================== //\n\n  event RoleProviderUpdated(\n    address indexed providerAddress,\n    uint32 timeToLive,\n    uint24 pullProviderIndex,\n    uint24 pushProviderIndex\n  );\n  event RoleProviderAdded(\n    address indexed providerAddress,\n    uint32 timeToLive,\n    uint24 pullProviderIndex,\n    uint24 pushProviderIndex\n  );\n  event RoleProviderRemoved(\n    address indexed providerAddress,\n    uint24 pullProviderIndex,\n    uint24 pushProviderIndex\n  );\n  event AccountBlockedFromDeposits(address indexed accountAddress);\n  event AccountUnblockedFromDeposits(address indexed accountAddress);\n  event AccountAccessGranted(\n    address indexed providerAddress,\n    address indexed accountAddress,\n    uint32 credentialTimestamp\n  );\n  event AccountAccessRevoked(address indexed accountAddress);\n  event AccountMadeFirstDeposit(address indexed market, address indexed accountAddress);\n  event NameUpdated(string name);\n\n  // ========================================================================== //\n  //                                   Errors                                   //\n  // ========================================================================== //\n\n  error CallerNotBorrower();\n  error ProviderNotFound();\n  error ProviderCanNotReplaceCredential();\n  error ProviderCanNotRevokeCredential();\n  /// @dev Error thrown when a provider grants a credential that is already expired.\n  error GrantedCredentialExpired();\n  /// @dev Error thrown when a provider is called to validate a credential and the\n  ///      returndata can not be decoded as a uint.\n  error InvalidCredentialReturned();\n  /// @dev Error thrown when a user does not have a valid credential\n  error NotApprovedLender();\n  error InvalidArrayLength();\n  error CreateRoleProviderFailed();\n\n  // ========================================================================== //\n  //                                    State                                   //\n  // ========================================================================== //\n\n  address public immutable borrower;\n  // Name of the hooks instance\n  string public name;\n  // Credentials by lender address\n  mapping(address => LenderStatus) internal _lenderStatus;\n  // Whether an account is a known lender for a given market\n  mapping(address lender => mapping(address market => bool)) public isKnownLenderOnMarket;\n  RoleProvider[] internal _pullProviders;\n  RoleProvider[] internal _pushProviders;\n  mapping(address => RoleProvider) internal _roleProviders;\n\n  // ========================================================================== //\n  //                                  Modifiers                                 //\n  // ========================================================================== //\n\n  modifier onlyBorrower() {\n    if (msg.sender != borrower) revert CallerNotBorrower();\n    _;\n  }\n\n  // ========================================================================== //\n  //                                 Constructor                                //\n  // ========================================================================== //\n\n  constructor(address _borrower) {\n    borrower = _borrower;\n    // Allow deployer to grant roles with no expiry\n    RoleProvider borrowerProvider = encodeRoleProvider(\n      type(uint32).max,\n      _borrower,\n      NullProviderIndex,\n      0\n    );\n    _roleProviders[borrower] = borrowerProvider;\n    _pushProviders.push(borrowerProvider);\n  }\n\n  function _initialize(NameAndProviderInputs memory inputs) internal {\n    name = inputs.name;\n    for (uint256 i = 0; i < inputs.existingProviders.length; i++) {\n      ExistingProviderInputs memory provider = inputs.existingProviders[i];\n      _addRoleProvider(provider.providerAddress, provider.timeToLive);\n    }\n    IRoleProviderFactory providerFactory = IRoleProviderFactory(inputs.roleProviderFactory);\n    if (address(providerFactory) != address(0)) {\n      for (uint256 i; i < inputs.newProviderInputs.length; i++) {\n        CreateProviderInputs memory createProviderInputs = inputs.newProviderInputs[i];\n        _createRoleProvider(\n          providerFactory,\n          createProviderInputs.timeToLive,\n          createProviderInputs.providerFactoryCalldata\n        );\n      }\n    }\n  }\n\n  function setName(string memory _name) external onlyBorrower {\n    name = _name;\n    emit NameUpdated(_name);\n  }\n\n  // ========================================================================== //\n  //                             Provider management                            //\n  // ========================================================================== //\n\n  function createRoleProvider(\n    address providerFactory,\n    uint32 timeToLive,\n    bytes memory data\n  ) external onlyBorrower {\n    _createRoleProvider(IRoleProviderFactory(providerFactory), timeToLive, data);\n  }\n\n  function _createRoleProvider(\n    IRoleProviderFactory providerFactory,\n    uint32 timeToLive,\n    bytes memory data\n  ) internal {\n    address providerAddress = providerFactory.createRoleProvider(data);\n    if (providerAddress == address(0)) revert CreateRoleProviderFailed();\n    _addRoleProvider(providerAddress, timeToLive);\n  }\n\n  /**\n   * @dev Adds or updates a role provider that is able to grant user access.\n   *      If it is not already approved, it is added to `_roleProviders` and,\n   *      if the provider can refresh credentials, added to `pullProviders`.\n   *      If the provider is already approved, only updates `timeToLive`.\n   */\n  function addRoleProvider(address providerAddress, uint32 timeToLive) external onlyBorrower {\n    _addRoleProvider(providerAddress, timeToLive);\n  }\n\n  function _addRoleProvider(address providerAddress, uint32 timeToLive) internal {\n    RoleProvider provider = _roleProviders[providerAddress];\n    if (provider.isNull()) {\n      bool isPullProvider = IRoleProvider(providerAddress).isPullProvider();\n      (uint24 pullProviderIndex, uint24 pushProviderIndex) = isPullProvider\n        ? (uint24(_pullProviders.length), NullProviderIndex)\n        : (NullProviderIndex, uint24(_pushProviders.length));\n      // Role providers that are not pull providers have `pullProviderIndex` set to\n      // `NullProviderIndex` (max uint24) to indicate they do not refresh credentials.\n      provider = encodeRoleProvider(\n        timeToLive,\n        providerAddress,\n        pullProviderIndex,\n        pushProviderIndex\n      );\n      if (isPullProvider) {\n        _pullProviders.push(provider);\n      } else {\n        _pushProviders.push(provider);\n      }\n      emit RoleProviderAdded(providerAddress, timeToLive, pullProviderIndex, pushProviderIndex);\n    } else {\n      // If provider already exists, the only value that can be updated is the TTL\n      provider = provider.setTimeToLive(timeToLive);\n      uint24 pullProviderIndex = provider.pullProviderIndex();\n      uint24 pushProviderIndex = provider.pushProviderIndex();\n      if (pullProviderIndex != NullProviderIndex) {\n        _pullProviders[pullProviderIndex] = provider;\n      } else {\n        _pushProviders[pushProviderIndex] = provider;\n      }\n      emit RoleProviderUpdated(providerAddress, timeToLive, pullProviderIndex, pushProviderIndex);\n    }\n    // Update the provider in storage\n    _roleProviders[providerAddress] = provider;\n  }\n\n  /**\n   * @dev Removes a role provider from the `_roleProviders` mapping and, if it is a\n   *      pull provider, from the `_pullProviders` array.\n   */\n  function removeRoleProvider(address providerAddress) external onlyBorrower {\n    RoleProvider provider = _roleProviders[providerAddress];\n    if (provider.isNull()) revert ProviderNotFound();\n    // Remove the provider from `_roleProviders`\n    _roleProviders[providerAddress] = EmptyRoleProvider;\n    emit RoleProviderRemoved(\n      providerAddress,\n      provider.pullProviderIndex(),\n      provider.pushProviderIndex()\n    );\n    // If the provider is a pull provider, remove it from `_pullProviders`\n    if (provider.isPullProvider()) {\n      _removePullProvider(provider.pullProviderIndex());\n    } else {\n      _removePushProvider(provider.pushProviderIndex());\n    }\n  }\n\n  /**\n   * @dev Remove a pull provider from the `_pullProviders` array.\n   *      If the provider is not the last in the array, the last provider\n   *      is moved to the index of the provider being removed, so its index\n   *      must also be updated in the `_roleProviders` mapping.\n   */\n  function _removePullProvider(uint24 indexToRemove) internal {\n    // Get the last index in the array\n    uint256 lastIndex = _pullProviders.length - 1;\n    // If the index to remove is the last index, just pop the last element\n    if (indexToRemove == lastIndex) {\n      _pullProviders.pop();\n      return;\n    }\n    // If the index to remove is not the last index, move the last element\n    // to the index of the element being removed\n    RoleProvider lastProvider = _pullProviders[lastIndex].setPullProviderIndex(indexToRemove);\n    _pullProviders[indexToRemove] = lastProvider;\n    _pullProviders.pop();\n    address lastProviderAddress = lastProvider.providerAddress();\n    _roleProviders[lastProviderAddress] = lastProvider;\n    // Emit an event to notify that the provider's index has been updated\n    emit RoleProviderUpdated(\n      lastProviderAddress,\n      lastProvider.timeToLive(),\n      indexToRemove,\n      NullProviderIndex\n    );\n  }\n\n  /**\n   * @dev Remove a push provider from the `_pushProviders` array.\n   *      If the provider is not the last in the array, the last provider\n   *      is moved to the index of the provider being removed, so its index\n   *      must also be updated in the `_roleProviders` mapping.\n   */\n  function _removePushProvider(uint24 indexToRemove) internal {\n    // Get the last index in the array\n    uint256 lastIndex = _pushProviders.length - 1;\n    // If the index to remove is the last index, just pop the last element\n    if (indexToRemove == lastIndex) {\n      _pushProviders.pop();\n      return;\n    }\n    // If the index to remove is not the last index, move the last element\n    // to the index of the element being removed\n    RoleProvider lastProvider = _pushProviders[lastIndex].setPushProviderIndex(indexToRemove);\n    _pushProviders[indexToRemove] = lastProvider;\n    _pushProviders.pop();\n    address lastProviderAddress = lastProvider.providerAddress();\n    _roleProviders[lastProviderAddress] = lastProvider;\n    // Emit an event to notify that the provider's index has been updated\n    emit RoleProviderUpdated(\n      lastProviderAddress,\n      lastProvider.timeToLive(),\n      NullProviderIndex,\n      indexToRemove\n    );\n  }\n\n  // ========================================================================== //\n  //                              Provider queries                              //\n  // ========================================================================== //\n\n  function getRoleProvider(address providerAddress) external view returns (RoleProvider) {\n    return _roleProviders[providerAddress];\n  }\n\n  function getPullProviders() external view returns (RoleProvider[] memory) {\n    return _pullProviders;\n  }\n\n  function getPushProviders() external view returns (RoleProvider[] memory) {\n    return _pushProviders;\n  }\n\n  // ========================================================================== //\n  //                                Role queries                                //\n  // ========================================================================== //\n\n  function getPreviousLenderStatus(\n    address accountAddress\n  ) external view returns (LenderStatus memory status) {\n    status = _lenderStatus[accountAddress];\n  }\n\n  /**\n   * @dev Retrieves the current status of a lender, attempting to find a valid\n   *      credential if their current one is invalid or non-existent.\n   *\n   *      If the lender has an expired credential, will attempt to refresh it\n   *      with the previous provider if it is still supported.\n   *\n   *      If the lender has no credential, or one from a provider that is no longer\n   *      supported or will not refresh it, will loop over all providers to find\n   *      a valid credential.\n   */\n  function getLenderStatus(\n    address accountAddress\n  ) external view returns (LenderStatus memory status) {\n    status = _lenderStatus[accountAddress];\n\n    uint256 pullProviderIndexToSkip = type(uint256).max;\n\n    // Check if user has an existing credential\n    if (status.lastApprovalTimestamp > 0) {\n      RoleProvider provider = _roleProviders[status.lastProvider];\n      if (!provider.isNull()) {\n        // If credential is not expired and the provider is still\n        // supported, the lender has a valid credential.\n        if (status.credentialNotExpired(provider)) return status;\n\n        // If credential is expired but the provider is still supported and\n        // allows refreshing (i.e. it's a pull provider), try to refresh.\n        if (status.canRefresh) {\n          if (_tryGetCredential(status, provider, accountAddress)) {\n            return status;\n          }\n          // If refresh fails, provider should be skipped in the query loop\n          pullProviderIndexToSkip = provider.pullProviderIndex();\n        }\n      }\n      // If credential could not be refreshed or the provider is no longer\n      // supported, remove it\n      status.unsetCredential();\n    }\n\n    // Loop over all pull providers to find a valid role for the lender\n    if (_loopTryGetCredential(status, accountAddress, pullProviderIndexToSkip)) {\n      return status;\n    }\n  }\n\n  // ========================================================================== //\n  //                                Role actions                                //\n  // ========================================================================== //\n\n  /**\n   * @dev Grants a role to an account by updating the account's status.\n   *      Can only be called by an approved role provider.\n   *\n   *      If the account has an existing credential, it can only be updated if:\n   *      - the previous credential's provider is no longer supported, OR\n   *      - the caller is the previous role provider, OR\n   *      - the new expiry is later than the current expiry\n   */\n  function grantRole(address account, uint32 roleGrantedTimestamp) external {\n    RoleProvider callingProvider = _roleProviders[msg.sender];\n\n    if (callingProvider.isNull()) revert ProviderNotFound();\n\n    _grantRole(callingProvider, account, roleGrantedTimestamp);\n  }\n\n  /**\n   * @dev Grants roles to multiple accounts by updating their statuses.\n   *      Can only be called by an approved role provider.\n   *\n   *      If any account has an existing credential, it can only be updated if:\n   *      - the previous credential's provider is no longer supported, OR\n   *      - the caller is the previous role provider, OR\n   *      - the new expiry is later than the current expiry\n   */\n  function grantRoles(address[] memory accounts, uint32[] memory roleGrantedTimestamps) external {\n    RoleProvider callingProvider = _roleProviders[msg.sender];\n\n    if (callingProvider.isNull()) revert ProviderNotFound();\n\n    if (accounts.length != roleGrantedTimestamps.length) revert InvalidArrayLength();\n    for (uint256 i = 0; i < accounts.length; i++) {\n      _grantRole(callingProvider, accounts[i], roleGrantedTimestamps[i]);\n    }\n  }\n\n  function _grantRole(\n    RoleProvider callingProvider,\n    address account,\n    uint32 roleGrantedTimestamp\n  ) internal {\n    LenderStatus memory status = _lenderStatus[account];\n\n    uint256 newExpiry = callingProvider.calculateExpiry(roleGrantedTimestamp);\n\n    // Check if the new credential is still valid\n    if (newExpiry < block.timestamp) revert GrantedCredentialExpired();\n\n    // Check if the account has ever had a credential\n    if (status.hasCredential()) {\n      RoleProvider lastProvider = _roleProviders[status.lastProvider];\n\n      // Check if the provider that last granted access is still supported\n      if (!lastProvider.isNull()) {\n        uint256 oldExpiry = lastProvider.calculateExpiry(status.lastApprovalTimestamp);\n\n        // Can only update role if the caller is the previous role provider or the new\n        // expiry is greater than the previous expiry.\n        if (!((status.lastProvider == msg.sender).or(newExpiry > oldExpiry))) {\n          revert ProviderCanNotReplaceCredential();\n        }\n      }\n    }\n\n    _setCredentialAndEmitAccessGranted(status, callingProvider, account, roleGrantedTimestamp);\n  }\n\n  function revokeRole(address account) external {\n    LenderStatus memory status = _lenderStatus[account];\n    if (status.lastProvider != msg.sender) {\n      revert ProviderCanNotRevokeCredential();\n    }\n    status.unsetCredential();\n    _lenderStatus[account] = status;\n    emit AccountAccessRevoked(account);\n  }\n\n  function blockFromDeposits(address account) external onlyBorrower {\n    LenderStatus memory status = _lenderStatus[account];\n    if (status.hasCredential()) {\n      status.unsetCredential();\n      emit AccountAccessRevoked(account);\n    }\n    status.isBlockedFromDeposits = true;\n    _lenderStatus[account] = status;\n    emit AccountBlockedFromDeposits(account);\n  }\n\n  function unblockFromDeposits(address account) external onlyBorrower {\n    LenderStatus memory status = _lenderStatus[account];\n    status.isBlockedFromDeposits = false;\n    _lenderStatus[account] = status;\n    emit AccountUnblockedFromDeposits(account);\n  }\n\n  /**\n   * @dev Tries to pull an active credential for an account from a pull provider.\n   *      If one exists, updates the account in memory and returns true.\n   *\n   *      Note: Does not check that provider is a pull provider - should\n   *      only be called if that has already been checked.\n   */\n  function _tryGetCredential(\n    LenderStatus memory status,\n    RoleProvider provider,\n    address accountAddress\n  ) internal view returns (bool isApproved) {\n    // Query provider for user approval\n    address providerAddress = provider.providerAddress();\n\n    uint32 credentialTimestamp;\n    uint getCredentialSelector = uint32(IRoleProvider.getCredential.selector);\n    assembly {\n      mstore(0x00, getCredentialSelector)\n      mstore(0x20, accountAddress)\n      // Call the provider and check if the return data is valid\n      if and(gt(returndatasize(), 0x1f), staticcall(gas(), providerAddress, 0x1c, 0x24, 0, 0x20)) {\n        // If the return data is valid, set `credentialTimestamp` to the returned word\n        // with a uint32 mask applied\n        credentialTimestamp := and(mload(0), 0xffffffff)\n      }\n    }\n\n    // If the returned timestamp is null or greater than the current time, return false.\n    if (credentialTimestamp == 0 || credentialTimestamp > block.timestamp) {\n      return false;\n    }\n\n    // If credential is still valid, update credential\n    if (provider.calculateExpiry(credentialTimestamp) >= block.timestamp) {\n      // User is approved, update status with new expiry and last provider\n      status.setCredential(provider, credentialTimestamp);\n      return true;\n    }\n  }\n\n  function _readAddress(bytes calldata hooksData) internal pure returns (address providerAddress) {\n    assembly {\n      providerAddress := shr(96, calldataload(hooksData.offset))\n    }\n  }\n\n  /**\n   * @dev Uses the data added to the end of the base call to the market function to call\n   *      `validateCredential` on the selected provider. Returns false if the provider does not\n   *      exist, the call fails, or the credential is invalid. Only reverts if the call succeeds but\n   *      does not return the correct amount of data.\n   *\n   *      The calldata to the market function must have a suffix encoded as (address, bytes), where\n   *      the address is packed and the bytes do not contain an offset or length. For example, if\n   *      the market function were `fn(uint256 arg0)` and the user provided a 32 byte `accessToken`\n   *      for provider `provider0`, the calldata to the market would be:\n   *      [0:4] selector\n   *      [4:36] arg0\n   *      [36:58] provider0\n   *      [58:90] `accessToken`\n   */\n  function _tryValidateCredential(\n    LenderStatus memory status,\n    address accountAddress,\n    bytes calldata hooksData\n  ) internal returns (bool) {\n    uint validateSelector = uint32(IRoleProvider.validateCredential.selector);\n    address providerAddress = _readAddress(hooksData);\n    RoleProvider provider = _roleProviders[providerAddress];\n    if (provider.isNull()) return false;\n    uint credentialTimestamp;\n    uint invalidCredentialReturnedSelector = uint32(InvalidCredentialReturned.selector);\n    assembly {\n      // Get the offset to the extra data provided in the hooks call, after the provider.\n      let validateDataCalldataPointer := add(hooksData.offset, 0x14)\n      // Encode the call to `validateCredential(address account, bytes calldata data)`\n      let calldataPointer := mload(0x40)\n      // The selector is right aligned, so the real calldata buffer begins at calldataPointer + 28\n      mstore(calldataPointer, validateSelector)\n      mstore(add(calldataPointer, 0x20), accountAddress)\n      // Write the calldata offset to `data`\n      mstore(add(calldataPointer, 0x40), 0x40)\n      // Get length of the data segment in the hooks data\n      let dataLength := sub(hooksData.length, 0x14)\n      // Write the length of the calldata to `data`\n      mstore(add(calldataPointer, 0x60), dataLength)\n      // Copy the calldata to the buffer\n      calldatacopy(add(calldataPointer, 0x80), validateDataCalldataPointer, dataLength)\n      // Call the provider\n      if call(\n        gas(),\n        providerAddress,\n        0,\n        add(calldataPointer, 0x1c),\n        add(dataLength, 0x64),\n        0,\n        0x20\n      ) {\n        switch lt(returndatasize(), 0x20)\n        case 1 {\n          // If the returndata is invalid but the call succeeded, the call must throw\n          // because the validateCredential function is stateful and can have side effects.\n          mstore(0, invalidCredentialReturnedSelector)\n          revert(0x1c, 0x04)\n        }\n        default {\n          // If the return data is valid, set `credentialTimestamp` to the returned word\n          // with a uint32 mask applied\n          credentialTimestamp := and(mload(0), 0xffffffff)\n        }\n      }\n    }\n    // If the returned timestamp is null or greater than the current time, return false.\n    if (credentialTimestamp == 0 || credentialTimestamp > block.timestamp) {\n      return false;\n    }\n    // Check if the returned timestamp results in a valid expiry\n    if (provider.calculateExpiry(credentialTimestamp) >= block.timestamp) {\n      status.setCredential(provider, credentialTimestamp);\n      return true;\n    }\n  }\n\n  /// @dev Loops over all pull providers to find a valid credential for the lender.\n  function _loopTryGetCredential(\n    LenderStatus memory status,\n    address accountAddress,\n    uint256 pullProviderIndexToSkip\n  ) internal view returns (bool foundCredential) {\n    uint256 providerCount = _pullProviders.length;\n    for (uint256 i = 0; i < providerCount; i++) {\n      if (i == pullProviderIndexToSkip) continue;\n      RoleProvider provider = _pullProviders[i];\n      if (_tryGetCredential(status, provider, accountAddress)) return (true);\n    }\n  }\n\n  /**\n   * @dev Handles the hooks data passed to the contract.\n   *\n   *      If the hooks data is 20 bytes long, it is interpreted as a provider selection\n   *      to pull a credential from with `getCredential`.\n   *\n   *      If the hooks data is more than 20 bytes, it is interpreted as a request to use\n   *      `validateCredential`, where the first 20 bytes encode the provider address and\n   *      the remaining bytes are the encoded credential data to pass to the provider.\n   *\n   *      If the hooks data is less than 20 bytes, it is skipped.\n   *\n   * @param status Current lender status object, updated in memory if a credential is found\n   * @param accountAddress Address of the lender\n   * @param hooksData Bytes passed to the contract for provider selection\n   */\n  function _handleHooksData(\n    LenderStatus memory status,\n    address accountAddress,\n    bytes calldata hooksData\n  ) internal returns (bool validCredential) {\n    // Check if the hooks data only contains a provider address\n    if (hooksData.length == 20) {\n      // If the data contains only an address, attempt to query a credential from that provider\n      // if it exists and is a pull provider.\n      address providerAddress = _readAddress(hooksData);\n      RoleProvider provider = _roleProviders[providerAddress];\n      if (!provider.isNull() && provider.isPullProvider()) {\n        return _tryGetCredential(status, provider, accountAddress);\n      }\n    } else if (hooksData.length > 20) {\n      // If the data contains both an address and additional bytes, attempt to\n      // validate a credential from that provider\n      return _tryValidateCredential(status, accountAddress, hooksData);\n    }\n  }\n\n  /**\n   * @dev Internal function used to validate or update the status of a lender account for\n   *      hooks on restricted actions.\n   *\n   *     The function follows these steps until a valid credential is found:\n   *       1. Check if lender has an existing unexpired credential.\n   *       2. Check if `hooksData` was provided, and if so:\n   *         - If it contains only an address, call `getCredential` on that provider.\n   *         - If it contains an address and bytes, call `validateCredential` on that provider.\n   *       3. If lender has an existing expired credential, attempt to refresh it.\n   *       4. Loop over all pull providers to find a valid credential, excluding the last provider\n   *          if it failed to refresh.\n   *\n   * note: Does not update storage or emit an event, but is stateful because it can invoke\n   *       `validateCredential` on a provider.\n   */\n  function _tryValidateAccessInner(\n    LenderStatus memory status,\n    address accountAddress,\n    bytes calldata hooksData\n  ) internal returns (bool hasValidCredential, bool wasUpdated) {\n    // Get the last provider that granted the lender a credential, if any\n    RoleProvider lastProvider = status.hasCredential()\n      ? _roleProviders[status.lastProvider]\n      : EmptyRoleProvider;\n\n    // If the lender has an active credential and the last provider is still supported, return\n    if (!lastProvider.isNull() && status.credentialNotExpired(lastProvider)) {\n      return (true, false);\n    }\n\n    // Handle the calldata suffix, if any\n    if (_handleHooksData(status, accountAddress, hooksData)) {\n      return (true, true);\n    }\n\n    uint256 pullProviderIndexToSkip = type(uint256).max;\n\n    // If lender has an expired credential from a pull provider, attempt to refresh it\n    if (!lastProvider.isNull() && status.canRefresh) {\n      if (_tryGetCredential(status, lastProvider, accountAddress)) {\n        return (true, true);\n      }\n      // If refresh fails, provider should be skipped in the query loop\n      pullProviderIndexToSkip = lastProvider.pullProviderIndex();\n    }\n\n    // Loop over all pull providers to find a valid role for the lender\n    if (_loopTryGetCredential(status, accountAddress, pullProviderIndexToSkip)) {\n      return (true, true);\n    }\n\n    // If there was previously a credential and no valid credential could be found,\n    // unset the credential.\n    if (status.hasCredential()) {\n      status.unsetCredential();\n      wasUpdated = true;\n    }\n  }\n\n  function _tryValidateAccess(\n    LenderStatus memory status,\n    address accountAddress,\n    bytes calldata hooksData\n  ) internal returns (bool hasValidCredential) {\n    bool wasUpdated;\n    (hasValidCredential, wasUpdated) = _tryValidateAccessInner(status, accountAddress, hooksData);\n    _writeLenderStatus(status, accountAddress, hasValidCredential, wasUpdated, false);\n  }\n\n  /**\n   * @dev Updates a lender's status in storage and emits an event when a\n   *      credential is granted or revoked, or when the lender is marked\n   *      as a known lender.\n   */\n  function _writeLenderStatus(\n    LenderStatus memory status,\n    address accountAddress,\n    bool hasValidCredential,\n    bool wasUpdated,\n    bool canSetKnownLender\n  ) internal {\n    if (wasUpdated) {\n      if (hasValidCredential) {\n        emit AccountAccessGranted(\n          status.lastProvider,\n          accountAddress,\n          status.lastApprovalTimestamp\n        );\n      } else {\n        emit AccountAccessRevoked(accountAddress);\n      }\n    }\n    // Mark account as a known lender if they have a valid credential, are not\n    // already known, and the function counts as a deposit.\n    if (\n      canSetKnownLender.and(hasValidCredential).and(\n        !isKnownLenderOnMarket[accountAddress][msg.sender]\n      )\n    ) {\n      isKnownLenderOnMarket[accountAddress][msg.sender] = true;\n      emit AccountMadeFirstDeposit(msg.sender, accountAddress);\n    }\n\n    // Write the account's status to storage if it was updated\n    if (wasUpdated) _lenderStatus[accountAddress] = status;\n  }\n\n  function _setCredentialAndEmitAccessGranted(\n    LenderStatus memory status,\n    RoleProvider provider,\n    address accountAddress,\n    uint32 credentialTimestamp\n  ) internal {\n    // Update the account's status with the new credential in memory\n    status.setCredential(provider, credentialTimestamp);\n    // Update the account's status in storage\n    _lenderStatus[accountAddress] = status;\n    emit AccountAccessGranted(provider.providerAddress(), accountAddress, credentialTimestamp);\n  }\n}\n"},"src/libraries/LibERC20.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport './StringQuery.sol';\n\n/// @notice Safe ERC20 library\n/// @author d1ll0n\n/// @notice Changes from solady:\n///   - Removed Permit2 and ETH functions\n///   - `balanceOf(address)` reverts if the call fails or does not return >=32 bytes\n///   - Added queries for `name`, `symbol`, `decimals`\n///   - Set name to LibERC20 as it has queries unrelated to transfers and ETH functions were removed\n/// @author Modified from Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibERC20.sol)\n/// @author Previously modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/LibERC20.sol)\n///\n/// @dev Note:\n/// - For ERC20s, this implementation won't check that a token has code,\n///   responsibility is delegated to the caller.\nlibrary LibERC20 {\n  /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n  /*                       CUSTOM ERRORS                        */\n  /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n  /// @dev The ERC20 `transferFrom` has failed.\n  error TransferFromFailed();\n\n  /// @dev The ERC20 `transfer` has failed.\n  error TransferFailed();\n\n  /// @dev The ERC20 `balanceOf` call has failed.\n  error BalanceOfFailed();\n\n  /// @dev The ERC20 `name` call has failed.\n  error NameFailed();\n\n  /// @dev The ERC20 `symbol` call has failed.\n  error SymbolFailed();\n\n  /// @dev The ERC20 `decimals` call has failed.\n  error DecimalsFailed();\n\n  /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n  /*                      ERC20 OPERATIONS                      */\n  /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n  /// @dev Sends `amount` of ERC20 `token` from `from` to `to`.\n  /// Reverts upon failure.\n  ///\n  /// The `from` account must have at least `amount` approved for\n  /// the current contract to manage.\n  function safeTransferFrom(address token, address from, address to, uint256 amount) internal {\n    /// @solidity memory-safe-assembly\n    assembly {\n      let m := mload(0x40) // Cache the free memory pointer.\n      mstore(0x60, amount) // Store the `amount` argument.\n      mstore(0x40, to) // Store the `to` argument.\n      mstore(0x2c, shl(96, from)) // Store the `from` argument.\n      mstore(0x0c, 0x23b872dd000000000000000000000000) // `transferFrom(address,address,uint256)`.\n      // Perform the transfer, reverting upon failure.\n      if iszero(\n        and(\n          // The arguments of `and` are evaluated from right to left.\n          or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\n          call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\n        )\n      ) {\n        mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\n        revert(0x1c, 0x04)\n      }\n      mstore(0x60, 0) // Restore the zero slot to zero.\n      mstore(0x40, m) // Restore the free memory pointer.\n    }\n  }\n\n  /// @dev Sends `amount` of ERC20 `token` from the current contract to `to`.\n  /// Reverts upon failure.\n  function safeTransfer(address token, address to, uint256 amount) internal {\n    /// @solidity memory-safe-assembly\n    assembly {\n      mstore(0x14, to) // Store the `to` argument.\n      mstore(0x34, amount) // Store the `amount` argument.\n      mstore(0x00, 0xa9059cbb000000000000000000000000) // `transfer(address,uint256)`.\n      // Perform the transfer, reverting upon failure.\n      if iszero(\n        and(\n          // The arguments of `and` are evaluated from right to left.\n          or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\n          call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\n        )\n      ) {\n        mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\n        revert(0x1c, 0x04)\n      }\n      mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\n    }\n  }\n\n  /// @dev Sends all of ERC20 `token` from the current contract to `to`.\n  /// Reverts upon failure.\n  function safeTransferAll(address token, address to) internal returns (uint256 amount) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      mstore(0x00, 0x70a08231) // Store the function selector of `balanceOf(address)`.\n      mstore(0x20, address()) // Store the address of the current contract.\n      // Read the balance, reverting upon failure.\n      if iszero(\n        and(\n          // The arguments of `and` are evaluated from right to left.\n          gt(returndatasize(), 0x1f), // At least 32 bytes returned.\n          staticcall(gas(), token, 0x1c, 0x24, 0x34, 0x20)\n        )\n      ) {\n        mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\n        revert(0x1c, 0x04)\n      }\n      mstore(0x14, to) // Store the `to` argument.\n      amount := mload(0x34) // The `amount` is already at 0x34. We'll need to return it.\n      mstore(0x00, 0xa9059cbb000000000000000000000000) // `transfer(address,uint256)`.\n      // Perform the transfer, reverting upon failure.\n      if iszero(\n        and(\n          // The arguments of `and` are evaluated from right to left.\n          or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\n          call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\n        )\n      ) {\n        mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\n        revert(0x1c, 0x04)\n      }\n      mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\n    }\n  }\n\n  /// @dev Returns the amount of ERC20 `token` owned by `account`.\n  /// Reverts if the call to `balanceOf` reverts or returns less than 32 bytes.\n  function balanceOf(address token, address account) internal view returns (uint256 amount) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      mstore(0x00, 0x70a08231) // Store the function selector of `balanceOf(address)`.\n      mstore(0x20, account) // Store the `account` argument.\n      // Read the balance, reverting upon failure.\n      if iszero(\n        and(\n          // The arguments of `and` are evaluated from right to left.\n          gt(returndatasize(), 0x1f), // At least 32 bytes returned.\n          staticcall(gas(), token, 0x1c, 0x24, 0x00, 0x20)\n        )\n      ) {\n        mstore(0x00, 0x4963f6d5) // `BalanceOfFailed()`.\n        revert(0x1c, 0x04)\n      }\n      amount := mload(0x00)\n    }\n  }\n\n  /// @dev Returns the `decimals` of ERC20 `token`.\n  /// Reverts if the call to `decimals` reverts or returns less than 32 bytes.\n  function decimals(address token) internal view returns (uint8 _decimals) {\n    assembly {\n      // Write selector for `decimals()` to the end of the first word\n      // of scratch space.\n      mstore(0, 0x313ce567)\n      // Call `asset.decimals()`, writing up to 32 bytes of returndata\n      // to scratch space, overwriting the calldata used for the call.\n      // Reverts if the call fails, does not return exactly 32 bytes, or the returndata\n      // exceeds 8 bits.\n      if iszero(\n        and(\n          and(eq(returndatasize(), 0x20), lt(mload(0), 0x100)),\n          staticcall(gas(), token, 0x1c, 0x04, 0, 0x20)\n        )\n      ) {\n        mstore(0x00, 0x3394d170) // `DecimalsFailed()`.\n        revert(0x1c, 0x04)\n      }\n      // Read the return value from scratch space\n      _decimals := mload(0)\n    }\n  }\n\n  /// @dev Returns the `name` of ERC20 `token`.\n  /// Reverts if the call to `name` reverts or returns a value which is neither\n  /// a bytes32 string nor a valid ABI-encoded string.\n  function name(address token) internal view returns (string memory) {\n    // The `name` function selector is 0x06fdde03.\n    // The `NameFailed` error selector is 0x2ed09f54.\n    return queryStringOrBytes32AsString(token, 0x06fdde03, 0x2ed09f54);\n  }\n\n  /// @dev Returns the `symbol` of ERC20 `token`.\n  /// Reverts if the call to `symbol` reverts or returns a value which is neither\n  /// a bytes32 string nor a valid ABI-encoded string.\n  function symbol(address token) internal view returns (string memory) {\n    // The `symbol` function selector is 0x95d89b41.\n    // The `SymbolFailed` error selector is 0x3ddcc60a.\n    return queryStringOrBytes32AsString(token, 0x95d89b41, 0x3ddcc60a);\n  }\n}\n"},"src/interfaces/IWildcatArchController.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\ninterface IWildcatArchController {\n  error NotMarketFactory();\n\n  error NotControllerFactory();\n\n  function owner() external view returns (address);\n\n  // ========================================================================== //\n  //                               SphereX Config                               //\n  // ========================================================================== //\n\n  event ChangedSpherexOperator(address oldSphereXAdmin, address newSphereXAdmin);\n\n  event ChangedSpherexEngineAddress(address oldEngineAddress, address newEngineAddress);\n\n  event SpherexAdminTransferStarted(address currentAdmin, address pendingAdmin);\n\n  event SpherexAdminTransferCompleted(address oldAdmin, address newAdmin);\n\n  event NewAllowedSenderOnchain(address sender);\n\n  error SphereXOperatorRequired();\n\n  error SphereXAdminRequired();\n\n  error SphereXOperatorOrAdminRequired();\n\n  error SphereXNotPendingAdmin();\n\n  error SphereXNotEngine();\n\n  function pendingSphereXAdmin() external view returns (address);\n\n  function sphereXAdmin() external view returns (address);\n\n  function sphereXOperator() external view returns (address);\n\n  function sphereXEngine() external view returns (address);\n\n  function transferSphereXAdminRole(address newAdmin) external virtual;\n\n  function acceptSphereXAdminRole() external virtual;\n\n  function changeSphereXOperator(address newSphereXOperator) external;\n\n  function changeSphereXEngine(address newSphereXEngine) external;\n\n  // ========================================================================== //\n  //                         Controller Factory Registry                        //\n  // ========================================================================== //\n\n  event ControllerFactoryAdded(address);\n\n  event ControllerFactoryRemoved(address);\n\n  function getRegisteredControllerFactories() external view returns (address[] memory);\n\n  function getRegisteredControllerFactories(\n    uint256 start,\n    uint256 end\n  ) external view returns (address[] memory);\n\n  function getRegisteredControllerFactoriesCount() external view returns (uint256);\n\n  function isRegisteredControllerFactory(address factory) external view returns (bool);\n\n  function registerControllerFactory(address factory) external;\n\n  function removeControllerFactory(address factory) external;\n\n  // ========================================================================== //\n  //                             Controller Registry                            //\n  // ========================================================================== //\n\n  event ControllerAdded(address, address);\n\n  event ControllerRemoved(address);\n\n  function getRegisteredControllers() external view returns (address[] memory);\n\n  function getRegisteredControllers(\n    uint256 start,\n    uint256 end\n  ) external view returns (address[] memory);\n\n  function getRegisteredControllersCount() external view returns (uint256);\n\n  function isRegisteredController(address controller) external view returns (bool);\n\n  function registerController(address controller) external;\n\n  function removeController(address controller) external;\n\n  // ========================================================================== //\n  //                             Borrowers Registry                             //\n  // ========================================================================== //\n\n  event BorrowerAdded(address);\n\n  event BorrowerRemoved(address);\n\n  function getRegisteredBorrowers() external view returns (address[] memory);\n\n  function getRegisteredBorrowers(\n    uint256 start,\n    uint256 end\n  ) external view returns (address[] memory);\n\n  function getRegisteredBorrowersCount() external view returns (uint256);\n\n  function isRegisteredBorrower(address borrower) external view returns (bool);\n\n  function registerBorrower(address borrower) external;\n\n  function removeBorrower(address borrower) external;\n\n  // ========================================================================== //\n  //                          Asset Blacklist Registry                          //\n  // ========================================================================== //\n\n  event AssetPermitted();\n\n  event AssetBlacklisted();\n\n  function addBlacklist(address asset) external;\n\n  function removeBlacklist(address asset) external;\n\n  function isBlacklistedAsset(address asset) external view returns (bool);\n\n  function getBlacklistedAssets() external view returns (address[] memory);\n\n  function getBlacklistedAssets(\n    uint256 start,\n    uint256 end\n  ) external view returns (address[] memory);\n\n  function getBlacklistedAssetsCount() external view returns (uint256);\n\n  // ========================================================================== //\n  //                               Markets Registry                             //\n  // ========================================================================== //\n\n  event MarketAdded(address, address);\n\n  event MarketRemoved(address);\n\n  function getRegisteredMarkets() external view returns (address[] memory);\n\n  function getRegisteredMarkets(\n    uint256 start,\n    uint256 end\n  ) external view returns (address[] memory);\n\n  function getRegisteredMarketsCount() external view returns (uint256);\n\n  function isRegisteredMarket(address market) external view returns (bool);\n\n  function registerMarket(address market) external;\n\n  function removeMarket(address market) external;\n}\n"},"src/libraries/LibStoredInitCode.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.24;\n\nlibrary LibStoredInitCode {\n  error InitCodeDeploymentFailed();\n  error DeploymentFailed();\n\n  function deployInitCode(bytes memory data) internal returns (address initCodeStorage) {\n    assembly {\n      let size := mload(data)\n      let createSize := add(size, 0x0b)\n      // Prefix Code\n      //\n      // Has trailing STOP instruction so the deployed data\n      // can not be executed as a smart contract.\n      //\n      // Instruction                | Stack\n      // ----------------------------------------------------\n      // PUSH2 size                 | size                  |\n      // PUSH0                      | 0, size               |\n      // DUP2                       | size, 0, size         |\n      // PUSH1 10 (offset to STOP)  | 10, size, 0, size     |\n      // PUSH0                      | 0, 10, size, 0, size  |\n      // CODECOPY                   | 0, size               |\n      // RETURN                     |                       |\n      // STOP                       |                       |\n      // ----------------------------------------------------\n\n      // Shift (size + 1) to position it in front of the PUSH2 instruction.\n      // Reuse `data.length` memory for the create prefix to avoid\n      // unnecessary memory allocation.\n      mstore(data, or(shl(64, add(size, 1)), 0x6100005f81600a5f39f300))\n      // Deploy the code storage\n      initCodeStorage := create(0, add(data, 21), createSize)\n      // if (initCodeStorage == address(0)) revert InitCodeDeploymentFailed();\n      if iszero(initCodeStorage) {\n        mstore(0, 0x11c8c3c0)\n        revert(0x1c, 0x04)\n      }\n      // Restore `data.length`\n      mstore(data, size)\n    }\n  }\n\n  /**\n   * @dev Returns the create2 prefix for a given deployer address.\n   *      Equivalent to `uint256(uint160(deployer)) | (0xff << 160)`\n   */\n  function getCreate2Prefix(address deployer) internal pure returns (uint256 create2Prefix) {\n    assembly {\n      create2Prefix := or(deployer, 0xff0000000000000000000000000000000000000000)\n    }\n  }\n\n  function calculateCreate2Address(\n    uint256 create2Prefix,\n    bytes32 salt,\n    uint256 initCodeHash\n  ) internal pure returns (address create2Address) {\n    assembly {\n      // Cache the free memory pointer so it can be restored at the end\n      let freeMemoryPointer := mload(0x40)\n\n      // Write 0xff + address to bytes 11:32\n      mstore(0x00, create2Prefix)\n\n      // Write salt to bytes 32:64\n      mstore(0x20, salt)\n\n      // Write initcode hash to bytes 64:96\n      mstore(0x40, initCodeHash)\n\n      // Calculate create2 address\n      create2Address := and(keccak256(0x0b, 0x55), 0xffffffffffffffffffffffffffffffffffffffff)\n\n      // Restore the free memory pointer\n      mstore(0x40, freeMemoryPointer)\n    }\n  }\n\n  function createWithStoredInitCode(address initCodeStorage) internal returns (address deployment) {\n    deployment = createWithStoredInitCode(initCodeStorage, 0);\n  }\n\n  function createWithStoredInitCode(\n    address initCodeStorage,\n    uint256 value\n  ) internal returns (address deployment) {\n    assembly {\n      let initCodePointer := mload(0x40)\n      let initCodeSize := sub(extcodesize(initCodeStorage), 1)\n      extcodecopy(initCodeStorage, initCodePointer, 1, initCodeSize)\n      deployment := create(value, initCodePointer, initCodeSize)\n      if iszero(deployment) {\n        mstore(0x00, 0x30116425) // DeploymentFailed()\n        revert(0x1c, 0x04)\n      }\n    }\n  }\n\n  function create2WithStoredInitCode(\n    address initCodeStorage,\n    bytes32 salt\n  ) internal returns (address deployment) {\n    deployment = create2WithStoredInitCode(initCodeStorage, salt, 0);\n  }\n\n  function create2WithStoredInitCode(\n    address initCodeStorage,\n    bytes32 salt,\n    uint256 value\n  ) internal returns (address deployment) {\n    assembly {\n      let initCodePointer := mload(0x40)\n      let initCodeSize := sub(extcodesize(initCodeStorage), 1)\n      extcodecopy(initCodeStorage, initCodePointer, 1, initCodeSize)\n      deployment := create2(value, initCodePointer, initCodeSize, salt)\n      if iszero(deployment) {\n        mstore(0x00, 0x30116425) // DeploymentFailed()\n        revert(0x1c, 0x04)\n      }\n    }\n  }\n\n  function create2WithStoredInitCode(\n    address initCodeStorage,\n    bytes32 salt,\n    uint256 value,\n    bytes memory constructorArgs\n  ) internal returns (address deployment) {\n    assembly {\n      let initCodePointer := mload(0x40)\n      let initCodeSize := sub(extcodesize(initCodeStorage), 1)\n      // Copy code from target address to memory starting at byte 1\n      extcodecopy(initCodeStorage, initCodePointer, 1, initCodeSize)\n      // Copy constructor args from memory to initcode\n      let constructorArgsSize := mload(constructorArgs)\n      mcopy(add(initCodePointer, initCodeSize), add(constructorArgs, 0x20), constructorArgsSize)\n      let initCodeSizeWithArgs := add(initCodeSize, constructorArgsSize)\n      deployment := create2(value, initCodePointer, initCodeSizeWithArgs, salt)\n      if iszero(deployment) {\n        mstore(0x00, 0x30116425) // DeploymentFailed()\n        revert(0x1c, 0x04)\n      }\n    }\n  }\n\n  function create2WithStoredInitCode(\n    address initCodeStorage,\n    bytes32 salt,\n    bytes memory constructorArgs\n  ) internal returns (address deployment) {\n    return create2WithStoredInitCode(initCodeStorage, salt, 0, constructorArgs);\n  }\n\n  function create2WithStoredInitCodeCD(\n    address initCodeStorage,\n    bytes32 salt,\n    uint256 value,\n    bytes calldata constructorArgs\n  ) internal returns (address deployment) {\n    assembly {\n      let initCodePointer := mload(0x40)\n      let initCodeSize := sub(extcodesize(initCodeStorage), 1)\n      // Copy code from target address to memory starting at byte 1\n      extcodecopy(initCodeStorage, initCodePointer, 1, initCodeSize)\n      // Copy constructor args from calldata to end of initcode\n      let constructorArgsSize := constructorArgs.length\n      calldatacopy(add(initCodePointer, initCodeSize), constructorArgs.offset, constructorArgsSize)\n      let initCodeSizeWithArgs := add(initCodeSize, constructorArgsSize)\n      deployment := create2(value, initCodePointer, initCodeSizeWithArgs, salt)\n      if iszero(deployment) {\n        mstore(0x00, 0x30116425) // DeploymentFailed()\n        revert(0x1c, 0x04)\n      }\n    }\n  }\n\n  function create2WithStoredInitCodeCD(\n    address initCodeStorage,\n    bytes32 salt,\n    bytes calldata constructorArgs\n  ) internal returns (address deployment) {\n    return create2WithStoredInitCodeCD(initCodeStorage, salt, 0, constructorArgs);\n  }\n}\n"},"src/ReentrancyGuard.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.20;\n\n/// @dev Selector for `error NoReentrantCalls()`\nuint256 constant NoReentrantCalls_ErrorSelector = 0x7fa8a987;\n\nuint256 constant _REENTRANCY_GUARD_SLOT = 0x929eee14;\n\n/**\n * @title ReentrancyGuard\n * @author d1ll0n\n * @notice Changes from original:\n *   - Removed the checks for whether tstore is supported.\n * @author Modified from Seaport contract by 0age (https://github.com/ProjectOpenSea/seaport-1.6)\n *\n * @notice ReentrancyGuard contains a transient storage variable and related\n *         functionality for protecting against reentrancy.\n */\ncontract ReentrancyGuard {\n  /**\n   * @dev Revert with an error when a caller attempts to reenter a protected function.\n   *\n   *      Note: Only defined for the sake of the interface and readability - the\n   *      definition is not directly referenced in the contract code.\n   */\n  error NoReentrantCalls();\n\n  uint256 private constant _NOT_ENTERED = 0;\n  uint256 private constant _ENTERED = 1;\n\n  /**\n   * @dev Reentrancy guard for state-changing functions.\n   *      Reverts if the reentrancy guard is currently set; otherwise, sets\n   *      the reentrancy guard, executes the function body, then clears the\n   *      reentrancy guard.\n   */\n  modifier nonReentrant() {\n    _setReentrancyGuard();\n    _;\n    _clearReentrancyGuard();\n  }\n\n  /**\n   * @dev Reentrancy guard for view functions.\n   *      Reverts if the reentrancy guard is currently set.\n   */\n  modifier nonReentrantView() {\n    _assertNonReentrant();\n    _;\n  }\n\n  /**\n   * @dev Internal function to ensure that a sentinel value for the reentrancy\n   *      guard is not currently set and, if not, to set a sentinel value for\n   *      the reentrancy guard.\n   */\n  function _setReentrancyGuard() internal {\n    assembly {\n      // Retrieve the current value of the reentrancy guard slot.\n      let _reentrancyGuard := tload(_REENTRANCY_GUARD_SLOT)\n\n      // Ensure that the reentrancy guard is not already set.\n      // Equivalent to `if (_reentrancyGuard != _NOT_ENTERED) revert NoReentrantCalls();`\n      if _reentrancyGuard {\n        mstore(0, NoReentrantCalls_ErrorSelector)\n        revert(0x1c, 0x04)\n      }\n\n      // Set the reentrancy guard.\n      // Equivalent to `_reentrancyGuard = _ENTERED;`\n      tstore(_REENTRANCY_GUARD_SLOT, _ENTERED)\n    }\n  }\n\n  /**\n   * @dev Internal function to unset the reentrancy guard sentinel value.\n   */\n  function _clearReentrancyGuard() internal {\n    assembly {\n      // Equivalent to `_reentrancyGuard = _NOT_ENTERED;`\n      tstore(_REENTRANCY_GUARD_SLOT, _NOT_ENTERED)\n    }\n  }\n\n  /**\n   * @dev Internal view function to ensure that a sentinel value for the\n   *         reentrancy guard is not currently set.\n   */\n  function _assertNonReentrant() internal view {\n    assembly {\n      // Ensure that the reentrancy guard is not currently set.\n      // Equivalent to `if (_reentrancyGuard != _NOT_ENTERED) revert NoReentrantCalls();`\n      if tload(_REENTRANCY_GUARD_SLOT) {\n        mstore(0, NoReentrantCalls_ErrorSelector)\n        revert(0x1c, 0x04)\n      }\n    }\n  }\n}\n"},"src/IHooksFactory.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport './access/IHooks.sol';\nimport './interfaces/WildcatStructsAndEnums.sol';\n\nstruct HooksTemplate {\n  /// @dev Asset used to pay origination fee\n  address originationFeeAsset;\n  /// @dev Amount of `originationFeeAsset` paid to deploy a new market using\n  ///      an instance of this template.\n  uint80 originationFeeAmount;\n  /// @dev Basis points paid on interest for markets deployed using hooks\n  ///      based on this template\n  uint16 protocolFeeBips;\n  /// @dev Whether the template exists\n  bool exists;\n  /// @dev Whether the template is enabled\n  bool enabled;\n  /// @dev Index of the template address in the array of hooks templates\n  uint24 index;\n  /// @dev Address to pay origination and interest fees\n  address feeRecipient;\n  /// @dev Name of the template\n  string name;\n}\n\ninterface IHooksFactoryEventsAndErrors {\n  error FeeMismatch();\n  error NotApprovedBorrower();\n  error HooksTemplateNotFound();\n  error HooksTemplateNotAvailable();\n  error HooksTemplateAlreadyExists();\n  error DeploymentFailed();\n  error HooksInstanceNotFound();\n  error CallerNotArchControllerOwner();\n  error InvalidFeeConfiguration();\n  error SaltDoesNotContainSender();\n  error MarketAlreadyExists();\n  error HooksInstanceAlreadyExists();\n  error NameOrSymbolTooLong();\n  error AssetBlacklisted();\n  error SetProtocolFeeBipsFailed();\n\n  event HooksInstanceDeployed(address hooksInstance, address hooksTemplate);\n  event HooksTemplateAdded(\n    address hooksTemplate,\n    string name,\n    address feeRecipient,\n    address originationFeeAsset,\n    uint80 originationFeeAmount,\n    uint16 protocolFeeBips\n  );\n  event HooksTemplateDisabled(address hooksTemplate);\n  event HooksTemplateFeesUpdated(\n    address hooksTemplate,\n    address feeRecipient,\n    address originationFeeAsset,\n    uint80 originationFeeAmount,\n    uint16 protocolFeeBips\n  );\n\n  event MarketDeployed(\n    address indexed hooksTemplate,\n    address indexed market,\n    string name,\n    string symbol,\n    address asset,\n    uint256 maxTotalSupply,\n    uint256 annualInterestBips,\n    uint256 delinquencyFeeBips,\n    uint256 withdrawalBatchDuration,\n    uint256 reserveRatioBips,\n    uint256 delinquencyGracePeriod,\n    HooksConfig hooks\n  );\n}\n\ninterface IHooksFactory is IHooksFactoryEventsAndErrors {\n  function archController() external view returns (address);\n\n  function sanctionsSentinel() external view returns (address);\n\n  function marketInitCodeStorage() external view returns (address);\n\n  function marketInitCodeHash() external view returns (uint256);\n\n  /// @dev Set-up function to register the factory as a controller with the arch-controller.\n  ///      This enables the factory to register new markets.\n  function registerWithArchController() external;\n\n  function name() external view returns (string memory);\n\n  // ========================================================================== //\n  //                               Hooks Templates                              //\n  // ========================================================================== //\n\n  /// @dev Add a hooks template that stores the initcode for the template.\n  ///\n  ///      On success:\n  ///      - Emits `HooksTemplateAdded` on success.\n  ///      - Adds the template to the list of templates.\n  ///      - Creates `HooksTemplate` struct with the given parameters mapped to the template address.\n  ///\n  ///      Reverts if:\n  ///      - The caller is not the owner of the arch-controller.\n  ///      - The template already exists.\n  ///      - The fee settings are invalid.\n  function addHooksTemplate(\n    address hooksTemplate,\n    string calldata name,\n    address feeRecipient,\n    address originationFeeAsset,\n    uint80 originationFeeAmount,\n    uint16 protocolFeeBips\n  ) external;\n\n  /// @dev Update the fees for a hooks template.\n  ///\n  ///      On success:\n  ///      - Emits `HooksTemplateFeesUpdated` on success.\n  ///      - Updates the fees for the `HooksTemplate` struct mapped to the template address.\n  ///\n  ///      Reverts if:\n  ///      - The caller is not the owner of the arch-controller.\n  ///      - The template does not exist.\n  ///      - The fee settings are invalid.\n  function updateHooksTemplateFees(\n    address hooksTemplate,\n    address feeRecipient,\n    address originationFeeAsset,\n    uint80 originationFeeAmount,\n    uint16 protocolFeeBips\n  ) external;\n\n  /// @dev Disable a hooks template.\n  ///\n  ///      On success:\n  ///      - Emits `HooksTemplateDisabled` on success.\n  ///      - Disables the `HooksTemplate` struct mapped to the template address.\n  ///\n  ///      Reverts if:\n  ///      - The caller is not the owner of the arch-controller.\n  ///      - The template does not exist.\n  function disableHooksTemplate(address hooksTemplate) external;\n\n  /// @dev Get the name and fee configuration for an approved hooks template.\n  function getHooksTemplateDetails(\n    address hooksTemplate\n  ) external view returns (HooksTemplate memory);\n\n  /// @dev Check if a hooks template is approved.\n  function isHooksTemplate(address hooksTemplate) external view returns (bool);\n\n  /// @dev Get the list of approved hooks templates.\n  function getHooksTemplates() external view returns (address[] memory);\n\n  function getHooksTemplates(\n    uint256 start,\n    uint256 end\n  ) external view returns (address[] memory arr);\n\n  function getHooksTemplatesCount() external view returns (uint256);\n\n  function getMarketsForHooksTemplate(\n    address hooksTemplate\n  ) external view returns (address[] memory);\n\n  function getMarketsForHooksTemplate(\n    address hooksTemplate,\n    uint256 start,\n    uint256 end\n  ) external view returns (address[] memory arr);\n\n  function getMarketsForHooksTemplateCount(address hooksTemplate) external view returns (uint256);\n\n  // ========================================================================== //\n  //                               Hooks Instances                              //\n  // ========================================================================== //\n\n  /// @dev Deploy a hooks instance for an approved template with constructor args.\n  ///\n  ///      On success:\n  ///      - Emits `HooksInstanceDeployed`.\n  ///      - Deploys a new hooks instance with the given templates and constructor args.\n  ///      - Maps the hooks instance to the template address.\n  ///\n  ///      Reverts if:\n  ///      - The caller is not an approved borrower.\n  ///      - The template does not exist.\n  ///      - The template is not enabled.\n  ///      - The deployment fails.\n  function deployHooksInstance(\n    address hooksTemplate,\n    bytes calldata constructorArgs\n  ) external returns (address hooksDeployment);\n\n  function getHooksInstancesForBorrower(address borrower) external view returns (address[] memory);\n\n  function getHooksInstancesCountForBorrower(address borrower) external view returns (uint256);\n\n  /// @dev Check if a hooks instance was deployed by the factory.\n  function isHooksInstance(address hooks) external view returns (bool);\n\n  /// @dev Get the template that was used to deploy a hooks instance.\n  function getHooksTemplateForInstance(address hooks) external view returns (address);\n\n  // ========================================================================== //\n  //                                   Markets                                  //\n  // ========================================================================== //\n  function getMarketsForHooksInstance(\n    address hooksInstance\n  ) external view returns (address[] memory);\n\n  function getMarketsForHooksInstance(\n    address hooksInstance,\n    uint256 start,\n    uint256 len\n  ) external view returns (address[] memory arr);\n\n  function getMarketsForHooksInstanceCount(address hooksInstance) external view returns (uint256);\n\n  /// @dev Get the temporarily stored market parameters for a market that is\n  ///      currently being deployed.\n  function getMarketParameters() external view returns (MarketParameters memory parameters);\n\n  /// @dev Deploy a market with an existing hooks deployment (in `parameters.hooks`)\n  ///\n  ///      On success:\n  ///      - Pays the origination fee (if applicable).\n  ///      - Calls `onDeployMarket` on the hooks contract.\n  ///      - Deploys a new market with the given parameters.\n  ///      - Emits `MarketDeployed`.\n  ///\n  ///      Reverts if:\n  ///      - The caller is not an approved borrower.\n  ///      - The hooks instance does not exist.\n  ///      - Payment of origination fee fails.\n  ///      - The deployment fails.\n  ///      - The call to `onDeployMarket` fails.\n  ///      - `originationFeeAsset` does not match the hook template's\n  ///      - `originationFeeAmount` does not match the hook template's\n  function deployMarket(\n    DeployMarketInputs calldata parameters,\n    bytes calldata hooksData,\n    bytes32 salt,\n    address originationFeeAsset,\n    uint256 originationFeeAmount\n  ) external returns (address market);\n\n  /// @dev Deploy a hooks instance for an approved template,then deploy a new market with that\n  ///      instance as its hooks contract.\n  ///      Will call `onCreateMarket` on `parameters.hooks`.\n  function deployMarketAndHooks(\n    address hooksTemplate,\n    bytes calldata hooksConstructorArgs,\n    DeployMarketInputs calldata parameters,\n    bytes calldata hooksData,\n    bytes32 salt,\n    address originationFeeAsset,\n    uint256 originationFeeAmount\n  ) external returns (address market, address hooks);\n\n  function computeMarketAddress(bytes32 salt) external view returns (address);\n\n  function pushProtocolFeeBipsUpdates(\n    address hooksTemplate,\n    uint marketStartIndex,\n    uint marketEndIndex\n  ) external;\n\n  function pushProtocolFeeBipsUpdates(address hooksTemplate) external;\n}\n"},"src/types/TransientBytesArray.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.25;\nimport { Panic_ErrorSelector, Panic_ErrorCodePointer, Panic_InvalidStorageByteArray, Error_SelectorPointer, Panic_ErrorLength } from '../libraries/Errors.sol';\n\ntype TransientBytesArray is uint256;\n\nusing LibTransientBytesArray for TransientBytesArray global;\n\nlibrary LibTransientBytesArray {\n  /**\n   * @dev Decode a dynamic bytes array from transient storage.\n   * @param transientSlot Slot for the dynamic bytes array in transient storage\n   * @param memoryPointer Pointer to the memory location to write the decoded array to\n   * @return endPointer Pointer to the end of the decoded array\n   */\n  function readToPointer(\n    TransientBytesArray transientSlot,\n    uint256 memoryPointer\n  ) internal view returns (uint256 endPointer) {\n    assembly {\n      function extractByteArrayLength(data) -> length {\n        length := div(data, 2)\n        let outOfPlaceEncoding := and(data, 1)\n        if iszero(outOfPlaceEncoding) {\n          length := and(length, 0x7f)\n        }\n\n        if eq(outOfPlaceEncoding, lt(length, 32)) {\n          // Store the Panic error signature.\n          mstore(0, Panic_ErrorSelector)\n          // Store the arithmetic (0x11) panic code.\n          mstore(Panic_ErrorCodePointer, Panic_InvalidStorageByteArray)\n          // revert(abi.encodeWithSignature(\"Panic(uint256)\", 0x22))\n          revert(Error_SelectorPointer, Panic_ErrorLength)\n        }\n      }\n      let slotValue := tload(transientSlot)\n      let length := extractByteArrayLength(slotValue)\n      mstore(memoryPointer, length)\n      memoryPointer := add(memoryPointer, 0x20)\n      switch and(slotValue, 1)\n      case 0 {\n        // short byte array\n        let value := and(slotValue, not(0xff))\n        mstore(memoryPointer, value)\n        endPointer := add(memoryPointer, 0x20)\n      }\n      case 1 {\n        // long byte array\n        mstore(0, transientSlot)\n        // Calculate the slot of the data portion of the array\n        let dataTSlot := keccak256(0, 0x20)\n        let i := 0\n        for {\n\n        } lt(i, length) {\n          i := add(i, 0x20)\n        } {\n          mstore(add(memoryPointer, i), tload(dataTSlot))\n          dataTSlot := add(dataTSlot, 1)\n        }\n        endPointer := add(memoryPointer, i)\n      }\n    }\n  }\n\n  function read(TransientBytesArray transientSlot) internal view returns (bytes memory data) {\n    uint256 dataPointer;\n    assembly {\n      dataPointer := mload(0x40)\n      data := dataPointer\n      mstore(data, 0)\n    }\n    uint256 endPointer = readToPointer(transientSlot, dataPointer);\n    assembly {\n      mstore(0x40, endPointer)\n    }\n  }\n\n  /**\n   * @dev Write a dynamic bytes array to transient storage.\n   * @param transientSlot Slot for the dynamic bytes array in transient storage\n   * @param memoryPointer Pointer to the memory location of the array to write\n   */\n  function write(TransientBytesArray transientSlot, bytes memory memoryPointer) internal {\n    assembly {\n      let length := mload(memoryPointer)\n      memoryPointer := add(memoryPointer, 0x20)\n      switch lt(length, 32)\n      case 0 {\n        // For long byte arrays, the length slot holds (length * 2 + 1)\n        tstore(transientSlot, add(1, mul(2, length)))\n        // Calculate the slot of the data portion of the array\n        mstore(0, transientSlot)\n        let dataTSlot := keccak256(0, 0x20)\n        let i := 0\n        for {\n\n        } lt(i, length) {\n          i := add(i, 0x20)\n        } {\n          tstore(dataTSlot, mload(add(memoryPointer, i)))\n          dataTSlot := add(dataTSlot, 1)\n        }\n      }\n      case 1 {\n        // For short byte arrays, the first 31 bytes are the data and the last byte is (length * 2).\n        let lengthByte := mul(2, length)\n        let data := mload(memoryPointer)\n        tstore(transientSlot, or(data, lengthByte))\n      }\n    }\n  }\n\n  function setEmpty(TransientBytesArray transientSlot) internal {\n    assembly {\n      tstore(transientSlot, 0)\n    }\n  }\n}\n"},"src/spherex/SphereXProtectedRegisteredBase.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\n// (c) SphereX 2023 Terms&Conditions\npragma solidity ^0.8.20;\n\nimport { ISphereXEngine, ModifierLocals } from './ISphereXEngine.sol';\nimport './SphereXProtectedEvents.sol';\nimport './SphereXProtectedErrors.sol';\n\n/**\n * @title Modified version of SphereXProtectedBase for contracts registered\n *        on Wildcat's arch controller.\n *\n * @author Modified from https://github.com/spherex-xyz/spherex-protect-contracts/blob/main/src/SphereXProtectedBase.sol\n *\n * @dev In this version, the WildcatArchController deployment is the SphereX operator.\n *      There is no admin because the arch controller address can not be modified.\n *\n *      All admin functions/events/errors have been removed to reduce contract size.\n *\n *      SphereX engine address validation is delegated to the arch controller.\n */\nabstract contract SphereXProtectedRegisteredBase {\n  // ========================================================================== //\n  //                                  Constants                                 //\n  // ========================================================================== //\n\n  /// @dev Storage slot with the address of the SphereX engine contract.\n  bytes32 private constant SPHEREX_ENGINE_STORAGE_SLOT =\n    bytes32(uint256(keccak256('eip1967.spherex.spherex_engine')) - 1);\n\n  /**\n   * @dev Address of the WildcatArchController deployment.\n   *      The arch controller is able to set the SphereX engine address.\n   *      The inheriting contract must assign this in the constructor.\n   */\n  address internal immutable _archController;\n\n  // ========================================================================== //\n  //                                 Initializer                                //\n  // ========================================================================== //\n\n  /**\n   * @dev Initializes the SphereXEngine and emits events for the initial\n   *      engine and operator (arch controller).\n   */\n  function __SphereXProtectedRegisteredBase_init(address engine) internal virtual {\n    emit_ChangedSpherexOperator(address(0), _archController);\n    _setAddress(SPHEREX_ENGINE_STORAGE_SLOT, engine);\n    emit_ChangedSpherexEngineAddress(address(0), engine);\n  }\n\n  // ========================================================================== //\n  //                              Events and Errors                             //\n  // ========================================================================== //\n\n  error SphereXOperatorRequired();\n\n  event ChangedSpherexOperator(address oldSphereXAdmin, address newSphereXAdmin);\n  event ChangedSpherexEngineAddress(address oldEngineAddress, address newEngineAddress);\n\n  // ========================================================================== //\n  //                               Local Modifiers                              //\n  // ========================================================================== //\n\n  modifier spherexOnlyOperator() {\n    if (msg.sender != _archController) {\n      revert_SphereXOperatorRequired();\n    }\n    _;\n  }\n\n  modifier returnsIfNotActivatedPre(ModifierLocals memory locals) {\n    locals.engine = sphereXEngine();\n    if (locals.engine == address(0)) {\n      return;\n    }\n\n    _;\n  }\n\n  modifier returnsIfNotActivatedPost(ModifierLocals memory locals) {\n    if (locals.engine == address(0)) {\n      return;\n    }\n\n    _;\n  }\n\n  // ========================================================================== //\n  //                                 Management                                 //\n  // ========================================================================== //\n\n  /// @dev Returns the current operator address.\n  function sphereXOperator() public view returns (address) {\n    return _archController;\n  }\n\n  /// @dev Returns the current engine address.\n  function sphereXEngine() public view returns (address) {\n    return _getAddress(SPHEREX_ENGINE_STORAGE_SLOT);\n  }\n\n  /**\n   * @dev  Change the address of the SphereX engine.\n   *\n   *       This is also used to enable SphereX protection, which is disabled\n   *       when the engine address is 0.\n   *\n   * Note: The new engine is not validated as it would be in `SphereXProtectedBase`\n   *       because the operator is the arch controller, which validates the engine\n   *       address prior to updating it here.\n   */\n  function changeSphereXEngine(address newSphereXEngine) external spherexOnlyOperator {\n    address oldEngine = _getAddress(SPHEREX_ENGINE_STORAGE_SLOT);\n    _setAddress(SPHEREX_ENGINE_STORAGE_SLOT, newSphereXEngine);\n    emit_ChangedSpherexEngineAddress(oldEngine, newSphereXEngine);\n  }\n\n  // ========================================================================== //\n  //                                    Hooks                                   //\n  // ========================================================================== //\n\n  /**\n   * @dev Wrapper for `_getStorageSlotsAndPreparePostCalldata` that returns\n   *      a `uint256` pointer to `locals` rather than the struct itself.\n   *\n   *      Declaring a return parameter for a struct will always zero and\n   *      allocate memory for every field in the struct. If the parameter\n   *      is always reassigned, the gas and memory used on this are wasted.\n   *\n   *      Using a `uint256` pointer instead of a struct declaration avoids\n   *      this waste while being functionally identical.\n   */\n  function _sphereXValidateExternalPre() internal returns (uint256 localsPointer) {\n    return _castFunctionToPointerOutput(_getStorageSlotsAndPreparePostCalldata)(_getSelector());\n  }\n\n  /**\n   * @dev Internal function for engine communication. We use it to reduce contract size.\n   *      Should be called before the code of an external function.\n   *\n   *      Queries `storageSlots` from `sphereXValidatePre` on the engine and writes\n   *      the result to `locals.storageSlots`, then caches the current storage values\n   *      for those slots in `locals.valuesBefore`.\n   *\n   *      Also allocates memory for the calldata of the future call to `sphereXValidatePost`\n   *      and initializes every value in the calldata except for `gas` and `valuesAfter` data.\n   *\n   * @param num function identifier\n   */\n  function _getStorageSlotsAndPreparePostCalldata(\n    int256 num\n  ) internal returnsIfNotActivatedPre(locals) returns (ModifierLocals memory locals) {\n    assembly {\n      // Read engine from `locals.engine` - this is filled by `returnsIfNotActivatedPre`\n      let engineAddress := mload(add(locals, 0x60))\n\n      // Get free memory pointer - this will be used for the calldata\n      // to `sphereXValidatePre` and then reused for both `storageSlots`\n      // and the future calldata to `sphereXValidatePost`\n      let pointer := mload(0x40)\n\n      // Call `sphereXValidatePre(num, msg.sender, msg.data)`\n      mstore(pointer, 0x8925ca5a)\n      mstore(add(pointer, 0x20), num)\n      mstore(add(pointer, 0x40), caller())\n      mstore(add(pointer, 0x60), 0x60)\n      mstore(add(pointer, 0x80), calldatasize())\n      calldatacopy(add(pointer, 0xa0), 0, calldatasize())\n      let size := add(0xc4, calldatasize())\n\n      if iszero(\n        and(eq(mload(0), 0x20), call(gas(), engineAddress, 0, add(pointer, 28), size, 0, 0x40))\n      ) {\n        returndatacopy(0, 0, returndatasize())\n        revert(0, returndatasize())\n      }\n      let length := mload(0x20)\n\n      // Set up the memory after the allocation `locals` struct as:\n      // [0x00:0x20]: `storageSlots.length`\n      // [0x20:0x20+(length * 0x20)]: `storageSlots` data\n      // [0x20+(length*0x20):]: calldata for `sphereXValidatePost`\n\n      // The layout for the `sphereXValidatePost` calldata is:\n      // [0x00:0x20]: num\n      // [0x20:0x40]: gas\n      // [0x40:0x60]: valuesBefore offset (0x80)\n      // [0x60:0x80]: valuesAfter offset (0xa0 + (0x20 * length))\n      // [0x80:0xa0]: valuesBefore length (0xa0 + (0x20 * length))\n      // [0xa0:0xa0+(0x20*length)]: valuesBefore data\n      // [0xa0+(0x20*length):0xc0+(0x20*length)] valuesAfter length\n      // [0xc0+(0x20*length):0xc0+(0x40*length)]: valuesAfter data\n      //\n      // size of calldata: 0xc0 + (0x40 * length)\n      //\n      // size of allocation: 0xe0 + (0x60 * length)\n\n      // Calculate size of array data (excluding length): 32 * length\n      let arrayDataSize := shl(5, length)\n\n      // Finalize memory allocation with space for `storageSlots` and\n      // the calldata for `sphereXValidatePost`.\n      mstore(0x40, add(pointer, add(0xe0, mul(arrayDataSize, 3))))\n\n      // Copy `storageSlots` from returndata to the start of the allocated\n      // memory buffer and write the pointer to `locals.storageSlots`\n      returndatacopy(pointer, 0x20, add(arrayDataSize, 0x20))\n      mstore(locals, pointer)\n\n      // Get pointer to future calldata.\n      // Add `32 + arrayDataSize` to skip the allocation for `locals.storageSlots`\n      // @todo *could* put `valuesBefore` before `storageSlots` and reuse\n      // the `storageSlots` buffer for `valuesAfter`\n      let calldataPointer := add(pointer, add(arrayDataSize, 0x20))\n\n      // Write `-num` to calldata\n      mstore(calldataPointer, sub(0, num))\n\n      // Write `valuesBefore` offset to calldata\n      mstore(add(calldataPointer, 0x40), 0x80)\n\n      // Write `locals.valuesBefore` pointer\n      mstore(add(locals, 0x20), add(calldataPointer, 0x80))\n\n      // Write `valuesAfter` offset to calldata\n      mstore(add(calldataPointer, 0x60), add(0xa0, arrayDataSize))\n\n      // Write `gasleft()` to `locals.gas`\n      mstore(add(locals, 0x40), gas())\n    }\n    _readStorageTo(locals.storageSlots, locals.valuesBefore);\n  }\n\n  /**\n   * @dev Wrapper for `_callSphereXValidatePost` that takes a pointer\n   *      instead of a struct.\n   */\n  function _sphereXValidateExternalPost(uint256 locals) internal {\n    _castFunctionToPointerInput(_callSphereXValidatePost)(locals);\n  }\n\n  function _callSphereXValidatePost(\n    ModifierLocals memory locals\n  ) internal returnsIfNotActivatedPost(locals) {\n    uint256 length;\n    bytes32[] memory storageSlots;\n    bytes32[] memory valuesAfter;\n    assembly {\n      storageSlots := mload(locals)\n      length := mload(storageSlots)\n      valuesAfter := add(storageSlots, add(0xc0, shl(6, length)))\n    }\n    _readStorageTo(storageSlots, valuesAfter);\n    assembly {\n      let sphereXEngineAddress := mload(add(locals, 0x60))\n      let arrayDataSize := shl(5, length)\n      let calldataSize := add(0xc4, shl(1, arrayDataSize))\n\n      let calldataPointer := add(storageSlots, add(arrayDataSize, 0x20))\n      let gasDiff := sub(mload(add(locals, 0x40)), gas())\n      mstore(add(calldataPointer, 0x20), gasDiff)\n      let slotBefore := sub(calldataPointer, 32)\n      let slotBeforeCache := mload(slotBefore)\n      mstore(slotBefore, 0xf0bd9468)\n      if iszero(call(gas(), sphereXEngineAddress, 0, add(slotBefore, 28), calldataSize, 0, 0)) {\n        returndatacopy(0, 0, returndatasize())\n        revert(0, returndatasize())\n      }\n      mstore(slotBefore, slotBeforeCache)\n    }\n  }\n\n  /// @dev Returns the function selector from the current calldata.\n  function _getSelector() internal pure returns (int256 selector) {\n    assembly {\n      selector := shr(224, calldataload(0))\n    }\n  }\n\n  /// @dev Modifier to be incorporated in all external protected non-view functions\n  modifier sphereXGuardExternal() {\n    uint256 localsPointer = _sphereXValidateExternalPre();\n    _;\n    _sphereXValidateExternalPost(localsPointer);\n  }\n\n  // ========================================================================== //\n  //                          Internal Storage Helpers                          //\n  // ========================================================================== //\n\n  /// @dev Stores an address in an arbitrary slot\n  function _setAddress(bytes32 slot, address newAddress) internal {\n    assembly {\n      sstore(slot, newAddress)\n    }\n  }\n\n  /// @dev Returns an address from an arbitrary slot.\n  function _getAddress(bytes32 slot) internal view returns (address addr) {\n    assembly {\n      addr := sload(slot)\n    }\n  }\n\n  /**\n   * @dev Internal function that reads values from given storage slots\n   *      and writes them to a particular memory location.\n   *\n   * @param storageSlots array of storage slots to read\n   * @param values array of values to write values to\n   */\n  function _readStorageTo(bytes32[] memory storageSlots, bytes32[] memory values) internal view {\n    assembly {\n      let length := mload(storageSlots)\n      let arrayDataSize := shl(5, length)\n      mstore(values, length)\n      let nextSlotPointer := add(storageSlots, 0x20)\n      let nextElementPointer := add(values, 0x20)\n      let endPointer := add(nextElementPointer, shl(5, length))\n      for {\n\n      } lt(nextElementPointer, endPointer) {\n\n      } {\n        mstore(nextElementPointer, sload(mload(nextSlotPointer)))\n        nextElementPointer := add(nextElementPointer, 0x20)\n        nextSlotPointer := add(nextSlotPointer, 0x20)\n      }\n    }\n  }\n\n  // ========================================================================== //\n  //                             Function Type Casts                            //\n  // ========================================================================== //\n\n  function _castFunctionToPointerInput(\n    function(ModifierLocals memory) internal fnIn\n  ) internal pure returns (function(uint256) internal fnOut) {\n    assembly {\n      fnOut := fnIn\n    }\n  }\n\n  function _castFunctionToPointerOutput(\n    function(int256) internal returns (ModifierLocals memory) fnIn\n  ) internal pure returns (function(int256) internal returns (uint256) fnOut) {\n    assembly {\n      fnOut := fnIn\n    }\n  }\n}\n"},"src/types/RoleProvider.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport '../libraries/MathUtils.sol';\n\ntype RoleProvider is uint256;\nuint24 constant NullProviderIndex = type(uint24).max;\nRoleProvider constant EmptyRoleProvider = RoleProvider.wrap(0);\n\nusing LibRoleProvider for RoleProvider global;\n\n/**\n * @dev Create a `RoleProvider` from its members.\n */\nfunction encodeRoleProvider(\n  uint32 timeToLive,\n  address providerAddress,\n  uint24 pullProviderIndex,\n  uint24 pushProviderIndex\n) pure returns (RoleProvider provider) {\n  assembly {\n    provider := or(\n      or(shl(0xe0, timeToLive), shl(0x40, providerAddress)),\n      or(shl(0x28, pullProviderIndex), shl(0x10, pushProviderIndex))\n    )\n  }\n}\n\nlibrary LibRoleProvider {\n  using MathUtils for uint256;\n\n  /**\n   * @dev Calculate the expiry for a credential granted at `timestamp` by `provider`,\n   *      adding its time-to-live to the timestamp and maxing out at the max uint32,\n   *      indicating indefinite access.\n   */\n  function calculateExpiry(\n    RoleProvider provider,\n    uint256 timestamp\n  ) internal pure returns (uint256) {\n    return timestamp.satAdd(provider.timeToLive(), type(uint32).max);\n  }\n\n  /// @dev Extract `timeToLive, providerAddress, pullProviderIndex` from a RoleProvider\n  function decodeRoleProvider(\n    RoleProvider provider\n  )\n    internal\n    pure\n    returns (\n      uint32 _timeToLive,\n      address _providerAddress,\n      uint24 _pullProviderIndex,\n      uint24 _pushProviderIndex\n    )\n  {\n    assembly {\n      _timeToLive := shr(0xe0, provider)\n      _providerAddress := shr(0x60, shl(0x20, provider))\n      _pullProviderIndex := shr(0xe8, shl(0xc0, provider))\n      _pushProviderIndex := shr(0xe8, shl(0xd8, provider))\n    }\n  }\n\n  /// @dev Extract `timeToLive` from `provider`\n  function timeToLive(RoleProvider provider) internal pure returns (uint32 _timeToLive) {\n    assembly {\n      _timeToLive := shr(0xe0, provider)\n    }\n  }\n\n  /**\n   * @dev Returns new RoleProvider with `timeToLive` set to `_timeToLive`\n   *\n   *      Note: This function does not modify the original RoleProvider\n   */\n  function setTimeToLive(\n    RoleProvider provider,\n    uint32 _timeToLive\n  ) internal pure returns (RoleProvider newProvider) {\n    assembly {\n      newProvider := or(shr(0x20, shl(0x20, provider)), shl(0xe0, _timeToLive))\n    }\n  }\n\n  /// @dev Extract `providerAddress` from `provider`\n  function providerAddress(RoleProvider provider) internal pure returns (address _providerAddress) {\n    assembly {\n      _providerAddress := shr(0x60, shl(0x20, provider))\n    }\n  }\n\n  /**\n   * @dev Returns new RoleProvider with `providerAddress` set to `_providerAddress`\n   *\n   *      Note: This function does not modify the original RoleProvider\n   */\n  function setProviderAddress(\n    RoleProvider provider,\n    address _providerAddress\n  ) internal pure returns (RoleProvider newProvider) {\n    assembly {\n      newProvider := or(\n        and(provider, 0xffffffff0000000000000000000000000000000000000000ffffffffffffffff),\n        shl(0x40, _providerAddress)\n      )\n    }\n  }\n\n  /// @dev Extract `pullProviderIndex` from `provider`\n  function pullProviderIndex(\n    RoleProvider provider\n  ) internal pure returns (uint24 _pullProviderIndex) {\n    assembly {\n      _pullProviderIndex := shr(0xe8, shl(0xc0, provider))\n    }\n  }\n\n  /// @dev Extract `pushProviderIndex` from `provider`\n  function pushProviderIndex(\n    RoleProvider provider\n  ) internal pure returns (uint24 _pushProviderIndex) {\n    assembly {\n      _pushProviderIndex := shr(0xe8, shl(0xd8, provider))\n    }\n  }\n\n  /**\n   * @dev Returns new RoleProvider with `pullProviderIndex` set to `_pullProviderIndex`\n   *\n   *      Note: This function does not modify the original RoleProvider\n   */\n  function setPullProviderIndex(\n    RoleProvider provider,\n    uint24 _pullProviderIndex\n  ) internal pure returns (RoleProvider newProvider) {\n    assembly {\n      newProvider := or(\n        and(provider, 0xffffffffffffffffffffffffffffffffffffffffffffffff000000ffffffffff),\n        shl(0x28, _pullProviderIndex)\n      )\n    }\n  }\n\n  /**\n   * @dev Returns new RoleProvider with `pushProviderIndex` set to `_pushProviderIndex`\n   *\n   *      Note: This function does not modify the original RoleProvider\n   */\n  function setPushProviderIndex(\n    RoleProvider provider,\n    uint24 _pushProviderIndex\n  ) internal pure returns (RoleProvider newProvider) {\n    assembly {\n      newProvider := or(\n        and(provider, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffff000000ffff),\n        shl(0x10, _pushProviderIndex)\n      )\n    }\n  }\n\n  /// @dev Checks if two RoleProviders are equal\n  function eq(\n    RoleProvider provider,\n    RoleProvider otherRoleProvider\n  ) internal pure returns (bool _eq) {\n    assembly {\n      _eq := eq(provider, otherRoleProvider)\n    }\n  }\n\n  /// @dev Checks if `provider` is null\n  function isNull(RoleProvider provider) internal pure returns (bool _null) {\n    assembly {\n      _null := iszero(provider)\n    }\n  }\n\n  /**\n   * @dev Returns whether `provider` is a pull provider by checking if\n   *      `pullProviderIndex` is not equal to `NullProviderIndex`.\n   */\n  function isPullProvider(RoleProvider provider) internal pure returns (bool) {\n    return provider.pullProviderIndex() != NullProviderIndex;\n  }\n\n  /**\n   * @dev Set `pullProviderIndex` in `provider` to `NullProviderIndex`\n   *      to mark it as not a pull provider.\n   */\n  function setNotPullProvider(\n    RoleProvider provider\n  ) internal pure returns (RoleProvider newProvider) {\n    assembly {\n      newProvider := or(provider, 0xffffff0000000000)\n    }\n  }\n}\n"},"src/spherex/ISphereXEngine.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\n// (c) SphereX 2023 Terms&Conditions\npragma solidity ^0.8.20;\n\n/// @dev this struct is used to reduce the stack usage of the modifiers.\nstruct ModifierLocals {\n  bytes32[] storageSlots;\n  bytes32[] valuesBefore;\n  uint256 gas;\n  address engine;\n}\n\n/// @title Interface for SphereXEngine - definitions of core functionality\n/// @author SphereX Technologies ltd\n/// @notice This interface is imported by SphereXProtected, so that SphereXProtected can call functions from SphereXEngine\n/// @dev Full docs of these functions can be found in SphereXEngine\ninterface ISphereXEngine {\n  function sphereXValidatePre(\n    int256 num,\n    address sender,\n    bytes calldata data\n  ) external returns (bytes32[] memory);\n\n  function sphereXValidatePost(\n    int256 num,\n    uint256 gas,\n    bytes32[] calldata valuesBefore,\n    bytes32[] calldata valuesAfter\n  ) external;\n\n  function sphereXValidateInternalPre(int256 num) external returns (bytes32[] memory);\n\n  function sphereXValidateInternalPost(\n    int256 num,\n    uint256 gas,\n    bytes32[] calldata valuesBefore,\n    bytes32[] calldata valuesAfter\n  ) external;\n\n  function addAllowedSenderOnChain(address sender) external;\n\n  /// This function is taken as is from OZ IERC165, we don't inherit from OZ\n  /// to avoid collisions with the customer OZ version.\n  /// @dev Returns true if this contract implements the interface defined by\n  /// `interfaceId`. See the corresponding\n  /// https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n  /// to learn more about how these ids are created.\n  /// This function call must use less than 30 000 gas.\n  function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"},"src/spherex/SphereXProtectedEvents.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nfunction emit_ChangedSpherexOperator(address oldSphereXAdmin, address newSphereXAdmin) {\n  assembly {\n    mstore(0, oldSphereXAdmin)\n    mstore(0x20, newSphereXAdmin)\n    log1(0, 0x40, 0x2ac55ae7ba47db34b5334622acafeb34a65daf143b47019273185d64c73a35a5)\n  }\n}\n\nfunction emit_ChangedSpherexEngineAddress(address oldEngineAddress, address newEngineAddress) {\n  assembly {\n    mstore(0, oldEngineAddress)\n    mstore(0x20, newEngineAddress)\n    log1(0, 0x40, 0xf33499cccaa0611882086224cc48cd82ef54b66a4d2edf4ed67108dd516896d5)\n  }\n}\n\nfunction emit_SpherexAdminTransferStarted(address currentAdmin, address pendingAdmin) {\n  assembly {\n    mstore(0, currentAdmin)\n    mstore(0x20, pendingAdmin)\n    log1(0, 0x40, 0x5778f1547abbbb86090a43c32aec38334b31df4beeb6f8f3fa063f593b53a526)\n  }\n}\n\nfunction emit_SpherexAdminTransferCompleted(address oldAdmin, address newAdmin) {\n  assembly {\n    mstore(0, oldAdmin)\n    mstore(0x20, newAdmin)\n    log1(0, 0x40, 0x67ebaebcd2ca5a91a404e898110f221747e8d15567f2388a34794aab151cf3e6)\n  }\n}\n\nfunction emit_NewAllowedSenderOnchain(address sender) {\n  assembly {\n    mstore(0, sender)\n    log1(0, 0x20, 0x6de0a1fd3a59e5479e6480ba65ef28d4f3ab8143c2c631bbfd9969ab39074797)\n  }\n}\n"},"src/spherex/SphereXProtectedErrors.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nfunction revert_SphereXOperatorRequired() pure {\n  assembly {\n    mstore(0, 0x4ee0b8f8)\n    revert(0x1c, 0x04)\n  }\n}\n\nfunction revert_SphereXAdminRequired() pure {\n  assembly {\n    mstore(0, 0x6222a550)\n    revert(0x1c, 0x04)\n  }\n}\n\nfunction revert_SphereXOperatorOrAdminRequired() pure {\n  assembly {\n    mstore(0, 0xb2dbeb59)\n    revert(0x1c, 0x04)\n  }\n}\n\nfunction revert_SphereXNotPendingAdmin() pure {\n  assembly {\n    mstore(0, 0x4d28a58e)\n    revert(0x1c, 0x04)\n  }\n}\n\nfunction revert_SphereXNotEngine() pure {\n  assembly {\n    mstore(0, 0x7dcb7ada)\n    revert(0x1c, 0x04)\n  }\n}\n"},"src/libraries/Errors.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.20;\n\nuint256 constant Panic_CompilerPanic = 0x00;\nuint256 constant Panic_AssertFalse = 0x01;\nuint256 constant Panic_Arithmetic = 0x11;\nuint256 constant Panic_DivideByZero = 0x12;\nuint256 constant Panic_InvalidEnumValue = 0x21;\nuint256 constant Panic_InvalidStorageByteArray = 0x22;\nuint256 constant Panic_EmptyArrayPop = 0x31;\nuint256 constant Panic_ArrayOutOfBounds = 0x32;\nuint256 constant Panic_MemoryTooLarge = 0x41;\nuint256 constant Panic_UninitializedFunctionPointer = 0x51;\n\nuint256 constant Panic_ErrorSelector = 0x4e487b71;\nuint256 constant Panic_ErrorCodePointer = 0x20;\nuint256 constant Panic_ErrorLength = 0x24;\nuint256 constant Error_SelectorPointer = 0x1c;\n\n/**\n * @dev Reverts with the given error selector.\n * @param errorSelector The left-aligned error selector.\n */\nfunction revertWithSelector(bytes4 errorSelector) pure {\n  assembly {\n    mstore(0, errorSelector)\n    revert(0, 4)\n  }\n}\n\n/**\n * @dev Reverts with the given error selector.\n * @param errorSelector The left-padded error selector.\n */\nfunction revertWithSelector(uint256 errorSelector) pure {\n  assembly {\n    mstore(0, errorSelector)\n    revert(Error_SelectorPointer, 4)\n  }\n}\n\n/**\n * @dev Reverts with the given error selector and argument.\n * @param errorSelector The left-aligned error selector.\n * @param argument The argument to the error.\n */\nfunction revertWithSelectorAndArgument(bytes4 errorSelector, uint256 argument) pure {\n  assembly {\n    mstore(0, errorSelector)\n    mstore(4, argument)\n    revert(0, 0x24)\n  }\n}\n\n/**\n * @dev Reverts with the given error selector and argument.\n * @param errorSelector The left-padded error selector.\n * @param argument The argument to the error.\n */\nfunction revertWithSelectorAndArgument(uint256 errorSelector, uint256 argument) pure {\n  assembly {\n    mstore(0, errorSelector)\n    mstore(0x20, argument)\n    revert(Error_SelectorPointer, 0x24)\n  }\n}\n"},"src/interfaces/IMarketEventsAndErrors.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.20;\n\nimport { MarketState } from '../libraries/MarketState.sol';\n\ninterface IMarketEventsAndErrors {\n  /// @notice Error thrown when deposit exceeds maxTotalSupply\n  error MaxSupplyExceeded();\n\n  /// @notice Error thrown when non-borrower tries accessing borrower-only actions\n  error NotApprovedBorrower();\n\n  /// @notice Error thrown when non-approved lender tries lending to the market\n  error NotApprovedLender();\n\n  /// @notice Error thrown when caller other than factory tries changing protocol fee\n  error NotFactory();\n\n  /// @notice Error thrown when non-sentinel tries to use nukeFromOrbit\n  error BadLaunchCode();\n\n  /// @notice Error thrown when transfer target is blacklisted\n  error AccountBlocked();\n\n  error BadRescueAsset();\n\n  error BorrowAmountTooHigh();\n\n  error InsufficientReservesForFeeWithdrawal();\n\n  error WithdrawalBatchNotExpired();\n\n  error NullMintAmount();\n\n  error NullBurnAmount();\n\n  error NullFeeAmount();\n\n  error NullTransferAmount();\n\n  error NullWithdrawalAmount();\n\n  error NullRepayAmount();\n\n  error NullBuyBackAmount();\n\n  error MarketAlreadyClosed();\n\n  error DepositToClosedMarket();\n\n  error RepayToClosedMarket();\n\n  error BuyBackOnDelinquentMarket();\n\n  error BorrowWhileSanctioned();\n\n  error BorrowFromClosedMarket();\n\n  error AprChangeOnClosedMarket();\n\n  error CapacityChangeOnClosedMarket();\n\n  error ProtocolFeeChangeOnClosedMarket();\n\n  error CloseMarketWithUnpaidWithdrawals();\n\n  error AnnualInterestBipsTooHigh();\n\n  error ReserveRatioBipsTooHigh();\n\n  error ProtocolFeeTooHigh();\n\n  /// @dev Error thrown when reserve ratio is set to a value\n  ///      that would make the market delinquent.\n  error InsufficientReservesForNewLiquidityRatio();\n\n  error InsufficientReservesForOldLiquidityRatio();\n\n  error InvalidArrayLength();\n\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n\n  event MaxTotalSupplyUpdated(uint256 assets);\n\n  event ProtocolFeeBipsUpdated(uint256 protocolFeeBips);\n\n  event AnnualInterestBipsUpdated(uint256 annualInterestBipsUpdated);\n\n  event ReserveRatioBipsUpdated(uint256 reserveRatioBipsUpdated);\n\n  event SanctionedAccountAssetsSentToEscrow(\n    address indexed account,\n    address escrow,\n    uint256 amount\n  );\n\n  event SanctionedAccountAssetsQueuedForWithdrawal(\n    address indexed account,\n    uint256 expiry,\n    uint256 scaledAmount,\n    uint256 normalizedAmount\n  );\n\n  event Deposit(address indexed account, uint256 assetAmount, uint256 scaledAmount);\n\n  event Borrow(uint256 assetAmount);\n\n  event DebtRepaid(address indexed from, uint256 assetAmount);\n\n  event MarketClosed(uint256 timestamp);\n\n  event FeesCollected(uint256 assets);\n\n  event StateUpdated(uint256 scaleFactor, bool isDelinquent);\n\n  event InterestAndFeesAccrued(\n    uint256 fromTimestamp,\n    uint256 toTimestamp,\n    uint256 scaleFactor,\n    uint256 baseInterestRay,\n    uint256 delinquencyFeeRay,\n    uint256 protocolFees\n  );\n\n  event AccountSanctioned(address indexed account);\n\n  // =====================================================================//\n  //                          Withdrawl Events                            //\n  // =====================================================================//\n\n  event WithdrawalBatchExpired(\n    uint256 indexed expiry,\n    uint256 scaledTotalAmount,\n    uint256 scaledAmountBurned,\n    uint256 normalizedAmountPaid\n  );\n\n  /// @dev Emitted when a new withdrawal batch is created.\n  event WithdrawalBatchCreated(uint256 indexed expiry);\n\n  /// @dev Emitted when a withdrawal batch is paid off.\n  event WithdrawalBatchClosed(uint256 indexed expiry);\n\n  event WithdrawalBatchPayment(\n    uint256 indexed expiry,\n    uint256 scaledAmountBurned,\n    uint256 normalizedAmountPaid\n  );\n\n  event WithdrawalQueued(\n    uint256 indexed expiry,\n    address indexed account,\n    uint256 scaledAmount,\n    uint256 normalizedAmount\n  );\n\n  event WithdrawalExecuted(\n    uint256 indexed expiry,\n    address indexed account,\n    uint256 normalizedAmount\n  );\n\n  event ForceBuyBack(\n    address indexed lender,\n    uint256 scaledAmount,\n    uint256 normalizedAmount,\n    uint32 withdrawalExpiry\n  );\n\n  event SanctionedAccountWithdrawalSentToEscrow(\n    address indexed account,\n    address escrow,\n    uint32 expiry,\n    uint256 amount\n  );\n}\n"},"src/libraries/FeeMath.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.20;\n\nimport './MathUtils.sol';\nimport './SafeCastLib.sol';\nimport './MarketState.sol';\n\nusing SafeCastLib for uint256;\nusing MathUtils for uint256;\n\nlibrary FeeMath {\n  /**\n   * @dev Function to calculate the interest accumulated using a linear interest rate formula\n   *\n   * @param rateBip The interest rate, in bips\n   * @param timeDelta The time elapsed since the last interest accrual\n   * @return result The interest rate linearly accumulated during the timeDelta, in ray\n   */\n  function calculateLinearInterestFromBips(\n    uint256 rateBip,\n    uint256 timeDelta\n  ) internal pure returns (uint256 result) {\n    uint256 rate = rateBip.bipToRay();\n    uint256 accumulatedInterestRay = rate * timeDelta;\n    unchecked {\n      return accumulatedInterestRay / SECONDS_IN_365_DAYS;\n    }\n  }\n\n  function calculateBaseInterest(\n    MarketState memory state,\n    uint256 timestamp\n  ) internal pure returns (uint256 baseInterestRay) {\n    baseInterestRay = MathUtils.calculateLinearInterestFromBips(\n      state.annualInterestBips,\n      timestamp - state.lastInterestAccruedTimestamp\n    );\n  }\n\n  function applyProtocolFee(\n    MarketState memory state,\n    uint256 baseInterestRay\n  ) internal pure returns (uint256 protocolFee) {\n    // Protocol fee is charged in addition to the interest paid to lenders.\n    uint256 protocolFeeRay = uint(state.protocolFeeBips).bipMul(baseInterestRay);\n    protocolFee = uint256(state.scaledTotalSupply).rayMul(\n      uint256(state.scaleFactor).rayMul(protocolFeeRay)\n    );\n    state.accruedProtocolFees = (state.accruedProtocolFees + protocolFee).toUint128();\n  }\n\n  function updateDelinquency(\n    MarketState memory state,\n    uint256 timestamp,\n    uint256 delinquencyFeeBips,\n    uint256 delinquencyGracePeriod\n  ) internal pure returns (uint256 delinquencyFeeRay) {\n    // Calculate the number of seconds the borrower spent in penalized\n    // delinquency since the last update.\n    uint256 timeWithPenalty = updateTimeDelinquentAndGetPenaltyTime(\n      state,\n      delinquencyGracePeriod,\n      timestamp - state.lastInterestAccruedTimestamp\n    );\n\n    if (timeWithPenalty > 0) {\n      // Calculate penalty fees on the interest accrued.\n      delinquencyFeeRay = calculateLinearInterestFromBips(delinquencyFeeBips, timeWithPenalty);\n    }\n  }\n\n  /**\n   * @notice  Calculate the number of seconds that the market has been in\n   *          penalized delinquency since the last update, and update\n   *          `timeDelinquent` in state.\n   *\n   * @dev When `isDelinquent`, equivalent to:\n   *        max(0, timeDelta - max(0, delinquencyGracePeriod - previousTimeDelinquent))\n   *      When `!isDelinquent`, equivalent to:\n   *        min(timeDelta, max(0, previousTimeDelinquent - delinquencyGracePeriod))\n   *\n   * @param state Encoded state parameters\n   * @param delinquencyGracePeriod Seconds in delinquency before penalties apply\n   * @param timeDelta Seconds since the last update\n   * @param `timeWithPenalty` Number of seconds since the last update where\n   *        the market was in delinquency outside of the grace period.\n   */\n  function updateTimeDelinquentAndGetPenaltyTime(\n    MarketState memory state,\n    uint256 delinquencyGracePeriod,\n    uint256 timeDelta\n  ) internal pure returns (uint256 /* timeWithPenalty */) {\n    // Seconds in delinquency at last update\n    uint256 previousTimeDelinquent = state.timeDelinquent;\n\n    if (state.isDelinquent) {\n      // Since the borrower is still delinquent, increase the total\n      // time in delinquency by the time elapsed.\n      state.timeDelinquent = (previousTimeDelinquent + timeDelta).toUint32();\n\n      // Calculate the number of seconds the borrower had remaining\n      // in the grace period.\n      uint256 secondsRemainingWithoutPenalty = delinquencyGracePeriod.satSub(\n        previousTimeDelinquent\n      );\n\n      // Penalties apply for the number of seconds the market spent in\n      // delinquency outside of the grace period since the last update.\n      return timeDelta.satSub(secondsRemainingWithoutPenalty);\n    }\n\n    // Reduce the total time in delinquency by the time elapsed, stopping\n    // when it reaches zero.\n    state.timeDelinquent = previousTimeDelinquent.satSub(timeDelta).toUint32();\n\n    // Calculate the number of seconds the old timeDelinquent had remaining\n    // outside the grace period, or zero if it was already in the grace period.\n    uint256 secondsRemainingWithPenalty = previousTimeDelinquent.satSub(delinquencyGracePeriod);\n\n    // Only apply penalties for the remaining time outside of the grace period.\n    return MathUtils.min(secondsRemainingWithPenalty, timeDelta);\n  }\n\n  /**\n   * @dev Calculates interest and delinquency/protocol fees accrued since last state update\n   *      and applies it to cached state, returning the rates for base interest and delinquency\n   *      fees and the normalized amount of protocol fees accrued.\n   *\n   *      Takes `timestamp` as input to allow separate calculation of interest\n   *      before and after withdrawal batch expiry.\n   *\n   * @param state Market scale parameters\n   * @param delinquencyFeeBips Delinquency fee rate (in bips)\n   * @param delinquencyGracePeriod Grace period (in seconds) before delinquency fees apply\n   * @param timestamp Time to calculate interest and fees accrued until\n   * @return baseInterestRay Interest accrued to lenders (ray)\n   * @return delinquencyFeeRay Penalty fee incurred by borrower for delinquency (ray).\n   * @return protocolFee Protocol fee charged on interest (normalized token amount).\n   */\n  function updateScaleFactorAndFees(\n    MarketState memory state,\n    uint256 delinquencyFeeBips,\n    uint256 delinquencyGracePeriod,\n    uint256 timestamp\n  )\n    internal\n    pure\n    returns (uint256 baseInterestRay, uint256 delinquencyFeeRay, uint256 protocolFee)\n  {\n    baseInterestRay = state.calculateBaseInterest(timestamp);\n\n    if (state.protocolFeeBips > 0) {\n      protocolFee = state.applyProtocolFee(baseInterestRay);\n    }\n\n    if (delinquencyFeeBips > 0) {\n      delinquencyFeeRay = state.updateDelinquency(\n        timestamp,\n        delinquencyFeeBips,\n        delinquencyGracePeriod\n      );\n    }\n\n    // Calculate new scaleFactor\n    uint256 prevScaleFactor = state.scaleFactor;\n    uint256 scaleFactorDelta = prevScaleFactor.rayMul(baseInterestRay + delinquencyFeeRay);\n\n    state.scaleFactor = (prevScaleFactor + scaleFactorDelta).toUint112();\n    state.lastInterestAccruedTimestamp = uint32(timestamp);\n  }\n}\n"},"src/libraries/MarketErrors.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nuint256 constant MaxSupplyExceeded_ErrorSelector = 0x8a164f63;\n\n/// @dev Equivalent to `revert MaxSupplyExceeded()`\nfunction revert_MaxSupplyExceeded() pure {\n  assembly {\n    mstore(0, 0x8a164f63)\n    revert(0x1c, 0x04)\n  }\n}\n\nuint256 constant CapacityChangeOnClosedMarket_ErrorSelector = 0x81b21078;\n\n/// @dev Equivalent to `revert CapacityChangeOnClosedMarket()`\nfunction revert_CapacityChangeOnClosedMarket() pure {\n  assembly {\n    mstore(0, 0x81b21078)\n    revert(0x1c, 0x04)\n  }\n}\n\nuint256 constant AprChangeOnClosedMarket_ErrorSelector = 0xb9de88a2;\n\n/// @dev Equivalent to `revert AprChangeOnClosedMarket()`\nfunction revert_AprChangeOnClosedMarket() pure {\n  assembly {\n    mstore(0, 0xb9de88a2)\n    revert(0x1c, 0x04)\n  }\n}\n\nuint256 constant MarketAlreadyClosed_ErrorSelector = 0x449e5f50;\n\n/// @dev Equivalent to `revert MarketAlreadyClosed()`\nfunction revert_MarketAlreadyClosed() pure {\n  assembly {\n    mstore(0, 0x449e5f50)\n    revert(0x1c, 0x04)\n  }\n}\n\nuint256 constant NotApprovedBorrower_ErrorSelector = 0x02171e6a;\n\n/// @dev Equivalent to `revert NotApprovedBorrower()`\nfunction revert_NotApprovedBorrower() pure {\n  assembly {\n    mstore(0, 0x02171e6a)\n    revert(0x1c, 0x04)\n  }\n}\n\nuint256 constant NotApprovedLender_ErrorSelector = 0xe50a45ce;\n\n/// @dev Equivalent to `revert NotApprovedLender()`\nfunction revert_NotApprovedLender() pure {\n  assembly {\n    mstore(0, 0xe50a45ce)\n    revert(0x1c, 0x04)\n  }\n}\n\nuint256 constant BadLaunchCode_ErrorSelector = 0xa97ab167;\n\n/// @dev Equivalent to `revert BadLaunchCode()`\nfunction revert_BadLaunchCode() pure {\n  assembly {\n    mstore(0, 0xa97ab167)\n    revert(0x1c, 0x04)\n  }\n}\n\nuint256 constant ReserveRatioBipsTooHigh_ErrorSelector = 0x8ec83073;\n\n/// @dev Equivalent to `revert ReserveRatioBipsTooHigh()`\nfunction revert_ReserveRatioBipsTooHigh() pure {\n  assembly {\n    mstore(0, 0x8ec83073)\n    revert(0x1c, 0x04)\n  }\n}\n\n/* \ncode size: 25634\ninitcode size: 28024\n\nerrors: -48 runtime, -48 initcode\n*/\nuint256 constant AnnualInterestBipsTooHigh_ErrorSelector = 0xcf1f916f;\n\n/// @dev Equivalent to `revert ReserveRatioBipsTooHigh()`\nfunction revert_AnnualInterestBipsTooHigh() pure {\n  assembly {\n    mstore(0, 0xcf1f916f)\n    revert(0x1c, 0x04)\n  }\n}\n\nuint256 constant AccountBlocked_ErrorSelector = 0x6bc671fd;\n\n/// @dev Equivalent to `revert AccountBlocked()`\nfunction revert_AccountBlocked() pure {\n  assembly {\n    mstore(0, 0x6bc671fd)\n    revert(0x1c, 0x04)\n  }\n}\n\nuint256 constant BorrowAmountTooHigh_ErrorSelector = 0x119fe6e3;\n\n/// @dev Equivalent to `revert BorrowAmountTooHigh()`\nfunction revert_BorrowAmountTooHigh() pure {\n  assembly {\n    mstore(0, 0x119fe6e3)\n    revert(0x1c, 0x04)\n  }\n}\n\nuint256 constant BadRescueAsset_ErrorSelector = 0x11530cde;\n\n/// @dev Equivalent to `revert BadRescueAsset()`\nfunction revert_BadRescueAsset() pure {\n  assembly {\n    mstore(0, 0x11530cde)\n    revert(0x1c, 0x04)\n  }\n}\n\nuint256 constant InsufficientReservesForFeeWithdrawal_ErrorSelector = 0xf784cfa4;\n\n/// @dev Equivalent to `revert InsufficientReservesForFeeWithdrawal()`\nfunction revert_InsufficientReservesForFeeWithdrawal() pure {\n  assembly {\n    mstore(0, 0xf784cfa4)\n    revert(0x1c, 0x04)\n  }\n}\n\nuint256 constant WithdrawalBatchNotExpired_ErrorSelector = 0x2561b880;\n\n/// @dev Equivalent to `revert WithdrawalBatchNotExpired()`\nfunction revert_WithdrawalBatchNotExpired() pure {\n  assembly {\n    mstore(0, 0x2561b880)\n    revert(0x1c, 0x04)\n  }\n}\n\nuint256 constant NullMintAmount_ErrorSelector = 0xe4aa5055;\n\n/// @dev Equivalent to `revert NullMintAmount()`\nfunction revert_NullMintAmount() pure {\n  assembly {\n    mstore(0, 0xe4aa5055)\n    revert(0x1c, 0x04)\n  }\n}\n\nuint256 constant NullBurnAmount_ErrorSelector = 0xd61c50f8;\n\n/// @dev Equivalent to `revert NullBurnAmount()`\nfunction revert_NullBurnAmount() pure {\n  assembly {\n    mstore(0, 0xd61c50f8)\n    revert(0x1c, 0x04)\n  }\n}\n\nuint256 constant NullFeeAmount_ErrorSelector = 0x45c835cb;\n\n/// @dev Equivalent to `revert NullFeeAmount()`\nfunction revert_NullFeeAmount() pure {\n  assembly {\n    mstore(0, 0x45c835cb)\n    revert(0x1c, 0x04)\n  }\n}\n\nuint256 constant NullTransferAmount_ErrorSelector = 0xddee9b30;\n\n/// @dev Equivalent to `revert NullTransferAmount()`\nfunction revert_NullTransferAmount() pure {\n  assembly {\n    mstore(0, 0xddee9b30)\n    revert(0x1c, 0x04)\n  }\n}\n\nuint256 constant NullWithdrawalAmount_ErrorSelector = 0x186334fe;\n\n/// @dev Equivalent to `revert NullWithdrawalAmount()`\nfunction revert_NullWithdrawalAmount() pure {\n  assembly {\n    mstore(0, 0x186334fe)\n    revert(0x1c, 0x04)\n  }\n}\n\nuint256 constant NullRepayAmount_ErrorSelector = 0x7e082088;\n\n/// @dev Equivalent to `revert NullRepayAmount()`\nfunction revert_NullRepayAmount() pure {\n  assembly {\n    mstore(0, 0x7e082088)\n    revert(0x1c, 0x04)\n  }\n}\n\nuint256 constant NullBuyBackAmount_ErrorSelector = 0x50394120;\n\n/// @dev Equivalent to `revert NullBuyBackAmount()`\nfunction revert_NullBuyBackAmount() pure {\n  assembly {\n    mstore(0, 0x50394120)\n    revert(0x1c, 0x04)\n  }\n}\n\nuint256 constant DepositToClosedMarket_ErrorSelector = 0x22d7c043;\n\n/// @dev Equivalent to `revert DepositToClosedMarket()`\nfunction revert_DepositToClosedMarket() pure {\n  assembly {\n    mstore(0, 0x22d7c043)\n    revert(0x1c, 0x04)\n  }\n}\n\nuint256 constant RepayToClosedMarket_ErrorSelector = 0x61d1bc8f;\n\n/// @dev Equivalent to `revert RepayToClosedMarket()`\nfunction revert_RepayToClosedMarket() pure {\n  assembly {\n    mstore(0, 0x61d1bc8f)\n    revert(0x1c, 0x04)\n  }\n}\n\nuint256 constant BuyBackOnDelinquentMarket_Selector = 0x1707a7b7;\n\n/// @dev Equivalent to `revert BuyBackOnDelinquentMarket()`\nfunction revert_BuyBackOnDelinquentMarket() pure {\n  assembly {\n    mstore(0, 0x1707a7b7)\n    revert(0x1c, 0x04)\n  }\n}\n\nuint256 constant BorrowWhileSanctioned_ErrorSelector = 0x4a1c13a9;\n\n/// @dev Equivalent to `revert BorrowWhileSanctioned()`\nfunction revert_BorrowWhileSanctioned() pure {\n  assembly {\n    mstore(0, 0x4a1c13a9)\n    revert(0x1c, 0x04)\n  }\n}\n\nuint256 constant BorrowFromClosedMarket_ErrorSelector = 0xd0242b28;\n\n/// @dev Equivalent to `revert BorrowFromClosedMarket()`\nfunction revert_BorrowFromClosedMarket() pure {\n  assembly {\n    mstore(0, 0xd0242b28)\n    revert(0x1c, 0x04)\n  }\n}\n\nuint256 constant CloseMarketWithUnpaidWithdrawals_ErrorSelector = 0x4d790997;\n\n/// @dev Equivalent to `revert CloseMarketWithUnpaidWithdrawals()`\nfunction revert_CloseMarketWithUnpaidWithdrawals() pure {\n  assembly {\n    mstore(0, 0x4d790997)\n    revert(0x1c, 0x04)\n  }\n}\n\nuint256 constant InsufficientReservesForNewLiquidityRatio_ErrorSelector = 0x253ecbb9;\n\n/// @dev Equivalent to `revert InsufficientReservesForNewLiquidityRatio()`\nfunction revert_InsufficientReservesForNewLiquidityRatio() pure {\n  assembly {\n    mstore(0, 0x253ecbb9)\n    revert(0x1c, 0x04)\n  }\n}\n\nuint256 constant InsufficientReservesForOldLiquidityRatio_ErrorSelector = 0x0a68e5bf;\n\n/// @dev Equivalent to `revert InsufficientReservesForOldLiquidityRatio()`\nfunction revert_InsufficientReservesForOldLiquidityRatio() pure {\n  assembly {\n    mstore(0, 0x0a68e5bf)\n    revert(0x1c, 0x04)\n  }\n}\n\nuint256 constant InvalidArrayLength_ErrorSelector = 0x9d89020a;\n\n/// @dev Equivalent to `revert InvalidArrayLength()`\nfunction revert_InvalidArrayLength() pure {\n  assembly {\n    mstore(0, 0x9d89020a)\n    revert(0x1c, 0x04)\n  }\n}\n\nuint256 constant ProtocolFeeTooHigh_ErrorSelector = 0x499fddb1;\n\n/// @dev Equivalent to `revert ProtocolFeeTooHigh()`\nfunction revert_ProtocolFeeTooHigh() pure {\n  assembly {\n    mstore(0, 0x499fddb1)\n    revert(0x1c, 0x04)\n  }\n}\n\nuint256 constant ProtocolFeeChangeOnClosedMarket_ErrorSelector = 0x37f1a75f;\n\n/// @dev Equivalent to `revert ProtocolFeeChangeOnClosedMarket()`\nfunction revert_ProtocolFeeChangeOnClosedMarket() pure {\n  assembly {\n    mstore(0, 0x37f1a75f)\n    revert(0x1c, 0x04)\n  }\n}\n\nuint256 constant NotFactory_ErrorSelector = 0x32cc7236;\n\nfunction revert_NotFactory() pure {\n  assembly {\n    mstore(0, 0x32cc7236)\n    revert(0x1c, 0x04)\n  }\n}\n"},"src/libraries/MarketEvents.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nuint256 constant InterestAndFeesAccrued_abi_head_size = 0xc0;\nuint256 constant InterestAndFeesAccrued_toTimestamp_offset = 0x20;\nuint256 constant InterestAndFeesAccrued_scaleFactor_offset = 0x40;\nuint256 constant InterestAndFeesAccrued_baseInterestRay_offset = 0x60;\nuint256 constant InterestAndFeesAccrued_delinquencyFeeRay_offset = 0x80;\nuint256 constant InterestAndFeesAccrued_protocolFees_offset = 0xa0;\n\nfunction emit_Transfer(address from, address to, uint256 value) {\n  assembly {\n    mstore(0, value)\n    log3(0, 0x20, 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef, from, to)\n  }\n}\n\nfunction emit_Approval(address owner, address spender, uint256 value) {\n  assembly {\n    mstore(0, value)\n    log3(\n      0,\n      0x20,\n      0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925,\n      owner,\n      spender\n    )\n  }\n}\n\nfunction emit_MaxTotalSupplyUpdated(uint256 assets) {\n  assembly {\n    mstore(0, assets)\n    log1(0, 0x20, 0xf2672935fc79f5237559e2e2999dbe743bf65430894ac2b37666890e7c69e1af)\n  }\n}\n\nfunction emit_ProtocolFeeBipsUpdated(uint256 protocolFeeBips) {\n  assembly {\n    mstore(0, protocolFeeBips)\n    log1(0, 0x20, 0x4b34705283cdb9398d0e50b216b8fb424c6d4def5db9bfadc661ee3adc6076ee)\n  }\n}\n\nfunction emit_AnnualInterestBipsUpdated(uint256 annualInterestBipsUpdated) {\n  assembly {\n    mstore(0, annualInterestBipsUpdated)\n    log1(0, 0x20, 0xff7b6c8be373823323d3c5d99f5d027dd409dce5db54eae511bbdd5546b75037)\n  }\n}\n\nfunction emit_ReserveRatioBipsUpdated(uint256 reserveRatioBipsUpdated) {\n  assembly {\n    mstore(0, reserveRatioBipsUpdated)\n    log1(0, 0x20, 0x72877a153052500f5edbb2f9da96a0f45d671d4b4555fdf8628a709dc4eab43a)\n  }\n}\n\nfunction emit_SanctionedAccountAssetsSentToEscrow(address account, address escrow, uint256 amount) {\n  assembly {\n    mstore(0, escrow)\n    mstore(0x20, amount)\n    log2(0, 0x40, 0x571e706c2f09ae0632313e5f3ae89fffdedfc370a2ea59a07fb0d8091147645b, account)\n  }\n}\n\nfunction emit_SanctionedAccountAssetsQueuedForWithdrawal(\n  address account,\n  uint32 expiry,\n  uint256 scaledAmount,\n  uint256 normalizedAmount\n) {\n  assembly {\n    let freePointer := mload(0x40)\n    mstore(0, expiry)\n    mstore(0x20, scaledAmount)\n    mstore(0x40, normalizedAmount)\n    log2(0, 0x60, 0xe12b220b92469ae28fb0d79de531f94161431be9f073b96b8aad3effb88be6fa, account)\n    mstore(0x40, freePointer)\n  }\n}\n\nfunction emit_Deposit(address account, uint256 assetAmount, uint256 scaledAmount) {\n  assembly {\n    mstore(0, assetAmount)\n    mstore(0x20, scaledAmount)\n    log2(0, 0x40, 0x90890809c654f11d6e72a28fa60149770a0d11ec6c92319d6ceb2bb0a4ea1a15, account)\n  }\n}\n\nfunction emit_Borrow(uint256 assetAmount) {\n  assembly {\n    mstore(0, assetAmount)\n    log1(0, 0x20, 0xb848ae6b1253b6cb77e81464128ce8bd94d3d524fea54e801e0da869784dca33)\n  }\n}\n\nfunction emit_DebtRepaid(address from, uint256 assetAmount) {\n  assembly {\n    mstore(0, assetAmount)\n    log2(0, 0x20, 0xe8b606ac1e5df7657db58d297ca8f41c090fc94c5fd2d6958f043e41736e9fa6, from)\n  }\n}\n\nfunction emit_MarketClosed(uint256 _timestamp) {\n  assembly {\n    mstore(0, _timestamp)\n    log1(0, 0x20, 0x9dc30b8eda31a6a144e092e5de600955523a6a925cc15cc1d1b9b4872cfa6155)\n  }\n}\n\nfunction emit_FeesCollected(uint256 assets) {\n  assembly {\n    mstore(0, assets)\n    log1(0, 0x20, 0x860c0aa5520013080c2f65981705fcdea474d9f7c3daf954656ed5e65d692d1f)\n  }\n}\n\nfunction emit_StateUpdated(uint256 scaleFactor, bool isDelinquent) {\n  assembly {\n    mstore(0, scaleFactor)\n    mstore(0x20, isDelinquent)\n    log1(0, 0x40, 0x9385f9ff65bcd2fb81cece54b27d4ec7376795fc4dcff686e370e347b0ed86c0)\n  }\n}\n\nfunction emit_InterestAndFeesAccrued(\n  uint256 fromTimestamp,\n  uint256 toTimestamp,\n  uint256 scaleFactor,\n  uint256 baseInterestRay,\n  uint256 delinquencyFeeRay,\n  uint256 protocolFees\n) {\n  assembly {\n    let dst := mload(0x40)\n    /// Copy fromTimestamp\n    mstore(dst, fromTimestamp)\n    /// Copy toTimestamp\n    mstore(add(dst, InterestAndFeesAccrued_toTimestamp_offset), toTimestamp)\n    /// Copy scaleFactor\n    mstore(add(dst, InterestAndFeesAccrued_scaleFactor_offset), scaleFactor)\n    /// Copy baseInterestRay\n    mstore(add(dst, InterestAndFeesAccrued_baseInterestRay_offset), baseInterestRay)\n    /// Copy delinquencyFeeRay\n    mstore(add(dst, InterestAndFeesAccrued_delinquencyFeeRay_offset), delinquencyFeeRay)\n    /// Copy protocolFees\n    mstore(add(dst, InterestAndFeesAccrued_protocolFees_offset), protocolFees)\n    log1(\n      dst,\n      InterestAndFeesAccrued_abi_head_size,\n      0x18247a393d0531b65fbd94f5e78bc5639801a4efda62ae7b43533c4442116c3a\n    )\n  }\n}\n\nfunction emit_WithdrawalBatchExpired(\n  uint256 expiry,\n  uint256 scaledTotalAmount,\n  uint256 scaledAmountBurned,\n  uint256 normalizedAmountPaid\n) {\n  assembly {\n    let freePointer := mload(0x40)\n    mstore(0, scaledTotalAmount)\n    mstore(0x20, scaledAmountBurned)\n    mstore(0x40, normalizedAmountPaid)\n    log2(0, 0x60, 0x9262dc39b47cad3a0512e4c08dda248cb345e7163058f300bc63f56bda288b6e, expiry)\n    mstore(0x40, freePointer)\n  }\n}\n\nfunction emit_WithdrawalBatchCreated(uint256 expiry) {\n  assembly {\n    log2(0, 0x00, 0x5c9a946d3041134198ebefcd814de7748def6576efd3d1b48f48193e183e89ef, expiry)\n  }\n}\n\nfunction emit_WithdrawalBatchClosed(uint256 expiry) {\n  assembly {\n    log2(0, 0x00, 0xcbdf25bf6e096dd9030d89bb2ba2e3e7adb82d25a233c3ca3d92e9f098b74e55, expiry)\n  }\n}\n\nfunction emit_WithdrawalBatchPayment(\n  uint256 expiry,\n  uint256 scaledAmountBurned,\n  uint256 normalizedAmountPaid\n) {\n  assembly {\n    mstore(0, scaledAmountBurned)\n    mstore(0x20, normalizedAmountPaid)\n    log2(0, 0x40, 0x5272034725119f19d7236de4129fdb5093f0dcb80282ca5edbd587df91d2bd89, expiry)\n  }\n}\n\nfunction emit_WithdrawalQueued(\n  uint256 expiry,\n  address account,\n  uint256 scaledAmount,\n  uint256 normalizedAmount\n) {\n  assembly {\n    mstore(0, scaledAmount)\n    mstore(0x20, normalizedAmount)\n    log3(\n      0,\n      0x40,\n      0xecc966b282a372469fa4d3e497c2ac17983c3eaed03f3f17c9acf4b15591663e,\n      expiry,\n      account\n    )\n  }\n}\n\nfunction emit_WithdrawalExecuted(uint256 expiry, address account, uint256 normalizedAmount) {\n  assembly {\n    mstore(0, normalizedAmount)\n    log3(\n      0,\n      0x20,\n      0xd6cddb3d69146e96ebc2c87b1b3dd0b20ee2d3b0eadf134e011afb434a3e56e6,\n      expiry,\n      account\n    )\n  }\n}\n\nfunction emit_ForceBuyBack(address lender, uint256 scaledAmount, uint256 normalizedAmount, uint32 withdrawalExpiry) {\n  assembly {\n    mstore(0, scaledAmount)\n    mstore(0x20, normalizedAmount)\n    mstore(0x40, withdrawalExpiry)\n    log2(0, 0x60, 0xd26ddbc1840a7e87449ec6172fa0ba67fadecc95a60ab7ec01d8f712b4d8cda3, lender)\n  }\n}\n\nfunction emit_SanctionedAccountWithdrawalSentToEscrow(\n  address account,\n  address escrow,\n  uint32 expiry,\n  uint256 amount\n) {\n  assembly {\n    let freePointer := mload(0x40)\n    mstore(0, escrow)\n    mstore(0x20, expiry)\n    mstore(0x40, amount)\n    log2(0, 0x60, 0x0d0843a0fcb8b83f625aafb6e42f234ac48c6728b207d52d97cfa8fbd34d498f, account)\n    mstore(0x40, freePointer)\n  }\n}\n"},"src/libraries/Withdrawal.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.20;\n\nimport './MarketState.sol';\nimport './FIFOQueue.sol';\n\nusing MathUtils for uint256;\nusing WithdrawalLib for WithdrawalBatch global;\n\n/**\n * Withdrawals are grouped together in batches with a fixed expiry.\n * Until a withdrawal is paid out, the tokens are not burned from the market\n * and continue to accumulate interest.\n */\nstruct WithdrawalBatch {\n  // Total scaled amount of tokens to be withdrawn\n  uint104 scaledTotalAmount;\n  // Amount of scaled tokens that have been paid by borrower\n  uint104 scaledAmountBurned;\n  // Amount of normalized tokens that have been paid by borrower\n  uint128 normalizedAmountPaid;\n}\n\nstruct AccountWithdrawalStatus {\n  uint104 scaledAmount;\n  uint128 normalizedAmountWithdrawn;\n}\n\nstruct WithdrawalData {\n  FIFOQueue unpaidBatches;\n  mapping(uint32 => WithdrawalBatch) batches;\n  mapping(uint256 => mapping(address => AccountWithdrawalStatus)) accountStatuses;\n}\n\nlibrary WithdrawalLib {\n  function scaledOwedAmount(WithdrawalBatch memory batch) internal pure returns (uint104) {\n    return batch.scaledTotalAmount - batch.scaledAmountBurned;\n  }\n\n  /**\n   * @dev Get the amount of assets which are not already reserved\n   *      for prior withdrawal batches. This must only be used on\n   *      the latest withdrawal batch to expire.\n   */\n  function availableLiquidityForPendingBatch(\n    WithdrawalBatch memory batch,\n    MarketState memory state,\n    uint256 totalAssets\n  ) internal pure returns (uint256) {\n    // Subtract normalized value of pending scaled withdrawals, processed\n    // withdrawals and protocol fees.\n    uint256 priorScaledAmountPending = (state.scaledPendingWithdrawals - batch.scaledOwedAmount());\n    uint256 unavailableAssets = state.normalizedUnclaimedWithdrawals +\n      state.normalizeAmount(priorScaledAmountPending) +\n      state.accruedProtocolFees;\n    return totalAssets.satSub(unavailableAssets);\n  }\n}\n"},"src/libraries/FunctionTypeCasts.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.20;\n\nimport { MarketParameters } from '../interfaces/WildcatStructsAndEnums.sol';\nimport { MarketState } from '../libraries/MarketState.sol';\nimport { WithdrawalBatch } from '../libraries/Withdrawal.sol';\n\n/**\n * @dev Type-casts to convert functions returning raw (uint) pointers\n *      to functions returning memory pointers of specific types.\n *\n *      Used to get around solc's over-allocation of memory when\n *      dynamic return parameters are re-assigned.\n *\n *      With `viaIR` enabled, calling any of these functions is a noop.\n */\nlibrary FunctionTypeCasts {\n  /**\n   * @dev Function type cast to avoid duplicate declaration/allocation\n   *      of MarketState return parameter.\n   */\n  function asReturnsMarketState(\n    function() internal view returns (uint256) fnIn\n  ) internal pure returns (function() internal view returns (MarketState memory) fnOut) {\n    assembly {\n      fnOut := fnIn\n    }\n  }\n\n  /**\n   * @dev Function type cast to avoid duplicate declaration/allocation\n   *      of MarketState and WithdrawalBatch return parameters.\n   */\n  function asReturnsPointers(\n    function() internal view returns (MarketState memory, uint32, WithdrawalBatch memory) fnIn\n  ) internal pure returns (function() internal view returns (uint256, uint32, uint256) fnOut) {\n    assembly {\n      fnOut := fnIn\n    }\n  }\n\n  /**\n   * @dev Function type cast to avoid duplicate declaration/allocation\n   *      of manually allocated MarketParameters in market constructor.\n   */\n  function asReturnsMarketParameters(\n    function() internal view returns (uint256) fnIn\n  ) internal pure returns (function() internal view returns (MarketParameters memory) fnOut) {\n    assembly {\n      fnOut := fnIn\n    }\n  }\n}\n"},"src/interfaces/IChainalysisSanctionsList.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.20;\n\ninterface IChainalysisSanctionsList {\n  function isSanctioned(address addr) external view returns (bool);\n}\n"},"src/interfaces/IWildcatSanctionsSentinel.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.20;\n\ninterface IWildcatSanctionsSentinel {\n  event NewSanctionsEscrow(\n    address indexed borrower,\n    address indexed account,\n    address indexed asset\n  );\n\n  event SanctionOverride(address indexed borrower, address indexed account);\n\n  event SanctionOverrideRemoved(address indexed borrower, address indexed account);\n\n  struct TmpEscrowParams {\n    address borrower;\n    address account;\n    address asset;\n  }\n\n  function WildcatSanctionsEscrowInitcodeHash() external pure returns (bytes32);\n\n  // Returns immutable sanctions list contract\n  function chainalysisSanctionsList() external view returns (address);\n\n  // Returns immutable arch-controller\n  function archController() external view returns (address);\n\n  // Returns temporary escrow params\n  function tmpEscrowParams()\n    external\n    view\n    returns (address borrower, address account, address asset);\n\n  // Returns result of `chainalysisSanctionsList().isSanctioned(account)`\n  function isFlaggedByChainalysis(address account) external view returns (bool);\n\n  // Returns result of `chainalysisSanctionsList().isSanctioned(account)`\n  // if borrower has not overridden the status of `account`\n  function isSanctioned(address borrower, address account) external view returns (bool);\n\n  // Returns boolean indicating whether `borrower` has overridden the\n  // sanction status of `account`\n  function sanctionOverrides(address borrower, address account) external view returns (bool);\n\n  function overrideSanction(address account) external;\n\n  function removeSanctionOverride(address account) external;\n\n  // Returns create2 address of sanctions escrow contract for\n  // combination of `borrower,account,asset`\n  function getEscrowAddress(\n    address borrower,\n    address account,\n    address asset\n  ) external view returns (address escrowContract);\n\n  /**\n   * @dev Returns a create2 deployment of WildcatSanctionsEscrow unique to each\n   *      combination of `account,borrower,asset`. If the contract is already\n   *      deployed, returns the existing address.\n   *\n   *      Emits `NewSanctionsEscrow(borrower, account, asset)` if a new contract\n   *      is deployed.\n   *\n   *      The sanctions escrow contract is used to hold assets until either the\n   *      sanctioned status is lifted or the assets are released by the borrower.\n   */\n  function createEscrow(\n    address borrower,\n    address account,\n    address asset\n  ) external returns (address escrowContract);\n}\n"},"src/WildcatSanctionsEscrow.sol":{"content":"// SPDX-License-Identifier: Apache-2.0 WITH LicenseRef-Commons-Clause-1.0\npragma solidity >=0.8.20;\n\nimport './interfaces/IERC20.sol';\nimport './interfaces/IWildcatSanctionsEscrow.sol';\nimport './interfaces/IWildcatSanctionsSentinel.sol';\nimport './libraries/LibERC20.sol';\n\ncontract WildcatSanctionsEscrow is IWildcatSanctionsEscrow {\n  using LibERC20 for address;\n\n  address public immutable override sentinel;\n  address public immutable override borrower;\n  address public immutable override account;\n  address internal immutable asset;\n\n  constructor() {\n    sentinel = msg.sender;\n    (borrower, account, asset) = IWildcatSanctionsSentinel(sentinel).tmpEscrowParams();\n  }\n\n  function balance() public view override returns (uint256) {\n    return IERC20(asset).balanceOf(address(this));\n  }\n\n  function canReleaseEscrow() public view override returns (bool) {\n    return !IWildcatSanctionsSentinel(sentinel).isSanctioned(borrower, account);\n  }\n\n  function escrowedAsset() public view override returns (address, uint256) {\n    return (asset, balance());\n  }\n\n  function releaseEscrow() public override {\n    if (!canReleaseEscrow()) revert CanNotReleaseEscrow();\n\n    uint256 amount = balance();\n    address _account = account;\n    address _asset = asset;\n\n    asset.safeTransfer(_account, amount);\n\n    emit EscrowReleased(_account, _asset, amount);\n  }\n}\n"},"src/access/IRoleProvider.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\ninterface IRoleProvider {\n  function isPullProvider() external view returns (bool);\n\n  function getCredential(address account) external view returns (uint32 timestamp);\n\n  /**\n   * @dev Validate a credential (e.g. a signature from an access token granter) for an account.\n   * @param account The account to validate the credential for.\n   * @param data The data to validate the credential with.\n   * @return timestamp The timestamp at which the credential was granted.\n   */\n  function validateCredential(\n    address account,\n    bytes calldata data\n  ) external returns (uint32 timestamp);\n}\n"},"src/access/ProviderStructs.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n// ========================================================================== //\n//        Common structs for OpenTermHooks and FixedTermHooks        //\n// ========================================================================== //\n\n/**\n * @dev Input parameters to create a new role provider with a call to a provider factory.\n * @param timeToLive Time to live for the new provider.\n * @param providerFactoryCalldata Calldata to be passed to the provider factory.\n */\nstruct CreateProviderInputs {\n  uint32 timeToLive;\n  bytes providerFactoryCalldata;\n}\n\n/**\n * @dev Input parameters to add a role provider that has already been deployed.\n * @param providerAddress Address of the role provider.\n * @param timeToLive Time to live for the provider.\n */\nstruct ExistingProviderInputs {\n  address providerAddress;\n  uint32 timeToLive;\n}\n\n/**\n * @dev Constructor parameters for new access control or fixed term hooks instance.\n * @param name Name of the hooks instance.\n * @param roleProviderFactory Address of the role provider factory.\n * @param newProviderInputs Inputs for creating new role providers.\n * @param existingProviders Inputs for adding existing role providers.\n */\nstruct NameAndProviderInputs {\n  string name;\n  address roleProviderFactory;\n  CreateProviderInputs[] newProviderInputs;\n  ExistingProviderInputs[] existingProviders;\n}\n"},"src/access/IRoleProviderFactory.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\ninterface IRoleProviderFactory {\n  function createRoleProvider(bytes calldata data) external returns (address);\n}\n"},"src/libraries/StringQuery.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.20;\n\nimport { LibBit } from 'solady/utils/LibBit.sol';\n\nusing LibBit for uint256;\n\nuint256 constant OnlyFullWordMask = 0xffffffe0;\n\nfunction bytes32ToString(bytes32 value) pure returns (string memory str) {\n  uint256 size;\n  unchecked {\n    uint256 sizeInBits = 255 - uint256(value).ffs();\n    size = (sizeInBits + 7) / 8;\n  }\n  assembly {\n    str := mload(0x40)\n    mstore(0x40, add(str, 0x40))\n    mstore(str, size)\n    mstore(add(str, 0x20), value)\n  }\n}\n\nfunction queryStringOrBytes32AsString(\n  address target,\n  uint256 leftPaddedFunctionSelector,\n  uint256 leftPaddedGenericErrorSelector\n) view returns (string memory str) {\n  bool isBytes32;\n  assembly {\n    mstore(0, leftPaddedFunctionSelector)\n    let status := staticcall(gas(), target, 0x1c, 0x04, 0, 0)\n    isBytes32 := eq(returndatasize(), 0x20)\n    // If call fails or function returns invalid data, revert.\n    // Strings are always right padded to full words - if the returndata\n    // is not 32 bytes (string encoded as bytes32) or >95 bytes (minimum abi\n    // encoded string) it is an invalid string.\n    if or(iszero(status), iszero(or(isBytes32, gt(returndatasize(), 0x5f)))) {\n      // Check if call failed\n      if iszero(status) {\n        // Check if any revert data was given\n        if returndatasize() {\n          returndatacopy(0, 0, returndatasize())\n          revert(0, returndatasize())\n        }\n        // If not, throw a generic error\n        mstore(0, leftPaddedGenericErrorSelector)\n        revert(0x1c, 0x04)\n      }\n      // If the returndata is the wrong size, `revert InvalidReturnDataString()`\n      mstore(0, 0x4cb9c000)\n      revert(0x1c, 0x04)\n    }\n  }\n  if (isBytes32) {\n    bytes32 value;\n    assembly {\n      returndatacopy(0x00, 0x00, 0x20)\n      value := mload(0)\n    }\n    str = bytes32ToString(value);\n  } else {\n    // If returndata is a string, copy the length and value\n    assembly {\n      str := mload(0x40)\n      // Get allocation size for the string including the length and data.\n      // Rounding down returndatasize to nearest word because the returndata\n      // has an extra offset word.\n      let allocSize := and(sub(returndatasize(), 1), OnlyFullWordMask)\n      mstore(0x40, add(str, allocSize))\n      // Copy returndata after the offset\n      returndatacopy(str, 0x20, sub(returndatasize(), 0x20))\n      let length := mload(str)\n      // Check if the length matches the returndatasize.\n      // The encoded string should have the string length rounded up to the nearest word\n      // as well as two words for length and offset.\n      let expectedReturndataSize := add(allocSize, 0x20)\n      if xor(returndatasize(), expectedReturndataSize) {\n        mstore(0, 0x4cb9c000)\n        revert(0x1c, 0x04)\n      }\n    }\n  }\n}\n"},"src/libraries/FIFOQueue.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.20;\n\nstruct FIFOQueue {\n  uint128 startIndex;\n  uint128 nextIndex;\n  mapping(uint256 => uint32) data;\n}\n\n// @todo - make array tightly packed for gas efficiency with multiple reads/writes\n//         also make a memory version of the array with (nextIndex, startIndex, storageSlot)\n//         so that multiple storage reads aren't required for tx's using multiple functions\n\nusing FIFOQueueLib for FIFOQueue global;\n\nlibrary FIFOQueueLib {\n  error FIFOQueueOutOfBounds();\n\n  function empty(FIFOQueue storage arr) internal view returns (bool) {\n    return arr.nextIndex == arr.startIndex;\n  }\n\n  function first(FIFOQueue storage arr) internal view returns (uint32) {\n    if (arr.startIndex == arr.nextIndex) {\n      revert FIFOQueueOutOfBounds();\n    }\n    return arr.data[arr.startIndex];\n  }\n\n  function at(FIFOQueue storage arr, uint256 index) internal view returns (uint32) {\n    index += arr.startIndex;\n    if (index >= arr.nextIndex) {\n      revert FIFOQueueOutOfBounds();\n    }\n    return arr.data[index];\n  }\n\n  function length(FIFOQueue storage arr) internal view returns (uint128) {\n    return arr.nextIndex - arr.startIndex;\n  }\n\n  function values(FIFOQueue storage arr) internal view returns (uint32[] memory _values) {\n    uint256 startIndex = arr.startIndex;\n    uint256 nextIndex = arr.nextIndex;\n    uint256 len = nextIndex - startIndex;\n    _values = new uint32[](len);\n\n    for (uint256 i = 0; i < len; i++) {\n      _values[i] = arr.data[startIndex + i];\n    }\n\n    return _values;\n  }\n\n  function push(FIFOQueue storage arr, uint32 value) internal {\n    uint128 nextIndex = arr.nextIndex;\n    arr.data[nextIndex] = value;\n    arr.nextIndex = nextIndex + 1;\n  }\n\n  function shift(FIFOQueue storage arr) internal {\n    uint128 startIndex = arr.startIndex;\n    if (startIndex == arr.nextIndex) {\n      revert FIFOQueueOutOfBounds();\n    }\n    delete arr.data[startIndex];\n    arr.startIndex = startIndex + 1;\n  }\n\n  function shiftN(FIFOQueue storage arr, uint128 n) internal {\n    uint128 startIndex = arr.startIndex;\n    if (startIndex + n > arr.nextIndex) {\n      revert FIFOQueueOutOfBounds();\n    }\n    for (uint256 i = 0; i < n; i++) {\n      delete arr.data[startIndex + i];\n    }\n    arr.startIndex = startIndex + n;\n  }\n}\n"},"src/interfaces/IWildcatSanctionsEscrow.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.20;\n\ninterface IWildcatSanctionsEscrow {\n  event EscrowReleased(address indexed account, address indexed asset, uint256 amount);\n\n  error CanNotReleaseEscrow();\n\n  function sentinel() external view returns (address);\n\n  function borrower() external view returns (address);\n\n  function account() external view returns (address);\n\n  function balance() external view returns (uint256);\n\n  function canReleaseEscrow() external view returns (bool);\n\n  function escrowedAsset() external view returns (address token, uint256 amount);\n\n  function releaseEscrow() external;\n}\n"},"lib/solady/src/utils/LibBit.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Library for bit twiddling and boolean operations.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibBit.sol)\n/// @author Inspired by (https://graphics.stanford.edu/~seander/bithacks.html)\nlibrary LibBit {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                  BIT TWIDDLING OPERATIONS                  */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Find last set.\n    /// Returns the index of the most significant bit of `x`,\n    /// counting from the least significant bit position.\n    /// If `x` is zero, returns 256.\n    function fls(uint256 x) internal pure returns (uint256 r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r := or(shl(8, iszero(x)), shl(7, lt(0xffffffffffffffffffffffffffffffff, x)))\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\n            r := or(r, shl(2, lt(0xf, shr(r, x))))\n            r := or(r, byte(shr(r, x), hex\"00000101020202020303030303030303\"))\n        }\n    }\n\n    /// @dev Count leading zeros.\n    /// Returns the number of zeros preceding the most significant one bit.\n    /// If `x` is zero, returns 256.\n    function clz(uint256 x) internal pure returns (uint256 r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\n            r := or(r, shl(2, lt(0xf, shr(r, x))))\n            // forgefmt: disable-next-item\n            r := add(iszero(x), xor(255,\n                or(r, byte(shr(r, x), hex\"00000101020202020303030303030303\"))))\n        }\n    }\n\n    /// @dev Find first set.\n    /// Returns the index of the least significant bit of `x`,\n    /// counting from the least significant bit position.\n    /// If `x` is zero, returns 256.\n    /// Equivalent to `ctz` (count trailing zeros), which gives\n    /// the number of zeros following the least significant one bit.\n    function ffs(uint256 x) internal pure returns (uint256 r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Isolate the least significant bit.\n            let b := and(x, add(not(x), 1))\n\n            r := or(shl(8, iszero(x)), shl(7, lt(0xffffffffffffffffffffffffffffffff, b)))\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, b))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, b))))\n\n            // For the remaining 32 bits, use a De Bruijn lookup.\n            // forgefmt: disable-next-item\n            r := or(r, byte(and(div(0xd76453e0, shr(r, b)), 0x1f),\n                0x001f0d1e100c1d070f090b19131c1706010e11080a1a141802121b1503160405))\n        }\n    }\n\n    /// @dev Returns the number of set bits in `x`.\n    function popCount(uint256 x) internal pure returns (uint256 c) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let max := not(0)\n            let isMax := eq(x, max)\n            x := sub(x, and(shr(1, x), div(max, 3)))\n            x := add(and(x, div(max, 5)), and(shr(2, x), div(max, 5)))\n            x := and(add(x, shr(4, x)), div(max, 17))\n            c := or(shl(8, isMax), shr(248, mul(x, div(max, 255))))\n        }\n    }\n\n    /// @dev Returns whether `x` is a power of 2.\n    function isPo2(uint256 x) internal pure returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Equivalent to `x && !(x & (x - 1))`.\n            result := iszero(add(and(x, sub(x, 1)), iszero(x)))\n        }\n    }\n\n    /// @dev Returns `x` reversed at the bit level.\n    function reverseBits(uint256 x) internal pure returns (uint256 r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Computing masks on-the-fly reduces bytecode size by about 500 bytes.\n            let m := not(0)\n            r := x\n            for { let s := 128 } 1 {} {\n                m := xor(m, shl(s, m))\n                r := or(and(shr(s, r), m), and(shl(s, r), not(m)))\n                s := shr(1, s)\n                if iszero(s) { break }\n            }\n        }\n    }\n\n    /// @dev Returns `x` reversed at the byte level.\n    function reverseBytes(uint256 x) internal pure returns (uint256 r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Computing masks on-the-fly reduces bytecode size by about 200 bytes.\n            let m := not(0)\n            r := x\n            for { let s := 128 } 1 {} {\n                m := xor(m, shl(s, m))\n                r := or(and(shr(s, r), m), and(shl(s, r), not(m)))\n                s := shr(1, s)\n                if eq(s, 4) { break }\n            }\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                     BOOLEAN OPERATIONS                     */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    // A Solidity bool on the stack or memory is represented as a 256-bit word.\n    // Non-zero values are true, zero is false.\n    // A clean bool is either 0 (false) or 1 (true) under the hood.\n    // Usually, if not always, the bool result of a regular Solidity expression,\n    // or the argument of a public/external function will be a clean bool.\n    // You can usually use the raw variants for more performance.\n    // If uncertain, test (best with exact compiler settings).\n    // Or use the non-raw variants (compiler can sometimes optimize out the double `iszero`s).\n\n    /// @dev Returns `x & y`. Inputs must be clean.\n    function rawAnd(bool x, bool y) internal pure returns (bool z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := and(x, y)\n        }\n    }\n\n    /// @dev Returns `x & y`.\n    function and(bool x, bool y) internal pure returns (bool z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := and(iszero(iszero(x)), iszero(iszero(y)))\n        }\n    }\n\n    /// @dev Returns `x | y`. Inputs must be clean.\n    function rawOr(bool x, bool y) internal pure returns (bool z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := or(x, y)\n        }\n    }\n\n    /// @dev Returns `x | y`.\n    function or(bool x, bool y) internal pure returns (bool z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := or(iszero(iszero(x)), iszero(iszero(y)))\n        }\n    }\n\n    /// @dev Returns 1 if `b` is true, else 0. Input must be clean.\n    function rawToUint(bool b) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := b\n        }\n    }\n\n    /// @dev Returns 1 if `b` is true, else 0.\n    function toUint(bool b) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := iszero(iszero(b))\n        }\n    }\n}\n"}},"settings":{"remappings":["src/=src/","forge-std/=lib/forge-std/src/","ds-test/=lib/ds-test/src/","solmate/=lib/solmate/src/","solady/=lib/solady/src/","openzeppelin/=lib/openzeppelin-contracts/","sol-utils/=lib/sol-utils/src/","ethereum-access-token/=lib/ethereum-access-token/contracts/","erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/","openzeppelin-contracts/=lib/openzeppelin-contracts/","vulcan/=lib/vulcan/src/"],"optimizer":{"enabled":true,"runs":50000},"metadata":{"useLiteralContent":false,"bytecodeHash":"none","appendCBOR":true},"outputSelection":{"*":{"*":["abi","evm.bytecode","evm.deployedBytecode","evm.methodIdentifiers","ir","irOptimized","metadata"]}},"evmVersion":"cancun","viaIR":true,"libraries":{}}}
